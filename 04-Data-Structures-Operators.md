Отлично! Я подготовлю ваш текст в формате Markdown, сохранив все содержимое без изменений, но добавив соответствующее форматирование для улучшения читаемости. Вот результат:

````markdown
# ДИСТРУКТУРИЗАЦИЯ МАССИВ

Диструктуризация - это функция ES6 которая позволяет распаковывать значения из массива или объекта в отдельное переменное.
Другими словами диструктуризация это разбиения сложные структуры данных на более мелкие, например на переменные.

К примеру если бы мы извлекали значение из массива без диструктуризация:

**Пример:**

```javascript
const arr = [2, 3, 4];
const a = arr[0];
const b = arr[1];
const c = arr[2];
```
````

**Пример извлечение значение с помощью диструктуризация:**

```javascript
const [x, y, z] = arr;
console.log(x, y, z); // result / 2 3 4
```

Создали сразу три переменных и присвоили им значения массива. Это выглядит как массив, но на самом деле это не так, это просто присваивания с диструктуризацией.

**Пример Ресторана:**

```javascript
const restaurant = {
  name: "Classico Italiano",
  location: "Via Angelo Tavanti 23, Firenze, Italy",
  categories: ["Italian", "Pizzeria", "Vegetarian", "Organic"],
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  mainMenu: ["Pizza", "Pasta", "Risotto"],
};
```

Извлекаем значения с помощью диструктуризации:

```javascript
let [main, , secondary] = restaurant.categories;
console.log(main, secondary); // result / Italian, Vegetarian
```

Извлекли значения из свойство categories, и пропустили одно значения 'Pizzeria' с помощью запятым, и сразу получили следующую значения 'Vegetarian'.

Если бы мы хотели бы поменять местами main и secondary без диструктуризации:

**Пример:**

```javascript
const temp = main;
main = secondary;
secondary = temp;
console.log(main, secondary); // result / Vegetarian Italian
```

Здесь мы поменяли значения переменных main и secondary местами.

Меняем местами main и secondary с помощью диструктуризации:

**Пример:**

```javascript
[main, secondary] = [secondary, main]; // result / Vegetarian Italian
```

Мы сначала создали новый массив с инвертированными значениями, то есть сначала secondary а потом main. А потом диструктурируем их, то есть значения secondary присваиваем main, значения main присваиваем secondary.

Еще одна хитрость диструктуризации заключается в том, что функция может возвращать массив, а затем мы можем сразу же диструктурировать результат в разные переменные. Это позволяет нам возвращать несколько значений из функции. Для этого мы создаем функцию метод для нашего объекта restaurant:

**Пример:**

```javascript
const restaurant = {
  name: "Classico Italiano",
  location: "Via Angelo Tavanti 23, Firenze, Italy",
  categories: ["Italian", "Pizzeria", "Vegetarian", "Organic"],
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  mainMenu: ["Pizza", "Pasta", "Risotto"],

  order: function (starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },
};
console.log(restaurant.order(2, 0)); // result / Garlic Bread, Pizza
```

Теперь мы можем диструктурировать этот массив, это и есть диструктурирующее присваивания.

**Пример:**

```javascript
const [starter, mainCourse] = restaurant.order(2, 0);
console.log(starter, mainCourse); // result / Garlic Bread, Pizza
```

Вот так мы получаем два значения из функции.

Давайте сделаем еще один шаг: Что будет если у нас есть массив внутри массива, то есть вложенный массив.

**Пример:**

```javascript
const nested = [2, 4, [5, 6]];
const [i, , j] = nested;
console.log(i, j); // result / 2, >(2)[5, 6]
```

Таким образом мы присвоили значения из массива сразу на 2 переменные i и j. Для i это 2, а для j это вложенный массив >(2)[5, 6].

А что если мы хотим получить отдельные значения вложенного массива [5, 6]? Тогда нам придется диструктурировать внутри диструктурирования.

**Пример:**

```javascript
const nested = [2, 4, [5, 6]];
const [i, , [j, k]] = nested;
console.log(i, j, k); // result / 2, 5, 6
```

Мы также можем задать значения по умолчанию для переменных при их извлечении, это будет очень полезно если мы незнаем длину массива. Давайте попытаемся извлечь сразу 3 значение из массива у которого есть только 2 значения.

**Пример:**

```javascript
const [p, q, r] = [8, 9];
console.log(p, q, r); // result / 8, 9, undefined
```

Мы видим что для третьего переменного (r) присвоино значения undefined. Но как я и написал мы можем задать значения для переменных по умолчанию:

**Пример:**

```javascript
const [p = 1, q = 1, r = 1] = [8, 9];
console.log(p, q, r); // result / 8, 9, 1
```

Здесь у нас есть значения по умолчанию для каждого переменного (p, q, r) и это значения 1. Но потом мы присвоили этим переменным значения массив [8, 9]. После этого для переменного (p) присвоино значения [8] из массива, для переменного (q) присвоино значения [9] из массива, для переменного (r) значения осталось по умолчанию и это 1.

---

# ДИСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ

Для диструктуризации объектов мы используем именно фигурные скобки {}, потому что именно так мы создаем объекты, верно? Тогда все что нам нужно сделать, это указать имена переменных которые точно соответствуют именам свойств, которые мы хотим извлечь из объектов.

**Пример объекта Ресторан:**

```javascript
const restaurant = {
  name: "Classico Italiano",
  location: "Via Angelo Tavanti 23, Firenze, Italy",
  categories: ["Italian", "Pizzeria", "Vegetarian", "Organic"],
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  mainMenu: ["Pizza", "Pasta", "Risotto"],

  order: function (starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },

  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0, // Open 24 hours
      close: 24,
    },
  },
};
```

Давайте диструктуриреум объект restaurant: Определяем имена переменных, нам нужно указать точные имена свойств чтобы извлечь свойств из этого объекта restaurant. По скольку в объекте порядок элементов не важен, нам не нужно в ручную пропускать элементы как мы делали это в массиве используя запятую.

**Пример:**

```javascript
const { name, openingHours, categories } = restaurant;
console.log(name, openingHours, categories);
// result / Classico Italiano,
            >{thu:{...}, fri:{...}, sat:{...}},
            >(4)['Italian', 'Pizzeria', 'Vegetarian', 'Organic']
```

Мы создали 3 новые переменные и присвоили им значения свойств объекта restaurant с помощью диструктуризации.

Но что, если мы хотим имена переменных, отличались от названии свойств? Для этого мы прежнему обращаемся к названиям свойств объекта restaurant, а потом ставим двоиточье и пишем названия переменной. Таким образом мы меняем названия переменной и присвоим ему значения свойств объекта restaurant.

**Пример:**

```javascript
const {
  name: restaurantName,
  openingHours: hours,
  categories: tags,
} = restaurant;
console.log(restaurantName, hours, tags);
// result / Classico Italiano,
            >{thu:{...}, fri:{...}, sat:{...}},
            >(4)['Italian', 'Pizzeria', 'Vegetarian', 'Organic']
```

Когда мы получаем данные из стороннего сервера и мы незнаем какие данные мы получим, мы можем задать значения по умолчанию пустой массив [] для свойств который не существует в объекте. Это делается для того чтобы не получить значения undefined для не существующему свойству. В нашем случаем объект restaurant это жестко запрограммированные данные, и по этому когда мы получаем данные из стороннего сервера мы можем не знать какие данные мы получим.

**Пример для значения по умолчанию:**

```javascript
const { menu = [], starterMenu: starters = [] } = restaurant;
console.log(menu, starters); // result / [], >(4)['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad']
```

Здесь мы видим что свойство menu не существует в нашем объекте restaurant, для этого мы присвоили ему значения по умолчанию пустой массив [], чтобы не получить значения undefined. А для существующему свойству starterMenu тоже присвоили значения пустой массив [], создав новое названия переменной starters, но так как он существует в нашем объекте restaurant, ему присваивается значения свойств который есть в нашем объекте restaurant.

Мутация переменных при диструктуризации объектов: Мы уже делали это с массивами когда меняли переменных местами:

**Пример:**

```javascript
[main, secondary] = [secondary, main]; // result / Vegetarian Italian
```

Но с объектами это работает немного иначе.

**Пример:**

```javascript
let a = 111;
let b = 999;
const obj = { a: 23, b: 7, c: 14 };
({ a, b } = obj);
console.log(a, b); // 23, 7
```

Тут сперва объявили переменные a и b и присвоили им значения 111 и 999. После мы видим что у нас объект obj со свойствами a: b: c:, и эти названия свойств совпадают с названиями переменных. После мы хотим диструктурировать переменные a и b, то есть присвоить им значения свойств a: b: объекта obj. Для этого мы переместили наши переменные a и b внутри круглых и фигрных скобок, и присвоили им наш объект obj. Таким образом переменные a и b получили значения свойств a: b: объекта obj.

### Почему нужны круглые скобки в `({ a, b } = obj)`?

В JavaScript **фигурные скобки `{}` имеют двойное значение**:

1. Синтаксис блока кода (например, в `if`, `for`, функциях)
2. Синтаксис объекта

Когда вы пишете деструктуризацию **без объявления переменных** (т.е. для уже существующих переменных), интерпретатор видит `{` в начале строки как начало **блока кода**, а не объекта. Это вызывает синтаксическую ошибку.

---

### Пример проблемы:

```javascript
let a = 111;
let b = 999;
const obj = { a: 23, b: 7 };

// Без скобок - ошибка!
{ a, b } = obj; // SyntaxError: Unexpected token '='
```

Интерпретатор читает это как:

1. `{` → начало блока кода
2. `a, b` → выражения внутри блока
3. `} = obj` → невалидный синтаксис

---

### Решение: Круглые скобки

```javascript
({ a, b } = obj); // Работает!
```

Круглые скобки **заставляют JavaScript интерпретировать `{...}` как выражение** (деструктуризацию объекта), а не как блок кода.

---

### Когда скобки НЕ нужны?

Если вы одновременно **объявляете переменные** с помощью `const`, `let`, `var`:

```javascript
// Без скобок - работает
const { a, b } = obj;

// С объявлением переменных - тоже работает
let x, y;
({ x, y } = obj); // Со скобками
```

---

### Итог:

| Ситуация                  | Нужны скобки? | Пример                  |
| ------------------------- | ------------- | ----------------------- |
| Переменные объявляются    | ❌ Нет        | `const {a,b} = obj;`    |
| Переменные уже существуют | ✅ Да         | `({a,b} = obj);`        |
| В середине выражения      | ❌ Нет        | `someFunc({a,b} = obj)` |

Давайте теперь поговорим о диструктуризации вложенных объектов: У нас есть объект {restaurant} и внутри него есть вложенный объект {openingHours} и еще внутри него есть вложенные объекты {thu}, {fri}, {sat} со своими свойствами и значениями. Допустим мы хотим объявить новые переменные и хотим им присвоить значения свойств open и close вложенного объекта fri.

**Пример:**

```javascript
const {
  fri: { open, close },
} = openingHours;
console.log(open, close); // result / 11, 23
```

Таким образом для переменных open и close присваивается значения свойств open: close: вложенного объекта fri. Это все сработало потому что здесь у нас названия свойств и переменных одинаковые. Точно также мы можем создавать новые названия для переменных отличающиеся от названии свойств объекта fti. Для этого мы пишем вот так:

```javascript
const {
  fri: { open: o, close: c },
} = openingHours;
console.log(o, c); // result / 11, 23
```

Сперва обратились к свойствам open: и close: а потом создали новые названия для переменных o и c.

> > > Крутое практическое применения диструктуризации:<<< Для этого вернемся к нашему объекту restaurant, и создадим новую функцию Method, внутри объекта restaurant. Вместо того чтобы указывать параметры для функции в ручную, мы можем просто передать объект в функцию в качестве аргумента, и функция сразу же диструктурирует этот объект.

**Пример:**

```javascript
const restaurant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],

  order: function(starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },

  orderDelivery: function({starterIndex, mainIndex, time, address}) {
    console.log(`Заказ получен! ${this.starterMenu[starterIndex]}
    и ${this.mainMenu[mainIndex]} будут доставлены
    по указанному адресу ${address} в назначенное время ${time}`);
  },
};

// вызов функции
restaurant.orderDelivery({
  time: '22:30',
  address: 'Via del Sole, 21',
  mainIndex: 2,
  starterIndex: 2,
});
// result / Заказ получен! Garlic Bread и Risotto будут доставлены
по указанному адресу Via del Sole, 21 в назначенное время 22:30.
```

Здесь мы видим что названия параметр и названия свойств объекта который мы передали как аргумент для функции orderDelivery(), названия являются одинаковыми. И по этому мы получаем диструктуризацию в параметрах функции, то есть получаем доступ к значениям свойств объекта в параметрах функции.

Но мы еще мы можем использовать и другие знания которые мы получили, например значения по умолчанию.

**Пример:**

```javascript
const restaurant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],

  order: function(starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },

  orderDelivery: function({starterIndex = 1, mainIndex = 0, time = '20:00', address}) {
    console.log(`Заказ получен! ${this.starterMenu[starterIndex]}
    и ${this.mainMenu[mainIndex]} будут доставлены
    по указанному адресу ${address} в назначенное время ${time}`);
  },
};

// вызов функции
restaurant.orderDelivery({
  time: '22:30',
  address: 'Via del Sole, 21',
  mainIndex: 2,
  starterIndex: 2,
});
// result / Заказ получен! Garlic Bread и Risotto будут доставлены
по указанному адресу Via del Sole, 21 в назначенное время 22:30.

// вызов функции (второй раз)
restaurant.orderDelivery({
  address: 'Via del Sole, 21',
  starterIndex: 1,
});
// result / Заказ получен! Bruschetta и Pizza будут доставлены
по указанному адресу Via del Sole, 21 в назначенное время 20:00.
```

Здесь при втором вызове функции передали другой объект как аргумент, со свойствами address и starterIndex. А остальное будет взято из значения по умолчанию, который мы установили для диструктуризации. То есть значению по умолчанию в параметрах самой функции orderDelivery(). Здесь мы видим что JS берет значения по умолчанию из параметр функции, которых нет в объекте который мы передали как аргумент для параметр функции orderDelivery().

---

# ОПЕРАТОР РАСШИРЕНИЯ SPREAD (...)

С его помощью мы можем преобразовать массив в отдельные элементы. То есть по сути распоковать все элементы массива по отдельности. Допустим у нас есть массив:

```javascript
const arr = [7, 8, 9];
```

Теперь мы хотим создать новый массив на основе этого, но с некоторыми новыми элементами в начале. С нашими знаниями мы бы сделали это перебирая весь этот массив, или еще хуже в ручную.

**Пример:**

```javascript
const badNewArr = [1, 2, arr[0], arr[1], arr[2]];
console.log(badNewArr); // result / >(5)[1, 2, 7, 8, 9]
```

Теперь когда у нас есть ES6, мы можем сделать это гораздо лучше с помощью оператора расширения spread (...).

**Пример:**

```javascript
const newArr = [1, 2, ...arr];
console.log(newArr); // result / >(5)[1, 2, 7, 8, 9]
```

Оператор расширения просто берет все значения массива [arr] и записывает их по отдельности в наш новый массив [newArr].

Если бы мы написали бы вот так, без оператора spread:

```javascript
const newArr = [1, 2, arr];
console.log(newArr); // result / >(3) [1, 2, Array(3)]
```

Мы бы включили весь массив [arr] как отдельное одно значения в наш новый массив [newArr].

Вторая ситуация когда оператор расширения полезен, это когда мы передаем аргументы в функцию. Например давайте представим что нам нужно вывести отдельные элементы этого нового массива [newArr].

```javascript
const newArr = [1, 2, ...arr];
console.log(newArr); // result / >(5)[1, 2, 7, 8, 9]
console.log(...newArr); // result / 1 2 7 8 9 (отдельные элементы массива)
```

Таким образом мы можем эти отдельные элементы передать в виде аргумента для параметра в функцию.

Давайте представим что мы хотим новое меню для нашего ресторана: То есть мы хотим внутри объекта restaurant обратится к свойству массив mainMenu: и добавить внутри этого свойство массива новое значение то есть меню.

**Пример:**

```javascript
const newMenu = [...restaurant.mainMenu, "Gnocci"];
console.log(newMenu); // result / >(4)['Pizza', 'Pasta', 'Risotto', 'Gnocci']
```

Мы сперва обращаемся к оператору расширения и выводим отдельные элементы этого массива mainMenu, потом добавляем новый элемент внутри него и это 'Gnocci'. Здесь мы создали абсолютно новый массив, внутри переменной newMenu.

Далее давайте рассмотрим два важных случаев использования оператора расширения spread, а именно создание не глубоких копий массивов и объединения двух массивов. Допустим на нужно скопировать массив:

```javascript
const mainMenuCopy = [...restaurant.mainMenu];
console.log(mainMenuCopy); // result / >(3)['Pizza', 'Pasta', 'Risotto']
```

Таким образом мы только что создали не глубокую копию этого массива mainMenu.

Теперь чтобы объеденить два массива, мы можем использовать ту же технику.

```javascript
const menu = [...restaurant.starterMenu, ...restaurant.mainMenu];
console.log(menu); // result /
>(7)['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad', 'Pizza', 'Pasta', 'Risotto']
```

Оператор расширения работает с массивами и также работает со всеми итерируемыми объектами. Что такое итерируемый объект? В JS есть разные итерируемые объекты, и мы поговорим о них в конце курса. Но пока мы должны знать что итерируемые объекты являются массивы, строки, и тд. Но не объекты. Таким образом большинство встроенных структур данных в JS, являются итерируемыми объектами, кроме объектов.

Теперь если строки являются итерируемыми объектами, мы также можем использовать оператор расширения и для строк.

**Пример:**

```javascript
const str = "Jonas";
```

Мы хотим создать массив, содержащияся отдельные буквы и еще нескольких элементов.

**Пример:**

```javascript
const letters = [...str, " ", "S."];
console.log(letters); // result / >(7)['J', 'o', 'n', 'a', 's', ' ', 'S.']
```

Теперь каждая буква этой строки является отдельным элементом. Только помните что оператор расширения можно использовать только при создания массива, или передачей значения в функцию. Например мы можем использовать это для создания строки с помощью шаблона, и здесь это не сработает.

```javascript
console.log(`${...str} Rabadanov`); // result / Unexpected token '...'
```

Давайте напишем собственную функцию которую принимает несколько аргументов, и используем оператор расширения для передачи этих аргументов. Добавим для нашего объекта restaurant новый метод:

```javascript
const restaurant = {
  name: "Classico Italiano",
  location: "Via Angelo Tavanti 23, Firenze, Italy",
  categories: ["Italian", "Pizzeria", "Vegetarian", "Organic"],
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  mainMenu: ["Pizza", "Pasta", "Risotto"],

  orderPasta: function (ing1, ing2, ing3) {
    console.log(`Вот ваша вкусная паста с ${ing1}, ${ing2} и ${ing3}`);
  },
};

const ingredients = [
  prompt("Давайте приготовим пасту! Ингредиент 1?"),
  prompt("Ингредиент 2?"),
  prompt("Ингредиент 3?"),
];
console.log(ingredients);
// result / Всплывающих 3 плашки для каждого Ингредиента в браузере для ввода input.
```

Все то что мы напишем в input возвращается в консоле в виде массива. Например если напишем для первого Ингредиента (a), для второго Ингредиента (b), для третьего Ингредиента (c). Результат будет таким в консоле >(3)['a', 'b', 'c']

А теперь как нам вызвать функцию orderPasta(): Раньше написали бы вот так, чтобы передать значения из массива в функцию в виде аргумента для параметров.

```javascript
restaurant.orderPasta(ingredients[0], ingredients[1], ingredients[2]);
```

Но теперь когда мы узнали об операторе расширения, мы можем сделать намного лучше.

```javascript
restaurant.orderPasta(...ingredients);
```

input - Для первого ингридиента (мясные нарезки)  
input - Для второго ингридиента (спаржа)  
input - Для третьего ингридиента (сыр)  
// Результат в консоле >(3)['мясные нарезки', 'спаржа', 'сыр']  
// Результат вызова функции - (Вот ваша вкусная паста с мясные нарезки, спаржа и сыр)  
Таким образом когда мы напишем в текстовом поле для каждого ингридиента какой то ингридиент, оно появляется в консоле в виде массива и передается в функцию как значения для параметров. И вызвав функцию мы получим эти ингридиенты в нашем строке внутри функции orderPasta.

Точно также оператор расширения работает с обычными объектами, хотя объекты не являются итерируемыми, это работает начиная с ES6. Давайте теперь создадим новый объект, который будет содержать все данные нашего объекта restaurant, и с некоторыми дополнительными данными.

**Пример:**

```javascript
const newRestaurant = { founderIn: 1998, ...restaurant, founder: 'Guiseppe' };
console.log(newRestaurant);
// result / {
  founderIn: 1998,
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],
  founder: 'Guiseppe',
}
```

Здесь мы видим что мы скопировали наш объект restaurant в новый объект newRestaurant, и добавили дополнительные свойство для нового объекта.

Теперь когда мы можем скопировать старый объект внутри нового объекта, и когда мы делаем изменение в свойстве нового объекта, то у старого объекта значения свойство не меняется. Как это было когда мы присваивали объект для новой переменной, тут когда мы меняем что то в новом объекте который мы присвоили для переменной, то это поменяется и в старом объекте.

**Пример:**

```javascript
const restaurantCopy = { ...restourant };
restaurantCopy.name = "Ristorante Roma";
console.log(restaurantCopy.name); // result / Ristorante Roma
console.log(restaurant.name); // result / Classico Italiano
```

Тут мы видим что значения свойства name у обоих объектов разные. Это потому что мы скопировали объект с помощью оператора расширения.

---

# ШАБЛОН REST - ОСТАВШАЯСЯ ЧАСТЬ

Этот шаблон выглядит точно также и как оператор расширения, у него такой же синтаксис с тремя точка (...). Но он делает противоположное тому, что делает оператор расширения.

Теперь давайте посмотрим на шаблон rest (остальное), он использует тот же синтаксис, но собирает несколько элементов и объединяет их в массив. Это полное противоположность оператору расширения. Оператор расширения разделяет массив на отдельные элементы, а шаблон rest (остальное) объединяет элементы в массив.

1 - **Пример диструктуризации для шаблона rest (остальное):**

```javascript
const [a, b, ...others] = [1, 2, 3, 4, 5];
console.log(a, b, others); // result / 1, 2, >(3)[3, 4, 5]
```

Мы видим что синтаксис шаблона rest (остальное) пишется справа оператора присваивания. То есть шаблон rest берет и присваивает остальные элементы массива в переменную others, создав новый массив others.

Давайте посмотрим на другой пример: И это покажет нам что мы действительно можем использовать три точки с обеих сторон оператора присваивания. Вернемся к нашему объекту restaurant:

```javascript
const restaurant = {
  name: "Classico Italiano",
  location: "Via Angelo Tavanti 23, Firenze, Italy",
  categories: ["Italian", "Pizzeria", "Vegetarian", "Organic"],
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  mainMenu: ["Pizza", "Pasta", "Risotto"],
};

const [pizza, , risotto, ...otherFood] = [
  ...restaurant.mainMenu,
  ...restaurant.starterMenu,
];
console.log(pizza, risotto, otherFood); // result /
Pizza,
  Risotto > (4)[("Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad")];
```

Здесь мы делаем диструктуризацию массивов mainMenu и starterMenu объединяя их с помощью оператора расширения. Потом переменные внутри массива pizza и risotto получают свои элементы из объединенного массивов mainMenu и starterMenu. Но мы пропустили один элемент 'Pasta' использовав запятое. Потом оставшуюся часть объединенных массисов mainMenu и starterMenu, присваивается в переменную otherFood с помощью шаблона rest, создав новый массив. Обратите внимания что синтаксис шаблона rest собирает все элементы объединенных массивов mainMenu и starterMenu, после последней переменной, в данном случае последняя переменная это risotto. Шаблон rest не включает пропущенные элементы использовав запятым, в данном случае пропущенный элемент это 'Pasta'. По этот шаблон rest всегда должен быть последним в диструктурирующем присваиванией, иначе как JS узнает до какого элемента нужно собирать остальные элементы массива.

А теперь давайте сделаем тоже самое с объектами, потому что это работает и сними. Разница в том, что оставшиеся элементы будут собраны в новый объект а не в новый массив.

Давайте теперь по работаем с нашими часами работ в объекте openingHours: Допусти что мы хотим выбрать только субботу это у нас вложенный объект sat, а остальные дни недели thu и fri должны быть в новом объекте. Нам нужно просто взять субботу sat в отдельную переменную, а остальные дни недели thu и fri собрать в новый объект.

Данный объект вложенный, внутри объекта restaurant:

```javascript
openingHours: {
  thu: {
    open: 12,
    close: 22,
  },
  fri: {
    open: 11,
    close: 23,
  },
  sat: {
    open: 0, // Open 24 hours
    close: 24,
  },
};
```

```javascript
const { sat, ...weekdays } = restaurant.openingHours;
console.log(sat, weekdays); // result / {sat:{...}}, >{thu:{...}, fri:{...}}
```

2 - **Пример шаблона rest в функциях:**

```javascript
const add = function(...numbers) {
  console.log(numbers);
};
add(2, 3);
add(5, 3, 7, 2);
add(8, 2, 5, 3, 2, 1, 4);
// result / >(2)[2, 3]
            >(4)[5, 3, 7, 2]
            >(7)[8, 2, 5, 3, 2, 1, 4]
```

И таким образом мы видим что в одном параметре numbers собраны все аргументы вызова функции. Оператор rest принимает несколько значений и объединяет их в один массив.

Теперь мы можем написать простую логику чтобы сложить все числа:
**Пример:**

```javascript
const add = function (...numbers) {
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
    console.log(sum);
  }
};
add(2, 3);
add(5, 3, 7, 2);
add(8, 2, 5, 3, 2, 1, 4);
// result / 5, 17, 25
```

Давайте теперь перейдем на следующий уровень: Давайте создадим еще один массив:

```javascript
const x = [23, 5, 7];
add(...x); // result / 35
```

Таким образом мы передали все элементы нового массива x, для параметра numbers функции add в виде аргумента, с помощью шаблона rest.

Давайте используем оператор rest для нашего объекта restaurant: Добавим еще один метод для нашего объекта restaurant. На этот раз функция будет связан с заказом пиццы, теперь для пиццы должен быть хотя бы один ингридиент, но остальные ингридиенты не обязательны.

Данная функция находится внутри объекта restaurant:

```javascript
orderPizza: function(mainIngredient, ...otherIngredients) {
  console.log(mainIngredient);
  console.log(otherIngredients);
};
restaurant.orderPizza('mushrooms', 'onion', 'olives', 'spinach');
// result / mushrooms, >(3)['onion', 'olives', 'spinach']
```

Мы видим что первый параметр mainIngredient принимает элемент 'mushrooms'. Второй параметр otherIngredients с помощью оператора rest, принимает все остальные элементы, создав новый массив.

Конечно мы могли бы указать только один аргумент при вызове функции orderPizza, тогда параметр otherIngredients остальные аргументы будут помещены в пустой массив, потому что их нет, так как мы указали только один аргумент при вызове функции.

**Пример:**

```javascript
restaurant.orderPizza("mushrooms"); // result / mushrooms, >[]
```

Мы видим что для параметра mainIngredient получено аргумент в консоле mushrooms, а для параметра otherIngredients получено пустой массив.

---

# ВЫЗОВ КОРОТКОГО ЗАМЫКАНИЯ ЛОГИЧЕСКИЕ ОПЕРАТОРЫ (&&, ||)

До этого момента мы использовали логические операторы только для объединения булевых значений. Но самом деле мы можем делать горазде больше с помощью логических операторов (&&, ||).

Давайте начнем с оператора ||:

```javascript
console.log(3 || "Jonas"); // result / 3
```

Это значит что результат оператора ||, не всегда должен быть булевым. Фактически на примере выше, мы использовали два значения которые не являются булевыми и получили не булевое значения (true, fasle).

И так, есть 3 свойство логических операторов о которых мы не говорили.
1 - Они могут работать с любым типом данных, они могут возвращать любой тип данных и выполняют короткое замыкания. Короткое замыкания означает что если первая значения является истинным (true), то оно сразу же вернет это первое значения. Именно это мы и видим в result на примере выше с числом 3, которое является истинным значением.

И так, если первый операнд в операторе || является истинным (true), то второй операнд даже не будет вычеслятся. То есть JavaScript даже не будет его проверять.

Давайте попробуем еще несколько примеров:

```javascript
console.log("" || "Jonas"); // result / Jonas
console.log(true || 0); // result / true

// Здесь возвращается последняя значения, так как оба значения являются ложными (false):
console.log(undefined || null); // result / null
console.log(0 || false); // result / false

// Здесь как только появляется истинное значения (true), JS сразу же возвращается его, дальше JS не будет проверять:
console.log(undefined || 0 || "" || "Hello" || 23 || null); // result / Hello
```

Теперь давайте рассмотрим более практическое применение: Допустим у объекта restaurant есть свойство с количеством гостей, но мы незнаем существует ли оно. Однако мы хотим определить переменную на основе этого свойство, и задать значения по умолчанию, если его нет.
**Пример:**

```javascript
const guests1 = restaurant.numGuests ? restaurant.numGuests : 10;
```

Мы хотим проверить существует ли данное свойство numGuests, и тогда результатом будет сам свойство restaurant.numGuests. Но если такого свойство нет, то мы хотим установить по умолчанию значения 10.

```javascript
console.log(guests1); // result / 10
```

Мы видим что в консоле получили число 10, это потому что свойство numGuests в объекте restaurant не существует.

Но вместо этого всего выше, мы можем воспользовать логическим оператором ||:

```javascript
const guests2 = restaurant.numGuests || 10;
console.log(guests2); // result / 10
```

Здесь мы видим что, первый операнд со свойством не определено, оно ложное undefined, по этот оператор || возвращает число 10. Но если данное свойство numGuests существовало бы в объекте restaurant, к примеру со значением 23, то оператор || возвращало бы данное число 23.

У нас есть еще есть логический оператор &&, и у него тоже есть короткое замыкания: Когда дело доходит до короткого замыкания, оператор && сработает противоположным образом по сравнению с оператором ||.
**Пример:**

```javascript
console.log(0 && "Jonas"); // result / 0
```

Это означает что оператор && замыкает цель, когда первое значения ложное, и сразу возвращает это ложное значения даже не оценивая второй операнд.
Еще пример:

```javascript
console.log(7 && "Jonas"); // result / Jonas
```

Если значения истина (true), то оценка продолжается и возвращается последняя значения. Если подумать это имеет смысл: Оператор && возвращает (true) только если все операнды истинные, если первый операнд ложный, то результат всей операции &&, будет ложным (false). По этот нет необходимости проверять все остальные операнды.
Еще пример:

```javascript
console.log("Hello" && 23 && null && "Jonas"); // result / null
```

Как только оператор && встречает ложное значения (false), он возвращает его и дальше не будет оценка.

Давайте рассмотрим еще один практический пример: Мы проверяем существует ли свойство orderPizza в объекте restaurant, а он существует, то есть это правда (true).

```javascript
if (restaurant.orderPizza) {
  restaurant.orderPizza("mushrooms", "spinach");
} // result / mushrooms, >[spinach]
```

В данном случае мы делаем вид что незнаем существует ли данное свойство orderPizza, чтобы заказать пиццу. Сначала проверяем существует ли данное свойство и только потом выполняем заказ.

Теперь с нашими знаниями об операторе &&, мы можем сделать это более простым способом:

```javascript
restaurant.orderPizza && restaurant.orderPizza("mushrooms", "spinach");
// result / mushrooms, >[spinach]
```

Если данное свойство orderPizze существует, а он существует в нашем объекте, то оператор && продолжает оценку и передает аргументы mushrooms и spinach в функцию orderPizza.

Уточню что в нашем функции orderPizze есть два параметра:
1 - Это обычный параметр mainIngredient  
2 - Это параметр ...otherIngredients с оператором rest, который перемещает в себя все остальные элементы, создав новый массив.

---

# ОПЕРАТОР СЛИЯНИЯ С НУЛЕВЫМ ЗНАЧЕНИЕМ (??)

Как мы помним оператор || возвращает значения как только он встретит истинное значения. Но здесь у нас возникает проблема:

```javascript
restaurant.numGuests = 0;
const guests = restaurant.numGuests || 10;
console.log(guests); // result / 10
```

Здесь мы видим что оператор || возвращает значения число 10, так как данное число 10 возвращает значения (true). Значения число 0 у свойствы numGuests, оператор || пропустил, так как он является ложным (fasle). Но у нас количество гостей указано, хотя количеством является число 0, но все равно у нас есть данное свойство numGuests со значением 0, в нашем объектом restaurant. А мы хотим чтобы в консоле было количество гостей было 0.

Для этого у нас есть отличное решение: Это новый оператор с названием, оператор слияния с нулевым значением (??). Данный оператор (??) работает почти также и как оператор ||, но не допускает ошибок.
**Пример:**

```javascript
restaurant.numGuests = 0;
const guestCorrect = restaurant.numGuests ?? 10;
console.log(guestCorrect); // result / 0
```

Мы получаем реальное значения, которое указано в свойстве numGuests.

Почему это работает? Потому что оператор слияния (??), работает с нулевыми значениями а не с ложными. Нулевые значения - это null и undefined. То есть данный оператор слияния (??) когда встречает операндов со значениями null и undefined, он их пропускает и продолжает оценку, пока не встретит любые другие операнды не с значениями null и undefined.

---

# НОВЫЕ ОПЕРАТОРЫ ПРИСВАИВАНИЯ

Давайте создадим две новых объектов ресторана:

```javascript
const rest1 = {
  name: "Capri",
  numGuests: 20,
};
const rest2 = {
  name: "La Piazza",
  owner: "Giovanni Rossi",
};
```

Теперь давайте установим количество гостей по умолчанию, для всех объектов ресторанов у которых нет этого свойство. Давайте воспользуемся уже знакомым нам уже инструментом, это оператор ||.

```javascript
rest2.numGuests = rest1.numGuests || 10;
```

Если свойство numGuests у объекта rest1 истина (true), то оно сразу возвращается и передается для свойство numGuests объекта rest2, как мы помним оператор || именно так и работает. А если свойство numGuests у объекта rest1 ложное (false), то оператор || возвращает значения число 10 по умолчанию, для свойство numGuests объекта rest2.

**Пример без оператора присваивания ||=:**

```javascript
rest1.numGuests = rest1.numGuests || 10; // result / >{name: 'Capri', numGuests: 20}
```

Здесь мы присвоили свойство numGuests объекта rest1, самому себе, или если свойство numGuests объекта rest1 не существует (false), задали значения число 10. Но мы видим что результат в консоле это сам свойство numGuests со значением 20, так как он существует в объекте rest1.
Другой пример без оператора присваивания =||:

```javascript
rest2.numGuests = rest2.numGuests || 10; // result / >{name: 'La Piazza', owner: 'Giovanna Rossi', numGuests: 10}
```

А здесь мы видим что у объекта rest2 свойство numGuests не существует (false), и по этот оператор || присвоил объекту новое свойство numGuests со значением число 10 по умолчанию.

Теперь перейдем к первому логическому оператору присваивания, который называется оператором присваивания ||=. С помощью этого оператора присваивания ||= мы можем написать тоже самое что и выше, но более кратко.
**Пример:**

```javascript
rest1.numGuests ||= 10; // result / >{name: 'Capri', numGuests: 20}
```

Здесь тоже самое но более кратко. То есть присвоили свойство numGuests объекта rest1, самому себе.

Точно также это работает и с оператором слияния (??):

```javascript
rest1.numGuests = 0;
rest1.numGuests ??= 10; // result / >{name: 'Capri', numGuests: 0}
```

Значения 0 у свойство numGuests, хотя число 0 ложное (false), оператор слияния (??) возвращает число 0 для свойство numGuests. Потому что оператор слияния (??) работает с нулевыми значениями.

Точно также это работает и с оператором (&&):
**Пример без логического оператора (&&):**

```javascript
rest1.owner = rest1.owner && "ANONYMOUS"; // result / >{name: 'Capri', numGuests: 20, owner: undefined}
```

Логический оператор (&&) возвращает ложное (false) значения как только он его встретит, дальше не будет оценки. В данном примере мы видим что оператор (&&), возвращает значения undefined, потому что свойство owner не существует в объекте rest1.

Второй пример объекта rest2 где существует свойство owner:

```javascript
rest2.owner = rest2.owner && "ANONYMOUS"; // result / >{ name: 'La Piazza', owner: 'ANONYMOUS'}
```

А здесь мы что оператор (&&), возвращает значения 'ANONYMOUS', потому что первое значения является истинным (true), то есть свойство owner существует в объекте rest2.

С помощью этого оператора присваивания ||= мы можем написать тоже самое что и выше, но более кратко.

```javascript
rest1.owner &&= "ANONYMOUS"; // result / >{name: 'Capri', numGuests: 20, owner: undefined}
rest2.owner &&= "ANONYMOUS"; // result / >{ name: 'La Piazza', owner: 'ANONYMOUS'}
```

Здесь тоже самое но более кратко.

---

# ПРАКТИКА

Теперь пришло время сделать перерыв в обучении, чтобы мы могли применить все что узнали в этом разделе на практике.

В этом задании мы будем создавать приложения для ставок на футбол: Мы будем работать с этими данными:

```javascript
const game = {
  team1: "Bayern Munich",
  team2: "Borrussia Dortmund",
  players: [
    [
      "Neuer",
      "Pavard",
      "Martinez",
      "Alaba",
      "Davies",
      "Kimmich",
      "Goretzka",
      "Coman",
      "Muller",
      "Gnarby",
      "Lewandowski",
    ],
    [
      "Burki",
      "Schulz",
      "Hummels",
      "Akanji",
      "Hakimi",
      "Weigl",
      "Witsel",
      "Hazard",
      "Brandt",
      "Sancho",
      "Gotze",
    ],
  ],
  score: "4:0",
  scored: ["Lewandowski", "Gnarby", "Lewandowski", "Hummels"],
  date: "Nov 9th, 2037",
  odds: {
    team1: 1.33,
    x: 3.25,
    team2: 6.5,
  },
};
```

Алгоритм:
1 - Сначала создаем массивы для players1 и для players2: Для этого воспользуемся диструктуризацией и разобъем массив players.

```javascript
const [players1, players2] = game.players;
```

Теперь это два отдельных массива.

2 - Далее создадим переменную и массив со всеми остальными игроками:

```javascript
const [gk, ...fieldPlayers] = players1;
console.log(gk, fieldPlayers); // result / Neuer, >(10)[все остальные игроки]
```

3 - Теперь наша задача создать один массив со всеми игроками players1 и players2:

```javascript
const allPlayers = [...players1, ...players2];
console.log(allPlayers); // result / >(22)[все игроки в одном массиве]
```

4 - Создаем новый массив в которой будет содержать все игроки массива players1, и еще дополнительных трех игроков:

```javascript
const players1Final = [...players1, "Thiago", "Coutinho", "Periscic"];
console.log(players1Final); // result / >(14)[все игроки players1 и доп 3 игроков]
```

5 - Создаем 3 переменные на основе вложенного объекта odds: Давайте сделаем вложенную диструктуризацию:

```javascript
const {
  odds: { team1, x: draw, team2 },
} = game;
console.log(team1, draw, team2); // result / 1.33, 3.25, 6.5
```

Здесь мы обратились к объекту odds, и сперва получили свойство team1 так как имя переменной и названия свойство odds.team1 одинаковые, мы получили значения из свойство team1 объекта odds. Потом мы обратились отдельно к свойству x, так как мы не хотим чтобы названия переменной и названия свойство x были одинаковыми, для этого мы создали переменную draw и внутри него получили значения, из свойство x. А третья переменная team2 у него названия совпадает с названием свойств team2 объекта odds.

6 - Создаем функцию на основе вложенного массива scored, чтобы узнать количество голов с помощью каждого отдельного игрока, которые у нас есть в этом массиве scored.

```javascript
const printGoals = function (...players) {
  console.log(`${players.length} голов были забиты!`);
};
printGoals(game.scored); // result / 1 голов были забиты!
```

Мы здесь видим что забитых голов только 1, хотя игроков внутри массива scored 4. Почему так? потому что мы передали весь массив целиком как аргумент для функции, без использования оператора расширения (...) при вызове функции printGoals(). Нам нужно передать каждый отдельный игрок как аргумент для параметра функции printGoals(...players). Вот так:

```javascript
printGoals(...game.scored); // result / 4 голов были забиты!
```

Так как в массиве 4 игрока то есть 4 элемента, оператор расширения (...) разбил их на отдельные элементы и передал их для параметра (...players) в функцию, а данный параметр (...players) функции, создал новый массив на основе этих элементов, и длина length этого массива состовляет 4.

7 - Выводим на консоль какая команда выигрыет учитывая коэффициент: То есть переменные которые мы создали с помощью диструктуризации, содержат эти коэффициенты. Команда с меньшим коэффициентом вероятнее всего выигрыет, по этот мы должны вывести это на консоль без оператора if или тернарного оператора.
**Пример:**

```javascript
team1 < team2 && console.log("У team1 больше шансов на победу");
```

Мы помним что логический оператор && продалжает оценку если первый операнда истина (true), в данном случае все операнды истинные (true), по этот логический оператор && выводит последний операнд на консоль. И это 'У team1 больше шансов на победу'.

---

# НОВЫЙ СПОСОБ ПЕРЕБОРА МАССИВОВ - ЦИКЛ FOR-OF

Допустим мы хотим пройтись по всему нашему меню в нашем объекте restaurant:

```javascript
const restaurant = {
  name: "Classico Italiano",
  location: "Via Angelo Tavanti 23, Firenze, Italy",
  categories: ["Italian", "Pizzeria", "Vegetarian", "Organic"],
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  mainMenu: ["Pizza", "Pasta", "Risotto"],
};

const menu = [...restaurant.starterMenu, ...restaurant.mainMenu];
```

Давайте будем перебирать данный массив menu, с помощью for-of, который объединяет в себя все элементы массивов starterMenu и mainMenu:

```javascript
for (const item of menu) console.log(item); // result / Focaccia
                                                        Bruschetta
                                                        Garlic Bread
                                                        Caprese Salad
                                                        Pizza
                                                        Pasta
                                                        Risotto
```

И таким образом мы получили все элементы массива menu по отдельности.

Цикл for-of перебирает весь массив и вытаскивает каждый элемент массива, перемещая каждый элемент массива по отдельности внутри переменной item при каждом этирации цикла. Мы видим в консоле что каждый элемент записывается по очереди, и это потому что переменная item всегда указывает на текущий элемент в каждой этирации.

С циклом for-of нам не нужно беспокоится о таких деталях как счетки и условия. Что еще хорошо в цикле for-of, так это то что, мы все еще можем использовать такие слова как continue и break.

Что если нам нужно не текущий элемент массива, но и index элементов? Ну в цикле for-of это немного не удобно, потому что изначально он был предназначен только для получения текущего элемента. Но мы можем получить и то и другое, и вот как это делается:

```javascript
for (const item of menu.entries()) {
  console.log(item);
}; // result / >(2)[0, 'Focaccia']
               >(2)[1, 'Bruschetta'] и тд
```

Как мы видим каждый элемент теперь представляет собой массив, с индексом и с самим элементом массива. Каждый элемент этого массива menu, это новый массив.

Теперь давайте выведем в консоль массивы каждого элемента по отдельности, так как каждый элемент это массив, мы хотим вывести их по отдельности как в настоящем меню. Как мы видим сверху в консоле, что у каждого массива находятся внутри индексы и сами элементы, мы хотим вывести сам элемент и индекс этого элемента, но внимания сам индекс тоже является элементом у индекса тоже есть индекс. индексы которые являются элементами ничаниются с числом 0, и это будет не красиво в меню, это мы исправим внутри шаблонного литерала с помощью интерполяции ${}.

```javascript
for (const item of menu.entries()) {
  console.log(`${item[0] + 1}: ${item[1]}`);
 } // result / 1: Focaccia
               2: Bruschetta
               3: Garlic Bread и тд
```

Результат в консоле выглядит красиво, как в настоящем меню. Как это работает? Первая этирация цикла for-of: Внутри переменной item перемещается массив с помощью entries(), массив содержит внутри себя элемент 0 и элемент 'Focaccia' [0, "Focaccia"]. Идем внутрь цикла внутрь фигурных скобок {}: Внутри шаблоного литерала обращаемся к массиву item[0] и получаем доступ к первому элементу этого массива и это число 0. И говорим этому элементу +1, то есть к тебе прибавляется всегда 1, и этот элемент число 0, становится 1. Потом обращаемся к массиву item[1] и получаем доступ к второму элементу 'Focaccia' с помощью индекса [1]. Первая этирация цикла заканчивается и начинается вторая этирация цикла: Точно также перемещается внутри переменной item новый массив с помощью entries().

Пример выше, мы можем сделать еще лучше с помощью диструктуризации:
**Пример:**

```javascript
for (const [i, el] of menu.entries()) {
  console.log(`${i + 1}: ${el}`);
 } // result / 1: Focaccia
               2: Bruschetta
               3: Garlic Bread и тд
```

Переменная i будет содержать внутри себя первый элемент массива и это число 0, который добавляет entries(). Переменная el будет содержать внутри себя второй элемент массива и это 'Focaccia', который добавляет entries(). При первом этирации цикла, переменная i содержит внутри себя первый элемент число 0, мы обращаемя к i внутри шаблонного литерала и добавляем к число 0 + 1 = 1 ${i + 1} Точно также все это работает отличным образом!

---

# РАСШИРЕННЫЕ ЛИТЕРАЛЫ ОБЪЕКТОВ (13.11.24 // 17:05)

Давайте рассматрим наш объект rest1:

```javascript
const rest1 = {
  name: "Capri",
  numGuests: 20,
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
};
```

Мы видим что мы написали этот объект, используя фигрных скобок {}. Весь этот объект написан с использованием синтаксиса литералов объектов. ES6 представил 3 способа, которую упращают написания таких литералов объектов.

Давайте рассмотрим их по очереди:
1 - Улучшение литералов объектов: Допустим у нас есть объект который находится вне этого объекта rest1. Давайте создадим этот отдельный объект, вне объекта rest1:

```javascript
const openingHours = {
  thu: {
    open: 12,
    close: 22,
  },
  fri: {
    open: 11,
    close: 23,
  },
  sat: {
    open: 0, // Open 24 hours
    close: 24,
  },
};
```

Теперь это openingHours отдельный объект вне объекта rest1. Но нам нужно чтобы это openingHours отдельный объект, был внутри объекта rest1. Раньше до ES6 мы бы добавили этот объект openingHours, внутри объекта rest1, вот таким образом:

```javascript
const rest1 = {
  name: 'Capri',
  numGuests: 20,
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  openingHours: openingHours, <<<
};
```

То есть мы добавили внутри объекта rest1 новое свойство, и присвоили ему наш отдельный объект openingHours. Проблема здесь в том, что названия свойства openingHours совпадает с именем переменной openingHours у которой, внутри находится объект {..}, это не проблема, но может раздражать.

С расширенными литералами объектов нам не нужно написать то что находится сверху. Так что, мы можем написать вот таким образом:

```javascript
const rest1 = {
  name: 'Capri',
  numGuests: 20,
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  openingHours, <<<
};
```

Мы создали свойство у которого названия, совпадает с названиям переменной из которой мы получаем этот отдельный объект.

2 - Улучшение литералов объектов: Это касается написания методов, то есть функции внутри объектов. В ES6 нам больше не нужно создавать свойство, а затем присваивать ему функцию как значения, как мы это делали раньше.
**Пример:**

```javascript
const rest1 = {
  name: "Capri",
  numGuests: 20,
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  openingHours,

  order: function (starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.starterMenu[mainIndex]];
  },
};
```

Вместо этого, мы просто создаем свойство и сразу присваиваем ему функцию без названия function и без двоиточье (:).
**Пример:**

```javascript
const rest1 = {
  name: "Capri",
  numGuests: 20,
  starterMenu: ["Focaccia", "Bruschetta", "Garlic Bread", "Caprese Salad"],
  openingHours,

  order(starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.starterMenu[mainIndex]];
  },
};
```

И теперь это работает точно также как и раньше, но с более простым синтаксисом.

3 - Улучшение литералов объектов: Теперь мы можем вычеслять имена свойств, вместо того чтоб писать их в ручную. Вычеслять значить считать. Давайте попробуем: Допустим у нас есть массив со всеми днями недели:

```javascript
const weekdays = ["mon", "true", "wed", "thu", "fri", "sat", "sun"];
```

Теперь мы хотим получить имена этих элементов из массива для свойств, вместо того чтобы писать их в ручную, мы можем сделать это с помощью синтаксиса квадратных скобок [].
**Пример:**

```javascript
const openingHours = {
  [weekdays[3]]: {
    open: 12,
    close: 22,
  },
  [weekdays[4]]: {
    open: 11,
    close: 23,
  },
  [weekdays[5]]: {
    open: 0, // Open 24 hours
    close: 24,
  },
};
```

Так как JS внутри квадратных скобок ожидает выражения, мы можем написать любое названия для свойств, который возвращает значения. Пример шаблонного литерала: Это названия для свойств - [`day-${2 + 4}`]: Итого названия будет таким - day-6: Хотя все эти вложенные объекты, но все равно они являются свойствами внутри объекта openingHours.

---

# НОВАЯ ФУНКЦИЯ ОБЪЕКТОВ И МАССИВОВ - НЕ ОБЯЗАТЕЛЬНАЯ ЦЕПОЧКА (?.)

Допустим мы хотим узнать существуют ли объект mon (пн), внутри объекта openingHours, и узнать часы работы у объекта mon, то есть время работы (open и close).

```javascript
console.log(rest1.openingHours.mon); // result / undefined
```

Значения undefined, потому что объект mon, не существует внутри объекта rest1.

Давайте представим что мы незнаем, работает ли этот ресторан rest1 в (пн) или нет:

```javascript
console.log(rest1.openingHours.mon.open); // result / Cannot read property 'open' of undefined
```

И теперь мы действительно получаем ошибку в консоле, потому что первый операнд mon, является undefined.

Чтобы избежать этой ошибки, нам нужно сначала проверить, существует ли это свойство (вложенный объект) mon, внутри объекта rest1. Мы можем сделать это с нашими знаниями без оператора не обязательной цепочки (?.):

```javascript
if (rest1.openingHours.mon) {
  console.log(rest1.openingHours.mon.open);
}
```

Если вложенный объект mon существует (true), то дай нам значения свойство open, у вложенного объекта mon.

Однако это проверка с условиям if(), для одного свойство, в данном случае только для mon (пн). А теперь представьте что возможно у объекта restaurant, также может не быть openingHours. В таком случае нам придется проверить и то и другое с помощью логического оператора &&.
**Пример:**

```javascript
if (rest1.openingHours && rest1.openingHours.mon) {
  console.log(rest1.openingHours.mon.open);
}
```

Здесь мы проверяем существует ли openingHour и существует ли свойство mon для openingHours. И только тогда, когда они оба существует (true), мы можем узнать значения у свойствы open в консоле. И это может довольно быстро выйти из подконтроля, когда у нас есть глубоко вложенные объекты с большим количеством свойств.

И по этот в ES2020 появилось отличная решения для этого, функция называемой не обязательной цепочкой (?.): При использовании не обязательной цепочки (?.), если определенное свойство не существует, немедленно возвращается значения undefined, вместо ошибки в консоле. Вот как это работает:

```javascript
console.log(rest1.openingHours.mon?.open); // result / undefined
```

Когда свойство mon находится перед вопросительном знаком (?), и если он существует, то свойство open внутри объекта mon, будет прочитано, и оператор не обязательной цепочки (?.), даст нам значения у данный свойство open. Но если mon не существует, то сразу же будет возвращено значения undefined, вместо ошибки в консоле.

Как мы знаем свойство mon существует если свойство mon не равно undefined и null. Если свойство mon равно 0 или пустой строке (''), то оно все равно существует.

Давайте посмотрим на более реальный пример: Для этого мы возьмем наш массив с днями недели:

```javascript
const days = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];
```

Теперь мы хотим пройтись по этому массиву и вывести в консоль, открыто или закрыто ли ресторан в каждой из этих дней.

```javascript
for(const day of days) {
  console.log(day);
}; // result / mon
               tue
               wed
               thu и тд
```

И так, теперь мы можем написать код для каждого из этих дней:
**Пример:**

```javascript
for(const day of days) {
  const open = rest1.openingHours[day]?.open
  console.log(`в ${day}, открываемся в ${open}`);
};
// result / В mon, открываемся в undefined
            В tue, открываемся в undefined
            В wed, открываемся в undefined
            В thu, открываемся в 12
            В fri, открываемся в 11
            В sat, открываемся в 0
            В sun, открываемся в undefined
```

Здесь мы видим что свойствы thu fri и sat, существуют в нашем объекте openingHours, по этот оператор не обязательной цепочки (?.), выдает нам значения (часы работы) свойствы open, у объектов thu fri и sat. А все остальные дни не существуют в нашем ресторане rest1 и в объекте openingHours, по этот оператор не обязательной цепочки (?.), выдает нам значения undefined для всех остальных дней.

Но теперь мы не хотим чтобы было написано undefined, для всех остальных дней. Давайте установим значения по умолчанию для всех остальных дней, используя логического оператора ||.
**Пример:**

```javascript
for(const day of days) {
  const open = rest1.openingHours[day]?.open || 'closed';
  console.log(`в ${day}, открываемся в ${open}`);
};
// result / В mon, открываемся в closed
            В tue, открываемся в closed
            В wed, открываемся в closed
            В thu, открываемся в 12
            В fri, открываемся в 11
            В sat, открываемся в closed <<<
            В sun, открываемся в closed
```

Здесь у нас появляется проблема: У свойство sat написано что мы закрыты closed, хотя на самом деле мы открыты в 0 часов. Свойство действительно существует в объекте openingHour. Мы знаем что логический оператор || пропускает ложное значения (false), и продолжает оценку пока не найдет истинное значения (true), в нашем случае это 'closed', а число 0 это ложное значения (false). По этот мы видим что логический оператор || пропустил значения число 0 у свойствы sat.

Решаем эту проблему:

```javascript
for(const day of days) {
  const open = rest1.openingHours[day]?.open ?? 'closed';
  console.log(`в ${day}, открываемся в ${open}`);
};
// result / В mon, открываемся в closed
            В tue, открываемся в closed
            В wed, открываемся в closed
            В thu, открываемся в 12
            В fri, открываемся в 11
            В sat, открываемся в 0 <<<
            В sun, открываемся в closed
```

Мы знаем, как решит эту проблему используя оператора объединения (??). Мы знаем что оператор объединения (??), пропускает значения undefined и null, пока не найдет любое другое значения кроме undefined и null. И когда он находит любое другое значения кроме undefined и null, он возвращает это другое значения в консоль, в нашем случае это число 0. Число 0 не является undefined и null, по этот оператор объединения (??), не пропустил число 0 и не перешел к значению 'closed'.

Оператор не обязательной цепочки (?.), также работает с вызывом методов: Таким образом мы можем проверить существует ли метод, прежде чем его вызывать.
**Пример:**

```javascript
console.log(rest1.order?.(0, 1) ?? "Метод не существует");
// result / >(2)["Focaccia", "Pasta"]
```

Мы видим что метод существует в объекте rest1. Если метод не существовало бы, то оператор не обязательной цепочки (?.) сразу вернул бы значения undefined. И после, оператор слияния (??) продолжил бы оценку и пропустил бы это значения undefined и вернул бы строку "Метод не существует".

Оператор не обязательной цепочки (?.), также работает с Массивами: Мы можем использовать ее чтобы проверить, пустой ли массив:
**Пример:**

```javascript
const users = [
  {
    name: "Jonas",
    email: "Rabadanov-1995@list.ru",
  },
];
```

Мы хотим получить первый элемент этого массива users, а первый элемент этого массива, это весь объект который находится внутри этого массива users, то есть длина length массива users это [1], а индекс [0]. И хотим получить свойство name, этого внутреннего объекта:

```javascript
console.log(users[0]?.name ?? "Массив users пуст"); // result / Jonas
```

Мы видим что свойство name существует в объекте внутри массива users. Если свойство name не существовало бы, то оператор не обязательной цепочки (?.), сразу вернул бы значения undefined. И после, оператор слияния (??) продолжил бы оценку и пропустил бы это значения undefined и вернул бы строку "Массив users пуст".

---

# ПЕРЕБОР НЕИТЕРИРУЕМЫХ ОБЪЕКТОВ

Мы можем перебирать имена свойств объекта, значения или и то и другое. Давайте начнем с простого перебора имен свойств, мы помним что их еще называют ключами. Мы будем перебирать объект косвенно, то есть мы не будем перебирать сам объект, вместо этого мы будем перебирать массив.
**Пример:**

```javascript
for (const day of Object.keys(openingHour)) {
  console.log(day);
} // result / thu
fri;
sat;
```

Мы видим что получили 3 ключевых имени объекта.

Давайте посмотрим поближе что такое Object.keys:

```javascript
const properties = Object.keys(openingHour);
console.log(properties); // result / >(3)["thu", "fri", "sat"]
```

Мы видим что, Object.keys берет наши ключи (вложенные объекты) из объекта openingHour, и перемещает их в массив.

Алгоритм: Мы открыты 3 дня: четверг, пятница, суббота
**Пример:**

```javascript
let openStr = `Мы открыты ${properties.length} дня: `;
for (const day of properties) {
  openStr += `${day}, `;
} // result / Мы открыты 3 дня: thu, fri, sat
```

Все что выше, это было перебор названия свойств или (вложенные объекты). А что если нам нужны сами значения свойств? Тогда мы просто используем Object.values():
**Пример:**

```javascript
const values = Object.values(openingHour);
console.log(values); // result / >(3)[{..}, {..}, {..}]
                                 >0: {open: 12, close: 22}
                                 >1: {open: 11, close: 23}
                                 >2: {open: 0, close: 24}
```

Мы видим что получили значения свойств thu: fri: sat: объекта openingHour. А значения здесь, сами объекты внутри свойств thu: fri: sat: И метод Object.values перемещает эти объекты в виде значения в массив.

Чтобы действительно смоделировать перебор всего объекта, нам нужны записи, записи это по сути имена свойств и значение вместе. Как мы помним Метод entries() возвращает индекс и сам элемент в новом массиве.

Мы можем сделать тоже самое и с объектами, и тогда метод entries() возвращает свойство и значения в новый массив.  
**Пример:**

```javascript
const entries = Object.entries(openingHour);
console.log(entries); // result / >(3)[Array(2), Array(2), Array(2)]
                                  >0: (2)["thu", {..}]
                                  >1: (2)["fri", {..}]
                                  >2: (2)["sat", {..}]
```

Здесь мы видим что метод Object.entries, берет и перемещает отдельно одно свойство со своим значениям в нашем случае это объект {..}, берет и перемещает одно свойство со своим значениям в отдельный массив. Так как в нашем объекте openingHour, 3 свойство thu fri sat со своими значениями и эти значения являются объекты {..}, метод Object.entries перемещает их всех как отдельные массивы в один большой массив. И длина length этого большого массива, составляет 3.

Теперь мы можем использовать это, для перебора объекта:

```javascript
for (const x of entries) {
  console.log(x);
} // result / >(2)["thu", {..}]
              >(2)["fri", {..}]
              >(2)["sat", {..}]
```

Теперь мы перебирали этот большой массив entries, у которого внутри были отдельные массивы со свойством и значениям.

Теперь давайте посмотрим на более сложный пример, используя диструктуризацию и вложенную диструктуризацию:

```javascript
for (const [key, { open, close }] of entries) {
  console.log(`По ${key} мы открываемся в ${open} и закрываемся в ${close}`);
};
// result / По thu мы открываемся в 12 и закрываемся в 22
            По fri мы открываемся в 11 и закрываемся в 23
            По sat мы открываемся в 0 и закрываемся в 24
```

Что у нас здесь происходит? У нас есть массив внутри переменной entries, и внутри этого массива есть первый элемент это имя свойство и второй элемент это значения сам объект, и внутри объекта есть свойство open и close со своими значениями. Дальше for-of вытаскивает эти оба элемента из массива entries, как отдельные элементы в консоль, и перемещает их в переменные. С помощью диструктуризации массива, первый элемент массива это имя свойство, присваивает его для переменной key. Второй элемент массива entries это сам объект, чтобы присвоить свойсво open и close которые находятся внутри этого объекта, мы делаем еще диструктуризацию внутри массива и для второго элемента массива, то есть для объекта. Таким образом имена переменных внутри диструктуризации { open, close }, совпадают с названиям свойств объекта, который этот объект является вторым элементом массива. И так, для переменной key присваивается первый элемент массива - это названия свойство, а для переменных { open, close } присваивается второй элемент массива и эти названия свойств которые находятся внутри объекта, так как объект является вторым элементом массива.

---

# ПРАКТИКА

Для этого вернемся к нашем объекут game:

```javascript
const game = {
  team1: 'Bayern Munich',
  team2: 'Borrussia Dortmund',
  players: [
    [
      'Neuer',
      'Pavard',
      'Martinez',
      'Alaba',
      'Davies',
      'Kimmich',
      'Goretzka',
      'Coman',
      'Muller',
      'Gnarby',
      'Lewandowski',
    ],
    [
      'Burki',
      'Schulz',
      'Hummels',
      'Akanji',
      'Hakimi',
      'Weigl',
      'Witsel',
      'Hazard',
      'Brandt',
      'Sancho',
      'Gotze',
    ],
  ],
  score: '4:0',
  scored: ['Lewandowski', 'Gnarby', 'Lewandowski', 'Hummels'],
  date: 'Nov 9th, 2037',
  odds: {
    team1: 1.33,
    x: 3.25,
    team2: 6.5,
  },
};

// 1
for (const [i, player] of game.scored.entries()) {
  console.log(`Гол ${i + 1}: ${player}`);
} // result / Гол 1: Lewandowski
              Гол 2: Gnarby
              Гол 3: Lewandowski
              Гол 4: Hummels

// 2
const odds = Object.values(game.odds);
console.log(odds); >(3)[1.33, 3.25, 6.5]
let average = 0;
for (const odd of odds) {
  average += odd;
};
average /= odds.length;
console.log(average); // result / 3.69 (средняя значения)

//3
for(const [team, odd] of Object.entries(game.odds)) {
  console.log(team, odd);
}; // result / team1, 1.33
               x, 3.25
               team2, 6.5
```

Более сложный пример на основе верхнего //3 примера:

```javascript
for(const [team, odd] of Object.entries(game.odds)) {
  const teamStr = team === 'x' ? 'draw' : `victory ${game[team]}`;
  console.log(`Odd of ${teamStr} ${odd}`);
};
// result / Odd of victory Bayern Munich 1.33
            Odd of draw 3.25
            Odd of victory Borrussia Dortmund 6.5
```

Постарайся понять эту задачу, я понял когда смотрел курс.

---

# СТРУКТУРА ДАННЫХ SET (14.11.24 - 19:47)

Set - это по сути просто набор уникальных значений. Это значит что в структуре данных set, не может быть дубликатов.

Давайте создадим стурктуры данных set: В структуре данных set мы передаем итерируемый объект, чаще всего это массив. Set конечно может содержать смешанные типы данных, это не проблема.
**Пример:**

```javascript
const ordersSets = new Set([
  "Pasta",
  "Pizza",
  "Pizza",
  "Risotto",
  "Pasta",
  "Pizza",
]);
console.log(ordersSets); // result / >Set(3){"Pasta", "Pizza", "Risotto"}
```

Мы видим что в консоле все дублирующие элементы исчезли. Теперь мы видим что set похож на массив, в нем нет пар свойство и значения. Как массивы структуры данных set тоже можно перебирать.

Но, структуры данных set сильно отличается от массива. Во первых - потому что элементы структуры данных set, элементы уникальны. Во вторых - Порядок элементов в структуре данных set, не важен.

И мы сейчас увидим почему? Мы также можем передать тип данных строку, в структуру данных set:

```javascript
console.log(new Set("Jonas")); // result / >Set(5){"J", "o", "n", "a", "s"}
```

Конечно структуру данных set, может быть и пустым:

```javascript
console.log(new Set());
```

Теперь давайте узнаем, как работать со структурой данных set: Во первых - мы можем узнать, размер структуры данных set.

```javascript
console.log(ordersSets.size); // result / 3
```

И тут мы видим что у структуры данных ordersSets, размер 3. Это 3 уникальных и не дублирующих элементов в переменной ordersSets. Обращаем внимания что это является размером, а не длиной length как в массивах.

Далее мы можем проверить, есть ли определенный элемент в структуре данных set:

```javascript
console.log(ordersSets.has("Pizza")); // result / true
console.log(ordersSets.has("Bread")); // result / false
```

Давайте сравним структуры данных set с массивами: Метод has() в структуре данных set, похож на includes() в массивах.

Далее мы можем добавлять новые элементы в set:

```javascript
ordersSets.add("Garlic Bread");
ordersSets.add("Garlic Bread");
console.log(ordersSets); // result /  >Set(4){"Pasta", "Pizza", "Risotto", "Garlic Bread"}
```

Мы видим что только один элемент добавилось в set, потому что элементы должны быть уникальными.

На конец, мы можем удалять элементы из структуры данных set:

```javascript
ordersSet.delete("Risotto");
console.log(ordersSet); // result / >Set(3){"Pasta", "Pizza", "Garlic Bread"}
```

Но мы можем спросить, как мы получаем значения из структуры данных set? Можем ли мы использовать index, как в массивах? Ответ - НЕТ! Это потому что в элементах структуры данных set, нет индексов. На самом деле нет способа получения значения из структуры данных set. По этот нет не обходимости извлекать элементов из структуры данных set. Если все элементы уникальны и порядок не важен, то нет смысла извлекания элементов из структуры данных set. Нам нужно только знать, есть ли определенный элемент в set или нет.

Есть еще один метод для структуры данных set: Мы можем использовать этот метод для удаления всех элементов из структуры данных set.

```javascript
ordersSet.clear();
console.log(ordersSet); // result / >Set(0){}
```

Как мы уже написали выше, элементы структуры данных set являются итерируемыми объектами. По этот мы можем перебирать их.

```javascript
for(const order of ordersSet) {
  console.log(order);
}; // result / Pasta
               Pizza
               Garlic Bread
```

Теперь когда знаем как работать с элементами структуры данных set, давайте рассмотрим, где они могут пригодится. В обычной кодовой базе, элементы структуры данных set, в основном используются для удаления повторяющихся значений из массивов.

Давайте рассмотрим пример: Создадим новый массив:

```javascript
const staff = ["Waiter", "Chef", "Waiter", "Manager", "Chef", "Waiter"];
```

Это список всех сотрудников в нашем ресторане.

Но теперь допустим что нам нужно узнать, какие должности есть в нашем ресторане. Другими словами, нам нужно список должностей ресторана без дубликатов.

```javascript
const staffUnique = new Set(staff);
console.log(staffUnique); // result / >Set(3){"Waiter", "Chef", "Manager"}
```

И таким образом у нас есть набор с тремя уникальными должностями. Но нам нужен массив, переобразовать элементы (набор) массива довольно просто.

По этот мы можем создать массив на основе набора структуры данных set. После создания массива для (элементов) наборов структуры данных set, мы можем преобразовать весь набор структуры данных set, с помощью оператора расширения spread.
**Пример:**

```javascript
const staffUnique = [...new Set(staff)]; <<<
console.log(staffUnique); // result / >(3)["Waiter", "Chef", "Manager"] <<<
```

И тогда эти элементы структуры данных set, будут добавлены в новый массив. Таким образом оператор расширения spread здесь работает также, и как с массивами.

Теперь, если бы нам нужно было узнать, сколько существуют уникальных элементов, то свойство size было бы очень полезным.
**Пример:**

```javascript
console.log(
  new Set(["Waiter", "Chef", "Waiter", "Manager", "Chef", "Waiter"]).size
); // result / 3
```

Нам даже не нужно было создавать массив.

Структуры данных set, не предназначены для замена массивов.

---

# СТРУКТУРА ДАННЫХ MAP

Map - это структура данных который мы можем использовать для сапоставления значений с ключами. Как и в объектах, данные map хранятся в парах свойство и значения. Но главное отличие структуры данных map от объектов в том, что в map ключи могут быть любого типа данных. В объектах ключи всегда являются строками string. А в map мы можем использовать ключи любого типа данных. Это могут быть даже объекты, массивы или другой map.

Давайте создадим map ресторана:

```javascript
const rest = new Map();
```

Чтобы заполнить map, мы можем использовать метод set.

```javascript
rest.set();
```

Здесь мы передаем два аргумента: 1 - Это имя ключа. 2 - Это значения для ключа.

```javascript
rest.set("name", "Classico Italiano");
```

И помните что мы можем любой тип данных, какой захотим:

```javascript
rest.set(1, "Firenze, Italy");
rest.set(2, "Lisbon, Portugal");
```

И вызов метода set, не только передает свойство и значения, но и возвращает свойство и значения.
**Пример:**

```javascript
console.log(rest.set(2, 'Lisbon, Portugal')); // result / >Map(3){2 => "Lisbon, Portugal"}
                                                          [[Entries]]
                                                           >0: {2 => "Lisbon, Portugal"}
```

Теперь, когда метод set возвращает обновленную map, мы можем использовать его в цепочке. Как и свойство так и значения могут быть любых типов данных, также мы можем добавлять несколько свойство и значений.
**Пример:**

```javascript
rest
  .set("name", "Classico Italiano")
  .set("categories", ["Italian", "Pizzeria", "Vegetarian", "Organic"])
  .set("open", 11)
  .set("close", 23)
  .set(true, "We are open")
  .set(false, "We are closed");
```

И так, чтобы считать данные из map, то есть чтобы получать значения из свойств, мы используем метод get(). Для этого мы пишем просто названия свойств, внутри метода get().
**Пример:**

```javascript
console.log(rest.get("name")); // result / Classico Italiano
console.log(rest.get(true)); // result / We are open
```

Свойство нужно писать внутри метода get() в соответствии типом данной самого свойство.

Давайте сделаем что нибудь интересное:

```javascript
const time = 21;
rest.get(time > rest.get("open") && time < rest.get("close"));
```

Таким образом мы спрашиваем, значения 21 переменной time больше, значении 11, свойствы 'open' у карты map и значении 21 переменной time меньше, значении 23, свойствы 'close' у карты map. Таким образом мы получаем булево значения (false) или (true).

Давайте выведем результат этого алгоритма в консоль:

```javascript
console.log(rest.get(time > rest.get("open") && time < rest.get("close")));
// result / We are open
```

То есть мы получили истинное значения (true), а true это свойство карты map и значения свойствы true - это 'We are open'.

Давайте продолжим изучать методы, доступные для структуры данных map: У нас уже есть метод get() для добавления и получения значений свойств структуры данных map.

Теперь, мы можем проверить содержит ли map, определенное свойство:

```javascript
console.log(rest.has("categories")); // result / true
```

Для удаления свойств структуры данных map:

```javascript
console.log(rest.delete("name")); // result / (его больше нет в rest)
```

Также у структуры данных map, есть свойство размер (size):

```javascript
console.log(rest.size); // result / 5
```

Также мы можем очистить map, то есть удалить все свойствы и значении из map:

```javascript
rest.clear();
console.log(rest); // result / >Map(0){}
```

Также мы можем использовать массивы и объекты в качестве ключей для map:

```javascript
rest.set([1, 2], "Test");
```

Как получать данные на основе этого массива? Используем метод get() для получения данных:

```javascript
console.log(rest.get([1. 2])); // result / undefined
```

Ой, у нас не получилось получить значения ключа [1, 2]. Причина в том что эти два массива, на самом деле не являются одним и тем же итерируемым объектом. Хотя мы записали их одинаково внутри метода set() и get(). Уних одинаковые элементы, но в памяти компьютера они не являются одним и тем же объектом.

Чтобы это сработало, нам нужно сделать следующее: Создаем отдельно новый массив:

```javascript
const arr = [1, 2];
```

Потом добавляем этот массив как ключ для map:

```javascript
rest.set(arr, "Test");
console.log(rest.get(arr)); // result / Test (получили значения ключа arr)
```

Теперь эти оба массива внутри set(arr) и get(arr) ссылаются на одно и тоже места в памяти.

---

# ПРОДОЛЖЕНИЕ СТРУКТУРЫ ДАННЫХ MAP

До этого мы создали пустую карту: Вот таким образом:

```javascript
const rest = new Map();
```

А затем добавляли свойство и значения с помощью метода set().

Но есть и другой способ заполнения map, без использования метода set(): Метод set() немного не удобен, когда нужно добавлять много свойств и значений.

Вместо этого, мы можем создать новый map, вот так: Создаем новый map, и передаем ему массив. Этот массив будет содержать несколько массивов. В каждом из них будет: 1 - Это свойство 2 - Это значения Раньше внутри метода set(), было первое это свойство и второе было значением. Но теперь мы можем указать точно таким образом внутри вложенного массива.

**Пример:**

```javascript
const question = new Map([
  ['questionu', 'What is the best programming language in the world?'],
  [1, 'C'],
  [2, 'Java'],
  [3, 'JavaScript'],
  ['correct' 3],
  [true, 'Correct!'],
  [false, 'Try again!'],
]);
console.log(question); // result / >Map(7) {....}
                                    >[[Entries]]
                                     >0: {"questionu" => "What is the best programming language in the world?"}
                                     >1: {}
                                     >2: {} и тд
```

Кстати, структура map с вложенными массивами, похож на структуру массив внутри массивов, когда мы используем метод Object.entries() для объектов.
**Пример:**

```javascript
console.log(Object.entries(openingHours));
// result / >(3)[Array(2), Array(2), Array(2),]
             >0: (2)["thu", {..}]
             >1: (2)["fri", {..}]
             >2: (2)["sat", {..}]
```

Тут мы видим что у нас есть большие массивы и внутри есть массивы где первый элемент это свойство "thu" а второй элемент это значения объект {..}. Мы знаем что объект не является итерируемым объектом, мы сделали объект итерируемым с помощью метода Object.entries(), превращая его в массива, чтобы была итерации цикла for, то есть чтобы перебирать его.

Это означает что есть простой способ преобразовать объект в map:
**Пример:**

```javascript
const hoursMap = new Map(Object.entries(openingHours));
console.log(hoursMap); // result / >Map(3){"thu" => {..}, "fri" => {..}, "sat" => {..}}
                                    >[[Entries]]
                                     >0: (2){"thu" => {..}}
                                     >1: (2){"fri" => {..}}
                                     >2: (2){"sat" => {..}}
```

Теперь, давайте поговорим об этирации цикла for: Итерирования возможно для map, потому что как мы уже знаем, map тоже является итерируемым объектом.

Каждый элемент map внутри массива, будет содержать ключ и значения. Хотя у массивов бывают индексы и элементы, но в случае со структурой данных map, массивы будут содержать ключ и значения, как и в обычных объектах.

**Пример:**

```javascript
console.log(question.get('questionu')); // result / What is the best programming language in the world?
for (const [key, value] of question) {
  if (typeof key === 'number') {
    console.log(`Answer ${key}: ${value}`);
  };
}; // result / Answer 1: C
               Answer 2: Java
               Answer 3: JavaScript

const answer = Number(prompt('Your answer'));
question.get(question.get('correct') === answer); // (значения свойство 'correct' это число 3)
```

Таким образом в текстовом поле input, если пользователь напишет число 3, то будет возвращено булево значения true. А true - это свойство для question, и таким образом будет возвращено значения свойство true в консоле, а значения свойство true - это 'Correct!'.

Чтобы преобразовать map в обычный массив, используем оператор расширения spread создав новый массив для переменной question у которого внутри содержится map. То есть поместив question внутри квадратных скобок.

```javascript
console.log([...question]);
```

Как работают этих методов entries(), keys(), values(), для обычных массивов и для преобразованных массивов из map. Посмотри в script.js файл.

Мы можем использовать методы keys() и values(), для преобразованного массива из map. И тогда мы получим первый элемент, то есть первый ключ внутри массива при использовании метода keys():
**Пример для keys():**

```javascript
[...question.keys()]; // result / >(7)['questionu', 1, 2, 3, 'correct', true, false]
```

Для получения второго элемента из преобразованного массива из map: Пример для values():

```javascript
[...question.values()]
// result / >(7)['What is the best programming language in the world?',
                 'C',
                 'Java',
                 'JavaScript',
                 3,
                 'Correct!',
                 'Try again!'
                ]
```

Коротко методы entries(), keys(), values(), для map массивов и для обычных массивов без map: Оба массивов одинаковые, просто один использует map другой без map.

1 - Метод entries() для map массивов
**Пример:**

```javascript
console.log(...question.entries()); // result / >(2) ['questionu', 'What is the best programming language in the world?']
                                                >(2) [1, 'C']
                                                >(2) [2, 'Java']
                                                >(2) [3, 'JavaScript']
                                                >(2) ['correct', 3]
                                                >(2) [true, 'Correct!']
                                                >(2) [false, 'Try again!']
```

При раскрытии каждого массива в консоле: Индекс 0 для первого элемента в массиве это - questionu Индекс 1 для второго элемента в массиве это - What is the best programming language in the world?

1 - Метод entries() для обычных массивов без map:
**Пример:**

```javascript
console.log(...question.entries()); // result / >(2) [0, Array(2)]
                                                >(2) [1, Array(2)]
                                                >(2) [2, Array(2)]
                                                >(2) [3, Array(2)]
                                                >(2) [4, Array(2)]
                                                >(2) [5, Array(2)]
                                                >(2) [6, Array(2)]
```

При раскрытии каждого массива в консоле: Индекс 0 для первого элемента в массиве это - сам индекс 0 Индекс 1 для второго элемента в массиве это - сам элемент ['questionu', 'What is the best programming language in the world?']

2 - Метод keys() для map массивов:

```javascript
console.log(...question.keys()); // result / questionu 1 2 3 correct true false
```

Получаем первый элемент из map массива, как свойство как ключ, как в объектах.

2 - Метод keys() для обычных массивов без map:

```javascript
console.log(...question.keys()); // result / 0 1 2 3 4 5 6
```

Получаем первый элемент из обычного массива, сами число index, как свойство как ключ, но не как в объектах.

3 - Метод values() для map массивов:

```javascript
console.log(...question.values()); // result / What is the best programming language in the world?
                                               C
                                               Java
                                               JavaScript
                                               3
                                               Correct!
                                               Try again!
```

Получаем второй элемент массива, как значения для свойство как в объектах.

3 - Метод values() для обычных массивов без map:

```javascript
console.log(...question.values()); // result / >(2)[Array(2)]
                                               >(2)[Array(2)]
                                               >(2)[Array(2)]
                                               >(2)[Array(2)]
                                               >(2)[Array(2)]
                                               >(2)[Array(2)]
                                               >(2)[Array(2)]
```

Получаем второй элемент из массива, сам массив. При раскрытии в консоле этих массивов: 0: "questionu" 1: "What is the best programming language in the world?"

---

# ПРАКТИКА

Объект для ставок на футбол, где перечислены все события во время игры:

```javascript
const gameEvents = new Map([
  [17, "GOAL"],
  [36, "Substitution"],
  [47, "GOAL"],
  [61, "Substitution"],
  [64, "Yellow card"],
  [69, "Red card"],
  [70, "Substitution"],
  [72, "Substitution"],
  [76, "GOAL"],
  [80, "GOAL"],
  [92, "Yellow card"],
]);

// 1.
const events = new Set(gameEvents.values());
console.log(events); // result / >Set(4){"Goal", "Substitution", "Yellow card", "Red card"}
```

Распаковываем set в массив:

```javascript
const events = [...new Set(gameEvents.values())];
console.log(events); // result / (4)["Goal", "Substitution", "Yellow card", "Red card"]

// 2.
gameEvents.delete(64); // Удалили ключ 64

// 3.
const time = [...gameEvents.keys()].pop();
console.log(time)
// result / (pop() удалил последний элемент из массива и вернет его нам и это ключ 92,
             почему ключ? потому что это преобразованный массив из Map).
console.log(`An event happened, on average, every ${time / gameEvents.size} minutes`);
// result / An event happened, on average, every 9.2 minutes

// 4
for (const [key, value] of gameEvents) {
  const half = key <= 45 ? 'FIRST' : 'SECOND';
  console.log(`[${half} HALF] ${key}: ${value}`);
}; // result / [FIRST HALF] 17: GOAL
               [FIRST HALF] 36: Substitution
               [SECOND HALF] 47: GOAL
               [SECOND HALF] 61: Substitution
               и тд
```

---

# РАБОТА СО СТРОКАМИ STRING - ЧАСТЬ 1

```javascript
const airline = "TAP Air Portugal";
const plane = "A320";
console.log(plane[0]); // result / A
console.log(plane[1]); // result / 3
console.log(plane[2]); // result / 2
```

Таким образом мы получили доступ к каждой букве строк, с помощью переменной plane. Но эти отдельные буквы в консоле, являются строками. Но если бы мы хотели эти отдельные буквы были числами, нам пришлось бы их преобразовать в числа.

Мы также можем получать доступ к каждой букве с помощью самой строки:

```javascript
console.log("B737"[0]); // result / B
```

Мы также можем узнать длину length строки, как и в случае с массивами: Свойство length для строк:

```javascript
console.log(airline.length); // result / 16
console.log("B737".length); // result / 4
```

Теперь, давайте поговорим о методах: Для получения индекса отдельных букв у строк. Метод indexOf():

```javascript
console.log(airline.indexOf("r")); // result / 6
```

Для получения последнего индекса у одинаковых букв, то есть если есть одинаковые буквы в строке, то мы получаем индекс последней буквы. Метод lastIndexOf():

```javascript
console.log(airline.lastIndexOf("r")); // result / 10
```

Для получения часть строки используем метод slice(). А методу slice() нужны индексы в качестве аргументов. Метод slice():

```javascript
console.log(airline.slice(4)); // result / Air Portugal
```

Индексы в качестве аргумента для метода slice(), это позиция с которого начинается метод извлечения. В данном случае индекс 4, это буква 'A' в строке 'TAP Air Portugal'. Именно с буквы 'A' начинается метод извлечения остальное части строки. Этот метод slice(), всегда возвращает новую строку. В данной случае новая строка это - Air Portugal

Если мы хотим прекращать извлечения часть строки до какого то индекса, тогда добвляем второй индекс внутри метода slice():

```javascript
console.log(airline.slice(4, 7)); // result / Air
```

Второй индекс 7 это пробел ' ', и при достижении пробела, метод slice() прекращает извлечения остальную часть строки. В итоге будут извлечены индексы 4, 5, 6, а это у нас Air.

Для получения остальную часть строки используя один индекс, мы можем использовать индекс который возвращает метод lastIndexOf():
**Пример:**

```javascript
console.log(slice(airline.lastIndexOf(" ") + 1)); // result / Portugal
```

Здесь мы возраващем индекс с помощью метода indexOf(), возвращаем индекс у второго пробела который находится в нашем строке TAP Air Portugal. И этот индекс - это число 7, и потом + еще 1 к 7 это = 8, и начиная с 8 индекса извлекается остальную часть строки, а восьмой индекс - это буква 'P'.

Если мы хотим извлечь какую то часть строки от какого индекса, то есть извлечения начинается справа не лево. Для этого как мы знаем используем два индекса внутри метода slice(). В таком случае тоже, мы можем использовать индекс который возвращает метод indexOf().

```javascript
console.log(slice(0, airline.indexOf(" "))); // result / TAP
```

Здесь извлечения начинается с возвращаемого индекса первого пробела нашей строки TAP Air Portugal. А возвращаемый индекс первого пробела - это число 3. И вот начиная с индекса 3, идет извлечения до индекс 0, который мы указали первым, внутри метода slice().

Мы можем также использовать отрицательные индексы внутри метода slice():

```javascript
console.log(airline.slice(1, -1)); // result / AP Air Portuga (Первая и последняя буквы отрезаны)
```

Давайте немного по практикуемся в том что мы узнали: Напишем функцию чтобы проверить средняя места в самолете: B и E - это средние места в самолете.

```javascript
const checkMiddleSeat = function (seat) {
  const s = seat.slice(-1); // (помним что метод slice(), как срезает так и возвращает буквы)
  if (s === "B" || s === "E") {
    console.log("Тебе досталось среднее места");
  } else {
    console.log("Тебе повезло");
  }
};
checkMiddleSeat("11B"); // result / Тебе досталось среднее места
checkMiddleSeat("23C"); // result / Тебе повезло
checkMiddleSeat("3E"); // result / Тебе досталось среднее места
```

Мы можем задаться вопросом? Разве методы используются в примитивных значениях такие как строки? Разве методы не должны быть доступны только для объектов и массивов? Ну это правда! Но, когда мы вызываем метод для строки, JS автоматически преобразует это примитивное значения "Строки" в строковый объект с тем же содержимым.
**Пример:**

```javascript
console.log(new String('Jonas')); // result / >String{"Jonas"}
                                                0: "J"
                                                1: "o"
                                                2: "n"
                                                3: "a"
                                                4: "s"
```

После завершении операции метода slice(), автоматически преобразованный объект снова превращается в обычную строку.

На самом деле все строковые методы, такие как slice, indexOf, lastIndexOf возвращают примитивные значения то есть буквы с типом 'string'. Даже если эти методы вызваны для автоматически преобразовонного строкого объекта.
**Пример:**

```javascript
console.log(typeof new String("Jonas").slice(0)); // result / string (это буква J)
```

Сперва Jonas был объектом, после завершении операции метода slice(), снова объект превращается в примитив типом данных string.

---

# РАБОТА СО СТРОКАМИ STRING - ЧАСТЬ 2

Простые методы для строк: Первые два метода предназначены для изменения регистр строки:

```javascript
console.log(airline.toLowerCase); // result / tap air portugal
console.log(airline.toUpperCase); // result / TAP AIR PORTUGAL
```

Также эти методы можно вызывать напрямую для строки:

```javascript
console.log("TAP Air Portugal".toLowerCase); // result / tap air portugal
console.log("TAP Air Portugal".toUpperCase); // result / TAP AIR PORTUGAL
```

Давайте рассмотрим этих методов в практическом примере, чтобы исправить написания имени пассажира:

```javascript
const passenger = "jOnAS";
```

Чтобы исправить это, обычно сначала переводится все в нижний регистр:

```javascript
const passengerLower = passenger.toLowerCase(); // result / jonas
```

Теперь нам нужно взять первую букву и оставшиеся часть строки, и соединить их:

```javascript
const passengerCorrect =
  passengerLower[0].toUpperCase() + passengerLower.slice(1);
console.log(passengerCorrect); // result / Jonas
```

Еще один пример, сравнения электронной почты пользователя:

```javascript
const email = "hello@jonas.io";
```

Но потом когда пользователь обратно пишет почту, он пишет его не правильно:

```javascript
const loginEmail = " Hello@Jonas.Io \n";
```

И теперь, мы можем сравнить этих обоих почт, похожи ли они. Потому что по сути они одинаковы, они бы отличались если бы в одном из них буквы были другие. Но здесь дело только в регистрке. Что касается почты loginEmail, я считаю что она все равно будет действительным, даже если регистр не учитывается. По этот когда мы проверяем ввод пользователя, в первым делом мы обычно приводим его к нижнему регистру.

```javascript
const lowerEmail = loginEmail.toLowerCase();
```

Затем мы также должны избавится от пробелов: Для этого есть специальный метод trim():

```javascript
const trimmedEmail = lowerEmail.trim();
console.log(trimmedEmail); // result / hello@jonas.io
```

Мы можем сделать все это за один шаг:

```javascript
const normalizedEmail = loginEmail.toLowerCase().trim();
console.log(normalizedEmail); // result / hello@jonas.io
```

Теперь, давайте сравним их:

```javascript
console.log(email === normalizedEmail); // result / true
```

Далее мы научимся заменять части строк:

```javascript
const priceGB = "288,97£";
const priceUS = priceGB.replace("£", "$").replace(",", ".");
console.log(priceUS); // result / 288.97$
```

Точно также мы можем заменять целые слова:

```javascript
const announcement =
  "All passengers come to barding door 23. Boarding door 23!";
console.log(announcement.replace("door", "gate"));
// result / All passengers come to barding gate 23. Boarding door 23!
```

Этот метод replace() заменил только первое слово door на gate.

Но мы можем это обойти с помощью метода replaceAll():

```javascript
console.log(announcement.replaceAll("door", "gate"));
// result / All passengers come to barding gate 23. Boarding gate 23!
```

Но есть еще одно решения этой проблемы без метода replaceAll(), использовать так называемые регулярные выражения: Регулярные выражения - это одно их самых сложных и запутанных тем в программировании. А пока давайте воспользуемся с очень простым Регулярным выражением, чтобы указать методы replace(), что нужно заменить все слова door на gate, а не только первое слово door.

Чтобы создать регулярное выражения, нужно написать строку между косыми чертами, без ковычков:

```javascript
console.log(announcement.replace(/door/g, "gate"));
// result / All passengers come to barding gate 23. Boarding gate 23!
```

Теперь, мы видим что заменены все слова door на gate.

Давайте рассмотрим 3 простых метода, которые возвращают булево значения (true, false): Метод includes():

```javascript
const plane = "Airbus A320neo";
console.log(plane.includes("A320")); // result / true
```

Проверили содержит ли переменная plane строка 'A320'.

Метод startsWith(): Проверяет начальное значения в строке и возвращает булево значения.

```javascript
console.log(plane.startsWith("Airb")); // result / true
```

Метод endsWith(): Проверяет конечное значения в строке и возвращает булево значения.

```javascript
console.log(plane.endsWith("neo")); // result / true
```

Давайте немного по практикуемся: Допустим нам нужно проверить можно ли зарегистрировать багаж, определенного пассажира.

```javascript
const checkBaggage = function (items) {
  const baggage = items.toLowerCase();
  //(переводим параметр в нижний регистр потому что в аргументах Нож, написано с большой буквы)
  if (baggage.includes("нож") || baggage.includes("пистолет")) {
    console.log("Вам запрещено находиться на борту");
  } else {
    console.log("Добро пожаловать в борт!");
  }
};
checkBaggage("У меня есть ноутбук, немного Еды и перочинный Нож");
// result / Вам запрещено находиться на борту
checkBaggage("У меня есть носки и фотоопарат");
// result / Добро пожаловать в борт!
checkBaggage("У меня есть немного еды и пистолет для самообороны");
// result / Вам запрещено находиться на борту
```

---

# РАБОТА СО СТРОКАМИ STRING - ЧАСТЬ 3

1 - Мощный строковый метод split(): Этот метод позволяет разделить строку на несколько частей.
**Пример:**

```javascript
console.log("a+very+nice+string".split("+")); // result / >(4)["a", "very", "nice", "string"]
```

Метод split() создает массив для отдельных строк, при этом исключая то что находится внутри самого метода split().
**Пример:**

```javascript
console.log("Jonas Schmedtmann".split(" ")); // result / >(2)["Jonas", "Schmedtmann"]
```

Метод split() создав новый массив, переместил внутри этого массива строки Jonas и Schmedtmann, при этом исключая пробел, который находится внутри самого метода split().

Теперь мы можем использовать диструктуризацию для создания переменных:

```javascript
const [firstName, lastName] = "Jonas Schmedtmann".split(" ");
console.log(firstName); // result / >(1)["Jonas"]
console.log(lastName); // result /  >(1)["Schmedtmann"]
```

2 - Мощный строковый метод join(): Это метод объединения, этот метод join() является противоположным, метода разделения split().
**Пример:**

```javascript
const newName = ["Mr.", firstName, lastName.toUpperCase()].join(" ");
console.log(newName); // result / Mr. Jonas SCHMEDTMANN
```

С помощью метода join(), мы получаем строка из трех элементов нашего массива newName. То есть все три элементы массива объеденили в одну строку.

Допустим мы хотим преобразовать каждую первую букву в верхний регистр у нескольких слов:
**Пример:**

```javascript
const capitalizeName = function (name) {
  const names = name.split(" ");
  const namesUpper = [];

  for (const n of names) {
    namesUpper.push(n[0].toUpperCase() + n.slice(1));
  }
  console.log(namesUpper.join(" "));
};
capitalizeName("jessica ann smith davis"); // result / Jessica Ann Smith Davis
capitalizeName("jonas schmedtmann"); // result / Jonas Schmedtmann
```

Есть еще другой способ решить верхнюю задачу:
**Пример:**

```javascript
const capitalizeName = function (name) {
  const names = name.split(" ");
  const namesUpper = [];

  for (const n of names) {
    namesUpper.push(n.replace(n[0], n[0].toUpperCase()));
  }
  console.log(namesUpper.join(" "));
};
capitalizeName("jessica ann smith davis"); // result / Jessica Ann Smith Davis
capitalizeName("jonas schmedtmann"); // result / Jonas Schmedtmann
```

Подумай и узнай логику этих задач, я понял при прохождении курса.

Метод padStart() для дополнения начало строки: Дополнения строки - это добавления определенного количество символов к строке, чтобы она стало нужной длины. 1 - Указываем длину строки, которую мы хотим. 2 - Символ который дополнит строку.
**Пример:**

```javascript
const message = "Go to gate 23!";
console.log(message.padStart(25, "+")); // result / +++++++++++Go to gate 23!
```

Теперь, длина всей строки 25. Другой пример:

```javascript
console.log("Jonas".padStart(25, "+")); // result / ++++++++++++++++++++Jonas
```

Метод padEnd() для дополнения конец строки:
**Пример:**

```javascript
console.log(message.padStart(25, "+")).padEnd(30, "+"); // result / +++++++++++Go to gate 23!+++++
```

Теперь, мы добавили еще 5 плюсов в конце строки, и длина всей строки состовляет 30.

Задача: Когда мы видим номер карты в интернете, мы никогда не видим номер карты целиком. Обычно мы видим последние 4 цифры, а остальные замаскированы какими то символами.
**Пример:**

```javascript
const maskCreditCard = function(number) {
  const str = number + ''; преобразовали число в строку (конкатинация)
  const last = str.slice(-4);
  return last.padStart(str.length, '*');
}
console.log(maskCreditCard(43347593020394)); // result / **********0394
console.log(maskCreditCard('433475930203944566')); // result / **************4566
```

Последний простой метод repeat() для строк: Это метод repeat() повторения - он позволяет повторять одну и ту же строку в несколько раз. Внутри этого метода repeat() указываем сколько раз мы хотим повторить строку:
**Пример:**

```javascript
const message = 'Bad waether... All Departues Delayed';
console.log(message.repeat(3)); // result / Bad waether... All Departues Delayed
                                            Bad waether... All Departues Delayed
                                            Bad waether... All Departues Delayed
```

---

# ПРАКТИКА (ПОДУМАЙ САМ)

```javascript
document.querySelector("button").addEventListener("click", function () {
  const text = document.querySelector("textarea").value;
  const rows = text.split("\n");

  for (const row of rows) {
    const [first, second] = row.toLowerCase().trim().split("_");
    const output = `${first}${second.replace(
      second[0],
      second[0].toUpperCase()
    )}`;
    console.log(output);
  }
});
// result / underscoreCase
firstName;
someVariable;
```

Другая задача: Можем его вбить в js файл. Я голову ломал чтобы понять его.

```javascript
const output = ['ЛюблюТебя', 'Лайк', 'Класс'];
for(const [i, row] of output.entries()) {
  const Pasrt = `${row}`;
  console.log(`${Pasrt.padEnd(20)}${'*'.repeat(i + 1)}`);
}; // result / ЛюблюТебя           *
               Лайк                **
               Класс               ***
```

Подсказка: Переменная i это первый элемент в массиве (индекс) с помощью entries(). У каждого массива переменная i индекс разное мы это знаем. По этот мы указываем i для метода repeat() для того чтобы повторилось строку '_'. Мы добавили i + 1 чтобы она изначально не было 0, а индексы начинаются с 0. Так как: У первого элемента индекс 1, повторение строки звездочки тоже 1. У второго элемента индекс 2, повторение строки звездочки тоже 2. У третьего элемента индекс 3, повторение строки звездочки тоже 3. А так, переменная i никакого отношение не имеет к элементу индекса 0, который мы выводили с помощью entries(). Мы используем переменная i только для того чтобы повторялось строка '_', для каждого элемента row индивидуально.

```

```
