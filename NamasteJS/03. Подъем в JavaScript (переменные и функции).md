````markdown
# 1. Введение в «Магию» в JavaScript

## Что показывается:

Спикер начинает со слов:
«Давайте я покажу вам магию.»

Он описывает простую программу, которая содержит:

- Переменную `x`, равную 7.
- Функцию `getname`, которая выводит название курса (в данном случае, "namaste javascript") через `console.log`.

## Ожидания против Реальности:

Изначально, когда код запускается в обычном порядке (с объявлениями в начале), вы ожидаете, что:

- Вызов функции напечатает "namaste javascript".
- `console.log(x)` выведет 7.
- Всё работает, как и должно.

---

# 2. Изменение порядка: Hoisting в действии

## Изменение порядка:

Спикер перемещает вызов функции и `console.log(x)` в начало кода — до того,
как переменная и функция реально определены в исходном коде.

## Ожидаемый результат в других языках:

Во многих языках использование переменной или функции до их объявления приведёт к ошибке.

## Что делает JavaScript (Магия):

### Функциональные объявления:

Даже если вызвать функцию до её появления в коде, JavaScript сможет её выполнить,
так как весь код функции «поднимается» (hoisting) в память до начала исполнения.

### Переменные, объявленные через var:

Если использовать переменную (например, `x`) до присвоения ей значения,
вы получите значение `undefined` вместо ошибки.

**Пример:**

```javascript
console.log(x); // выводит "undefined"
var x = 7;
```
````

### Ключевой момент:

Переменная `x` существует (для неё выделена память),
но её значение ещё не установлено.

### Результат в демо:

- Вызов `getname()` работает (выводит "namaste javascript") – код функции доступен.
- `console.log(x)` выводит `undefined` (а не 7), так как `x` был поднят, но значение ещё не присвоено.

---

# 3. Undefined vs. Not Defined

## Удаление объявления:

Спикер полностью убирает объявление `var x = 7;`.

## Объяснение разницы:

### Undefined:

Возникает, когда переменная объявлена, но ей ещё не присвоено значение.

**Пример:**

```javascript
var y;
console.log(y); // Вывод: undefined
```

### Not Defined:

Возникает, когда вы пытаетесь обратиться к переменной, которая никогда не была объявлена.

**Пример:**

```javascript
console.log(z); // Ошибка: z is not defined
```

### Ключевой вывод:

В демо, если `x` объявлена (даже если позже в коде),
hoisting задаёт ей значение `undefined`, если обратиться к ней до присвоения.

Если же объявление убрать полностью, обращение к `x` приведёт к ошибке "not defined",
так как для неё не выделена память.

---

# 4. Функциональные объявления vs. Функциональные выражения (стрелочные функции)

### Функциональные объявления:

Пишутся с использованием ключевого слова `function`.

**Поведение hoisting:**
Вся функция поднимается целиком.
То есть, даже если вы выведете её в консоль до объявления, получите полный код функции.

**Пример:**

```javascript
console.log(getname);
function getname() {
  console.log("namaste javascript");
}
```

**Вывод:** Выведется весь код функции.

### Функциональные выражения / стрелочные функции:

Когда функция объявляется как стрелочная или присваивается переменной,
она ведёт себя как переменная.

**Поведение hoisting:**
Поднимается только имя переменной с начальным значением `undefined`.

**Пример со стрелочной функцией:**

```javascript
console.log(getname); // выводит undefined
var getname = () => {
  console.log("namaste javascript");
};
```

Если вызвать `getname()` до присвоения, получится ошибка:
`"getname is not a function"`

### Итог:

- Функциональные объявления поднимаются с полным определением.
- Функциональные выражения (включая стрелочные функции) поднимаются как переменные (с `undefined`),
  поэтому их нужно определять до использования.

---

# 5. За кулисами: Hoisting и выделение памяти

## Создание Контекста Выполнения:

Когда JavaScript начинает выполнение программы,
он создаёт Контекст Выполнения, который имеет две фазы:

### Фаза создания памяти:

- JavaScript проходит по коду и выделяет память для каждой переменной и функции.
- Переменные, объявленные через `var`, получают значение `undefined`.
- Функциональные объявления сохраняют весь код.

### Фаза выполнения кода:

- JavaScript выполняет код построчно.
- Переменным присваиваются их реальные значения, а функции вызываются.

## Практический пример для визуализации hoisting:

```javascript
// Несмотря на то, что вызов функции находится в начале, JavaScript уже знает о getname.

getname(); // Вывод: "namaste javascript"
console.log(x); // Вывод: undefined

var x = 7;

function getname() {
  console.log("namaste javascript");
}
```

### Объяснение:

Во время **Фазы создания памяти**, переменная `x` создаётся и получает значение `undefined`,
а `getname` создаётся с полным кодом функции.

Во время **Фазы выполнения кода**, когда вызывается `getname()`,
всё работает как ожидается, а затем `x` получает значение 7.

---

# 6. Демонстрация работы отладчика и Стек Вызовов

## Использование отладчика:

Спикер описывает установку точки останова (`debugger`) на первой строке кода.
До того как начнётся выполнение:

- Глобальный Контекст Выполнения уже создан.
- Память для переменных и функций выделена (переменные получают временное значение `undefined`).

## Наблюдение за глобальной областью:

В отладчике браузера можно просмотреть глобальную область (память).
Например, вы увидите, что `x` существует и имеет значение `undefined` (если оно объявлено позже).
Также функция `getname` доступна с полным кодом, если это функциональное объявление.

## Обзор Стека Вызовов:

### Что такое Стек Вызовов?

Стек вызовов — это структура данных-стек, которая управляет Контекстами Выполнения.

### Как это работает:

- При вызове функции создаётся новый Контекст Выполнения, который помещается в стек.
- Как только функция завершается, её Контекст Выполнения снимается со стека.

### Визуальный пример:

- Глобальный Контекст Выполнения помещается внизу стека.
- Когда вызывается `getname()`, новый контекст помещается поверх.
- После завершения `getname()` этот контекст удаляется, и управление возвращается к Глобальному Контексту Выполнения.

### Демо:

Спикер использует команды `debugger`, чтобы показать,
как выполнение переходит из одного контекста в другой, подтверждая,
что стек вызовов управляет порядком исполнения.

---

# 7. Резюме и ключевые концепции

## Hoisting:

**Определение:** Процесс, при котором JavaScript-движок перемещает объявления переменных и функций
в начало их области видимости перед выполнением кода.

**Результат:**

- Переменные, объявленные через `var`, получают начальное значение `undefined`.
- Функциональные объявления доступны полностью, даже если вызваны до их фактического появления в коде.

## Undefined vs. Not Defined:

- **Undefined:** Объявленная переменная, которой ещё не присвоено значение.
- **Not Defined:** Попытка обратиться к переменной, которая никогда не была объявлена.

## Функциональные объявления vs. Функциональные выражения:

- **Объявления:** Поднимаются с полным кодом.
- **Выражения** (включая стрелочные функции): Поднимаются как переменные с начальным значением `undefined`.

## Фазы Контекста Выполнения:

### Фаза создания памяти (hoisting):

- Обрабатываются все объявления; выделяется память.

### Фаза выполнения кода:

- Код исполняется построчно; происходят присваивания и вызовы функций.

## Стек Вызовов:

- Управляет порядком вызовов функций.
- Каждый новый вызов функции создаёт новый Контекст Выполнения, который помещается в стек.
- После завершения функции её контекст снимается со стека.

---

# 8. Заключительные мысли

## Почему это важно?

- Понимание hoisting помогает объяснить, почему функции и переменные
  иногда можно использовать до их фактического объявления в коде.

- Знание разницы между функциональными объявлениями и функциональными выражениями
  (например, стрелочными функциями) помогает избежать ошибок вроде «getname is not a function».

- Концепции стека вызовов и Контекста Выполнения являются фундаментальными
  для отладки и понимания поведения JavaScript.

## Совет для интервью:

При вопросе о hoisting можно объяснить, что JavaScript выделяет память
для переменных и функций до начала выполнения кода,
а также уточнить разницу между объявлениями и выражениями.

```

```
