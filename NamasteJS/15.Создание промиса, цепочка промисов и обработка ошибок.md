## **Введение (00:00-01:03)**

**Что говорит автор:**
Автор выражает энтузиазм по поводу промисов и анонсирует, что в этом видео мы перейдем от потребления промисов к их созданию. Он подчеркивает практическую ценность этих знаний для становления профессиональным разработчиком.

**Мое подробное объяснение:**
До этого мы учились работать с готовыми промисами (например, от `fetch` API). Теперь пришло время научиться создавать свои собственные промисы, что является фундаментальным навыком для работы с асинхронными операциями в JavaScript.

---

## **Создание собственного Promise (01:03-13:24)**

### **Базовый пример с createOrder**

**Что говорит автор:**
Автор продолжает пример с e-commerce и показывает, как создать функцию `createOrder`, которая возвращает промис.

**Код создания промиса:**

```javascript
const cart = ["shoes", "pants", "kurta"];

function createOrder(cart) {
  const pr = new Promise(function (resolve, reject) {
    // логика создания заказа
    if (!validateCart(cart)) {
      const err = new Error("Cart is not valid");
      reject(err);
    }
    // логика для успешного случая
    const orderId = "12345";
    resolve(orderId);
  });

  return pr;
}
```

**Мое подробное объяснение создания промиса:**

1. **Конструктор Promise:**

   ```javascript
   new Promise(executorFunction);
   ```

   - Создает новый объект Promise
   - Принимает функцию-исполнитель (executor), которая выполняется сразу же

2. **Функция-исполнитель:**

   ```javascript
   function(resolve, reject) { ... }
   ```

   - Получает два параметра: `resolve` и `reject` - это функции, предоставляемые JavaScript
   - **resolve(value)** - вызывается при успешном выполнении операции
   - **reject(error)** - вызывается при ошибке

3. **Логика внутри промиса:**
   - Валидация входных данных
   - Выполнение асинхронной операции
   - Вызов `resolve()` при успехе или `reject()` при ошибке

### **Асинхронное поведение с setTimeout**

**Что говорит автор:**
Автор добавляет `setTimeout` для демонстрации реального асинхронного поведения:

```javascript
function createOrder(cart) {
  return new Promise(function (resolve, reject) {
    if (!validateCart(cart)) {
      reject(new Error("Cart is not valid"));
    }

    setTimeout(function () {
      const orderId = "12345";
      resolve(orderId);
    }, 5000);
  });
}
```

**Мое подробное объяснение:**

- Промис немедленно возвращается в состоянии `pending`
- Через 5 секунд автоматически вызывается `resolve(orderId)`
- Состояние промиса меняется с `pending` на `fulfilled`
- Все прикрепленные колбэки в `.then()` выполняются

### **Потребление созданного промиса**

```javascript
// Потребление промиса
createOrder(cart).then(function (orderId) {
  console.log(orderId); // "12345" после 5 секунд
});
```

---

## **Обработка ошибок (15:30-17:59)**

**Что говорит автор:**
Автор показывает, что происходит при отклонении промиса и как правильно обрабатывать ошибки.

**Проблема без обработки ошибок:**

```javascript
// Если validateCart возвращает false
createOrder(cart).then(function (orderId) {
  console.log(orderId);
});
// В консоли: Uncaught Error: Cart is not valid
```

**Решение с обработкой ошибок:**

```javascript
createOrder(cart)
  .then(function (orderId) {
    console.log(orderId);
  })
  .catch(function (err) {
    console.log(err.message); // "Cart is not valid"
  });
```

**Мое подробное объяснение обработки ошибок:**

1. **Метод `.catch()`:**

   - Специальный метод для обработки отклоненных промисов
   - Принимает функцию-колбэк, которая выполняется при ошибке
   - Получает объект ошибки в качестве параметра

2. **Важность обработки ошибок:**

   - Предотвращает "красные ошибки" в консоли
   - Позволяет gracefully обработать неудачные сценарии
   - Можно показать пользователю понятное сообщение об ошибке

3. **Синтаксис:**
   ```javascript
   promise.then(successCallback).catch(errorCallback);
   ```

---

## **Цепочки Promises (Promise Chaining) (18:32-31:53)**

### **Базовая цепочка**

**Что говорит автор:**
Автор расширяет пример, добавляя `proceedToPayment` и демонстрирует правильный способ создания цепочек.

**Неправильный подход (антипаттерн):**

```javascript
createOrder(cart).then(function (orderId) {
  proceedToPayment(orderId) // ОШИБКА: забыт return!
    .then(function (paymentInfo) {
      console.log(paymentInfo);
    });
});
```

**Правильный подход с цепочкой:**

```javascript
createOrder(cart)
  .then(function (orderId) {
    return proceedToPayment(orderId); // ВАЖНО: return!
  })
  .then(function (paymentInfo) {
    console.log(paymentInfo);
  });
```

**Мое подробное объяснение цепочек:**

### **Принцип работы цепочек:**

1. **Каждый `.then()` возвращает новый промис**
2. **Значение, возвращаемое из колбэка `.then()`, становится результатом этого нового промиса**
3. **Если возвращается промис, следующий `.then()` ждет его разрешения**

### **Детальный разбор:**

```javascript
createOrder(cart)
  // Шаг 1: createOrder возвращает промис с orderId
  .then(function (orderId) {
    // Возвращаем промис от proceedToPayment
    return proceedToPayment(orderId);
  })
  // Шаг 2: Этот then ждет разрешения промиса от proceedToPayment
  .then(function (paymentInfo) {
    // paymentInfo - результат промиса proceedToPayment
    console.log(paymentInfo);
    // Если ничего не возвращаем, следующий then получит undefined
  });
```

### **Реализация proceedToPayment:**

```javascript
function proceedToPayment(orderId) {
  return new Promise(function (resolve, reject) {
    // Асинхронная логика оплаты
    setTimeout(function () {
      const paymentInfo = {
        status: "success",
        transactionId: "txn_12345",
      };
      resolve(paymentInfo);
    }, 2000);
  });
}
```

### **Расширенная цепочка с несколькими операциями**

```javascript
createOrder(cart)
  .then(function (orderId) {
    console.log("Order created:", orderId);
    return proceedToPayment(orderId);
  })
  .then(function (paymentInfo) {
    console.log("Payment completed:", paymentInfo);
    return showOrderSummary(paymentInfo);
  })
  .then(function (summary) {
    console.log("Order summary:", summary);
    return updateWalletBalance(summary);
  })
  .then(function (walletBalance) {
    console.log("Wallet updated:", walletBalance);
  })
  .catch(function (error) {
    console.log("Error in chain:", error.message);
  });
```

---

## **Продвинутая обработка ошибок в цепочках (28:23-31:53)**

**Что говорит автор:**
Автор показывает, как strategically размещать `.catch()` для тонкой обработки ошибок.

### **Различные стратегии обработки ошибок:**

**1. Глобальный catch (ловит все ошибки в цепочке):**

```javascript
createOrder(cart)
  .then((orderId) => proceedToPayment(orderId))
  .then((paymentInfo) => showOrderSummary(paymentInfo))
  .then((summary) => updateWalletBalance(summary))
  .catch(function (error) {
    // Поймает ЛЮБУЮ ошибку в цепочке
    console.log("Something went wrong:", error.message);
  });
```

**2. Локальные catch с продолжением цепочки:**

```javascript
createOrder(cart)
  .then((orderId) => proceedToPayment(orderId))
  .catch(function (error) {
    // Обрабатываем ошибки только из createOrder и proceedToPayment
    console.log("Error in order/payment:", error.message);
    // Возвращаем значение по умолчанию чтобы продолжить цепочку
    return "default_payment_info";
  })
  .then(function (paymentInfo) {
    // Этот then ВСЕГДА выполнится, даже если выше был catch
    return showOrderSummary(paymentInfo);
  })
  .then((summary) => updateWalletBalance(summary))
  .catch(function (error) {
    // Этот catch ловит ошибки только из showOrderSummary и updateWalletBalance
    console.log("Error in summary/wallet:", error.message);
  });
```

**3. then после catch (всегда выполняется):**

```javascript
createOrder(cart)
  .then((orderId) => proceedToPayment(orderId))
  .catch(function (error) {
    console.log("Handled error:", error.message);
    // Не возвращаем значение - следующий then получит undefined
  })
  .then(function (result) {
    // ВЫПОЛНИТСЯ ВСЕГДА, даже если была ошибка
    // result будет undefined если был catch
    console.log("This always executes");
  });
```

**Мое подробное объяснение стратегий ошибок:**

- **Глобальный catch** в конце цепочки - самый простой подход
- **Локальные catch** позволяют обработать ошибки на определенных этапах и продолжить выполнение
- **then после catch** выполняется всегда, что полезно для cleanup операций
- **Возврат значения из catch** позволяет "восстановить" выполнение цепочки

---

## **Итоги и ключевые концепции (32:31-35:52)**

### **Создание промисов:**

```javascript
return new Promise(function (resolve, reject) {
  // Асинхронная логика
  if (success) {
    resolve(value);
  } else {
    reject(error);
  }
});
```

### **Потребление промисов:**

```javascript
promise.then(successCallback).catch(errorCallback);
```

### **Цепочки промисов:**

```javascript
apiCall1()
  .then((result1) => apiCall2(result1)) // ВАЖНО: return!
  .then((result2) => apiCall3(result2))
  .then((result3) => finalOperation(result3))
  .catch((error) => handleError(error));
```

### **Ключевые моменты:**

1. **Всегда возвращайте значения** из `.then()` для передачи по цепочке
2. **Используйте `.catch()`** для обработки ошибок
3. **Промисы immutable** - нельзя изменить после создания
4. **Цепочки избегают callback hell** и делают код читаемым

---

## **Домашнее задание (35:52-38:13)**

**Задача:** Создать цепочку из 4 асинхронных операций для e-commerce:

1. `createOrder(cart)` → возвращает `orderId`
2. `proceedToPayment(orderId)` → возвращает `paymentInfo`
3. `showOrderSummary(paymentInfo)` → возвращает `summary`
4. `updateWalletBalance(summary)` → обновляет баланс

**Требования:**

- Каждая функция должна возвращать промис
- Реализовать правильную цепочку с передачей данных
- Добавить обработку ошибок
- Использовать как глобальные, так и локальные catch

**Пример решения:**

```javascript
// 1. Create Order
function createOrder(cart) {
  return new Promise((resolve, reject) => {
    if (!validateCart(cart)) {
      reject(new Error("Cart is not valid"));
      return;
    }
    setTimeout(() => {
      const orderId = "ORDER_" + Math.random().toString(36).substr(2, 9);
      resolve(orderId);
    }, 1000);
  });
}

// 2. Proceed to Payment
function proceedToPayment(orderId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.2) {
        // 80% успешных платежей
        resolve({
          orderId: orderId,
          status: "success",
          amount: 1000,
        });
      } else {
        reject(new Error("Payment failed"));
      }
    }, 1500);
  });
}

// 3. Show Order Summary
function showOrderSummary(paymentInfo) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        items: 3,
        total: 1000,
        paymentStatus: paymentInfo.status,
      });
    }, 500);
  });
}

// 4. Update Wallet
function updateWalletBalance(summary) {
  return new Promise((resolve) => {
    setTimeout(() => {
      const newBalance = 5000 - summary.total;
      resolve(`Wallet balance updated: $${newBalance}`);
    }, 800);
  });
}

// Цепочка промисов с обработкой ошибок
createOrder(cart)
  .then((orderId) => {
    console.log("Order created:", orderId);
    return proceedToPayment(orderId);
  })
  .catch((error) => {
    console.log("Order creation failed:", error.message);
    // Возвращаем заглушку чтобы продолжить цепочку
    return "FALLBACK_ORDER";
  })
  .then((paymentInfo) => {
    if (typeof paymentInfo === "string") {
      // Это fallback от catch - пропускаем оплату
      console.log("Skipping payment due to previous error");
      return { status: "skipped", amount: 0 };
    }
    console.log("Payment completed:", paymentInfo);
    return showOrderSummary(paymentInfo);
  })
  .then((summary) => {
    console.log("Order summary:", summary);
    return updateWalletBalance(summary);
  })
  .then((walletResult) => {
    console.log(walletResult);
  })
  .catch((finalError) => {
    console.log("Final error:", finalError.message);
  });
```
