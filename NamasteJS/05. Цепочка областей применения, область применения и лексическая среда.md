````markdown
# 1. Обзор: Область видимости и лексическое окружение

## Область видимости в JavaScript:

**Определение:** Область видимости определяет, в какой части кода
можно получить доступ к переменной или функции.

**Ключевой вопрос:** «Где я могу использовать конкретную переменную или функцию?»

## Лексическое окружение:

**Определение:** Лексическое окружение — это, по сути,
«локальная память» текущего контекста выполнения плюс ссылка
(указатель) на лексическое окружение родительского контекста.

## Почему это важно:

- Оно формирует цепочку областей видимости (scope chain) — серию окружений, по которым JavaScript ищет переменные.
- Понимание лексического окружения является базой
  для понимания области видимости, цепочек областей видимости и замыканий.

---

# 2. Простой пример: Глобальная и локальная области видимости

## Пример кода:

```javascript
var b = 10; // Глобальная переменная

function a() {
  // Функция 'a' объявлена в глобальной области видимости
  console.log(b); // Вопрос: Можно ли получить доступ к 'b'?
  // Ответ: Да, так как 'b' находится во внешнем (глобальном) лексическом окружении.

  function c() {
    // Функция 'c' объявлена внутри 'a'
    console.log(b); // Вопрос: Что здесь произойдёт?
    // Ответ: 'c' также имеет доступ к 'b' через окружение своей родительской функции 'a', а затем — глобальное.
  }

  c(); // Вызов 'c'
}

a(); // Вызов 'a'
```
````

## Объяснение:

### Глобальная область видимости:

- Переменная `b` объявлена глобально.
- Функция `a`, а вместе с ней и её вложенная функция `c`, могут получить доступ к `b`,
  так как они лексически находятся в глобальной области.

### Внутри функции a:

При выполнении `console.log(b)` движок сначала ищет `b` в локальной памяти функции `a`.
Если не находит, он переходит по ссылке на лексическое окружение глобальной области,
где и находит `b` со значением 10.

### Внутри функции c:

Аналогично, когда `c` выполняет `console.log(b)`, она сначала ищет `b` в своём локальном окружении,
затем по ссылке в окружении функции `a`, а если и там не найдёт — переходит в глобальную область и находит `b`.

---

# 3. Что такое лексическое окружение?

## Компоненты лексического окружения:

### Локальная память (Environment Record):

Содержит все локальные переменные и объявления функций данного контекста выполнения.

### Ссылка на лексическое окружение родителя:

Указатель (часто изображается как «оранжевая стрелка» на схемах)
на лексическое окружение родительского контекста.

## Визуальное представление:

```
Global Lexical Environment
       │
       ▼
[ Переменные: { b: 10, a: [функция] } ]
       │
       └─────► Родителя глобального окружения нет (null)

─────────────────────────────

Контекст выполнения для функции a
       │
       ▼
[ Локальные переменные: { } ]   <-- (здесь 'b' не объявлена)
       │
       └─────► Ссылка на Global Lexical Environment

─────────────────────────────

Контекст выполнения для функции c (внутри a)
       │
       ▼
[ Локальные переменные: { } ]   <-- ('b' не объявлена в "c")
       │
       └─────► Ссылка на лексическое окружение функции "a"
```

## Ключевой момент:

Лексическое окружение = Локальная память + Ссылка на родительское окружение.
Оно создаётся в зависимости от того, где физически написаны функции и переменные в коде.

---

# 4. Цепочка областей видимости (Scope Chain)

## Определение:

Цепочка областей видимости — это последовательность лексических окружений,
по которых JavaScript проходит для разрешения ссылок на переменные.

## Как это работает:

- При обращении к переменной в функции (или любом блоке)
  JavaScript сначала проверяет локальное лексическое окружение.
- Если переменная не найдена, он смотрит в лексическое окружение родителя.
- Этот процесс продолжается до глобального лексического окружения.

- Если переменная так и не найдена,
  генерируется ошибка `ReferenceError` ("переменная не определена").

## Пример:

В приведённом ранее коде, когда функция `c` выполняет `console.log(b)`,
она не находит `b` в своём окружении, затем обращается к окружению функции `a`,
а далее к глобальному окружению, где и находит `b` со значением 10.

## Важно:

Если бы `b` не была объявлена ни в одном звене цепочки
(ни в глобальном, ни в `a`, ни в `c`), движок не смог бы её найти и вызвал бы ошибку.

---

# 5. Проверка границ: Когда переменные недоступны

## Сценарий 1:

Если объявить `b` внутри функции `a`, то она будет доступна только внутри `a` и её дочерних функций:

```javascript
function a() {
  var b = 10;
  console.log(b); // Выведет 10
  function c() {
    console.log(b); // Также выведет 10
  }
  c();
}
a();
console.log(b); // ReferenceError: b is not defined (так как b локальна для "a")
```

## Сценарий 2:

Если попытаться обратиться к переменной вне цепочки,
где она была объявлена, JavaScript не найдёт её, так как она не входит в лексическую цепочку.

---

# 6. Резюме: Определения и их взаимосвязь

## Область видимости (Scope):

«Где я могу получить доступ к переменной или функции?»

## Лексическое окружение:

«Контейнер», который хранит переменные текущего контекста
и имеет ссылку на родительское окружение.

## Цепочка областей видимости (Scope Chain):

Связанный список лексических окружений,
через которые JavaScript проходит для разрешения идентификаторов.

## Два взгляда на область видимости:

### С точки зрения переменной:

«Какова область видимости переменной b?» — т.е. где b доступна.

### С точки зрения функции:

«Находится ли b в области видимости функции "c"?» — т.е.
может ли c получить доступ к b через свою лексическую цепочку.

---

# 7. Визуализация процесса

Представьте себе вложенные коробки:

### Глобальная коробка:

Содержит глобальные переменные и функции.

### Коробка функции "a" (внутри глобальной):

Содержит свои локальные переменные и ссылку (стрелку) на глобальную коробку.

### Коробка функции "c" (внутри a):

Содержит свои локальные переменные и стрелку,
указывающую на коробку функции a (а косвенно — на глобальную коробку).

При поиске переменной в функции "c" движок сначала проверяет коробку "c",
затем следует по стрелке в коробку "a", а если там не находит — переходит в глобальную коробку.

---

# 8. Почему лексическое окружение важно для замыканий

## Замыкания (Closures):

Замыкание возникает, когда функция «запоминает» своё лексическое окружение даже после того,
как родительская функция завершила выполнение.

Поскольку функция хранит ссылку на родительское лексическое окружение
(ту самую «оранжевую стрелку»), она может получить доступ к переменным,
определённым в этом окружении, даже спустя время.

## Пример замыкания:

```javascript
function a() {
  var b = 10;
  function c() {
    console.log(b); // Функция "c" имеет доступ к b, даже после завершения a()
  }
  return c;
}

var closureFunction = a(); // Функция a возвращает функцию "c"
closureFunction(); // Выведет 10, так как "c" всё ещё имеет доступ к b через своё лексическое окружение
```

---

# 9. Итоговое резюме

## Лексическое окружение:

«Локальная память + ссылка на окружение родителя».
Создаётся каждый раз при создании нового контекста выполнения.

## Цепочка областей видимости:

Последовательность связанных лексических окружений,
по которым JavaScript ищет переменные.

## Область видимости (Scope):

Определяет, где можно получить доступ к переменной или функции
на основе их физического расположения в коде.

## Практическое значение:

Знание этих концепций упрощает понимание поиска переменных,
работы замыканий и объясняет, почему код ведёт себя определённым образом в разных частях программы.

Понимание этих базовых понятий поможет вам читать,
отладывать и писать JavaScript-код, особенно когда дело касается вложенных функций и замыканий.

```

```
