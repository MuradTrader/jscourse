```markdown
# Основы асинхронности в JavaScript

## 1. Основы JavaScript

### Синхронность и однопоточность:

JavaScript выполняет код построчно в одном стеке вызовов.
В один момент времени может обрабатываться только одна задача.

### Стек вызовов (Call Stack):

Это структура LIFO (Last-In-First-Out), в которую помещаются функции для выполнения.
Пример: сначала в стек помещается Глобальный Контекст Выполнения (GEC), затем – контексты вызовов функций.

## 2. Необходимость асинхронных операций

### Ограничения стека вызовов:

Стек вызовов не может сам по себе обрабатывать задержки (например, таймеры или сетевые запросы).

### Суперспособности браузера (Web APIs):

API, такие как `setTimeout`, `fetch`, манипуляция DOM и даже `console.log`,
не являются частью чистого JavaScript, а предоставляются браузерами.
К ним можно обращаться через глобальный объект `window`
(например, `window.setTimeout` или просто `setTimeout`).

## 3. Событийный цикл (Event Loop) и очередь колбэков

### Очередь колбэков (Callback Queue или Task Queue):

Здесь хранятся асинхронные колбэки (например, от `setTimeout`, обработчики DOM-событий) до тех пор,
пока стек вызовов не опустеет.
Это структура FIFO (First-In-First-Out).

### Событийный цикл (Event Loop):

Постоянно проверяет:

- Пуст ли стек вызовов?
- Есть ли задачи в очереди колбэков?

Если да, то он перемещает задачи из очереди колбэков в стек вызовов для выполнения.

### Пример работы с setTimeout:
```

Вызов setTimeout(cb, 5000) регистрирует функцию cb в Web APIs и запускает таймер на 5 секунд.
После 5 секунд функция cb перемещается в очередь колбэков.
Когда стек вызовов опустеет, событийный цикл помещает cb в стек вызовов для выполнения.

```

## 4. Очередь микрозадач (Microtask Queue)

### Более высокий приоритет:
Микрозадачи выполняются перед задачами из очереди колбэков.
В основном используются для разрешения Promise и для Mutation Observer.

### Риск голодания:
Если микрозадачи генерируют новые микрозадачи, задачи из очереди колбэков могут никогда не выполниться.

### Пример работы с fetch:
```

Функция fetch() выполняет сетевой запрос и регистрирует свой колбэк (например, cbn) в Web APIs.
Когда данные получены, cbn перемещается в очередь микрозадач.
Событийный цикл отдаёт приоритет микрозадачам перед задачами из очереди колбэков.

````

## 5. Основные различия: Очередь колбэков vs. Очередь микрозадач

| Очередь колбэков (Task Queue) | Очередь микрозадач (Microtask Queue) |
|-------------------------------|--------------------------------------|
| `setTimeout`, DOM-события, `setInterval` | Promises, MutationObserver |
| Низкий приоритет | Высокий приоритет |
| Обрабатываются после микрозадач | Обрабатываются перед задачами из колбэк-очереди |

## 6. Порядок выполнения кода

### Синхронный код:
Выполняется сразу в стеке вызовов (например, `console.log("Start")`).

### Асинхронный код:
Web APIs обрабатывают таймеры, сетевые запросы и т.д.
Колбэки отправляются либо в очередь колбэков, либо в очередь микрозадач.

### Событийный цикл:
Сначала выполняет микрозадачи, затем задачи из очереди колбэков.

### Пример:
```javascript
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
fetch("url").then(() => console.log("Fetch"));
console.log("End");
````

**Ожидаемый вывод:**

```
Start
End
Fetch   // Выполнено из очереди микрозадач (Promise)
Timeout // Выполнено из очереди колбэков
```

## 7. Голодание очереди колбэков

### Сценарий:

Если микрозадачи (например, промисы) рекурсивно добавляют новые микрозадачи,
задачи в очереди колбэков (например, от `setTimeout`) могут откладываться бесконечно.

## 8. Основные выводы

### Стек вызовов:

Выполняет код синхронно;
сам по себе не обрабатывает таймеры или асинхронные операции.

### Web APIs:

Функциональность,
предоставляемая браузером (таймеры, сетевые запросы и т.д.).

### Очереди:

- **Очередь микрозадач**: Высокий приоритет (Promise, MutationObserver)
- **Очередь колбэков**: Низкий приоритет (`setTimeout`, DOM-события)

### Событийный цикл:

Координирует выполнение задач между стеком вызовов и очередями,
отдавая приоритет микрозадачам.

## 9. Вопросы для интервью

### Что такое событийный цикл?

Механизм, который проверяет стек вызовов и очереди,
отдавая приоритет микрозадачам перед задачами из очереди колбэков.

### Почему `setTimeout(fn, 0)` выполняется после Promise?

Потому что промисы попадают в очередь микрозадач (высокий приоритет),
а `setTimeout` — в очередь колбэков (низкий приоритет).

### Может ли очередь колбэков «голодать»?

Да, если микрозадачи постоянно добавляют новые микрозадачи.

## 10. Итоговая диаграмма

```
[JS Engine]
│
├── Call Stack (Синхронное выполнение)
│
├── Web APIs (Функционал браузера: setTimeout, fetch, DOM)
│
├── Microtask Queue (Промисы, MutationObserver) → ВЫСОКИЙ ПРИОРИТЕТ
│
├── Callback Queue (setTimeout, DOM-события) → НИЗКИЙ ПРИОРИТЕТ
│
└── Event Loop (Проверяет стек вызовов → обрабатывает микрозадачи → затем задачи из очереди колбэков)
```

```

```
