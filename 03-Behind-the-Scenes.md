# КОНТЕКСТ ВЫПОЛНЕНИЯ

## SCOPE CHAIN (Цепочка областей видимости в текущей контексте)

Давайте разберемся что такое область видимости, и цепочка областей видимости.

Начнем с того, что такое область видимости, и какие связанные сними понятие существуют:

**1 - Scoping**  
По сути область видимости отвечает на вопрос где живут переменные.  
Где мы можем получить доступ к определенной переменной, а где нет.

**2 - Lexical scoping**  
В JS есть понятия лексические область видимости:  
Лексическая область видимости означает что способ организация доступа к переменным  
полностью зависит от размещения функции блоков кода в программе.  
Например функция написанная внутри в другой функции,  
имеет доступ к переменным родительской функции.  
Таким образом на область видимости влияет то, где именно мы пишем функции блоки кода.

**3 - Scope**  
А теперь поговорим о самой области видимости:  
Область видимости это пространство или среда в которой объявлена определенная переменная.  
В случае с функциями это по сути переменная среда, которая хранится в контексте выполнения функции.  
И так если мы сейчас задаемся вопросом в чем разница между областью видимости и контекстом переменной?  
В случае с функциями это по сути одно и тоже.  
В JS есть глобальная область видимости:  
Область видимости функции.  
Область видимости блока.

**4 - Scope of a variable**  
Что такое область видимости переменной ?  
Область видимости переменной - это по сути весь код в котором можно получить  
доступ к определенной переменной.

Виды области видимости в JS:  
1 - Global Scope  
2 - Function Scope  
3 - Block Scope (ES6)  
Помните что область видимости - это место в нашем коде, где объявляются переменные.  
И когда мы говорим переменная это в равной степени относится и к функциям,  
потому что в конечном счете функция это просто значения хранящиеся в переменных.

**1 - Global Scope**  
Глобальная область видимости - это код верхнего уровня.  
Это переменная объявленная вне какой либо функции или блока.  
Эти переменные будут доступны везде в нашей программе, во всех функциях и блоках.

**2 - Function Scope**  
Область видимости функции - создает область видимости и переменная объявленная  
внутри этой функции, доступно только внутри нее.  
Это называется локальной областью видимости.  
Таким образом локальные переменные существуют только внутри функции,  
а за ее пределоми они не доступны.

Пример:

```javascript
function calcAge(birthYear) {
  const now = 2037;
  const age = now - birthYear;
  return age;
}
console.log(now); // result / ReferenceError
```

В этом примере мы видим что переменная (now) объявленная внутри функции,  
не доступен за пределами этой функции, когда мы хотим получить доступ к этой переменной с помощью console.  
Таким образом JS пытается искать данную переменную (now) в глобальной области видимости,  
но не может ее найти.  
И здесь не имеет значение какую функцию мы используем,  
объявления функции, выражения функции, стрелочные функции,  
все они создают свои собственные области видимости.

**3 - Block Scope (ES6)**  
Блоки тоже создают свои области видимости.  
Под блоками мы подразумеваем все что заключено в фигурные скобки {}.  
Например блок оператора if или цикла for, но с объектами это не работает.  
Также как и с функциями переменные объявленные внутри блока  
доступны только внутри этого блока а не за его пределами.  
Но есть одно большое отличия:  
Область видимости блока распространяется только на переменные объявленные с помощью let или const.  
По этому мы говорим что переменные let и const имеют область видимости блока.  
Если бы мы объявили переменную с помощью var в этом блоке, она была бы доступно за его пределами  
и имела бы область видимости текущей функции или глобальной область видимости.  
По этому мы говорим переменные var имеют область видимости функции.

Пример кода для всех областей видимости:

```javascript
const myName = 'Jonas'; //Global Scope
function first() {      //first() scope
  const age = 30;
  if (age >= 30) {     //block scope
    const decade = 3;
    var millenial = true; //var не ограничено только блока области видимости,
                            он является частью первой области видимости функции first().
  }
  function second() {   //second() scope (вложенная функция)
    const job = 'teacher';

    console.log(`${myName} is a ${age}-old ${job}`); // result / Jonas is a 30-old teacher
    //Каждая область видимости всегда имеет доступ ко всем переменным из всех внешних областей видимости,
     то есть из всех родительских областей видимости.
  }
  second();
}
first();
```

Замечания:  
У одной области видимости никогда не будет доступа к переменным  
внутренней области видимости, то есть мы не можем получать доступ  
к переменным из областей видимости сверху вниз, только снизу вверх.  
По этому можно использовать только родительскую область видимости но не дочерние.

И еще дочерняя область видимости if() {block scope},  
не имеет доступ к переменным у другого дочернего области видимости second().

Если переменная var является частью первой области видимости функции first(),  
то конечно область видимости второй функции second() также имеет к ним доступ.

let и const - имеют блочную область видимости.  
var - имеет функциональную область видимости.  
function - имеет блочная область видимости, то есть  
если функция было создано внутри блока, то вызвать мы можем его внутри блока,  
а не за предалами блока.  
Но это работает для строгого режима, если отключить строгий режим  
то область видимости функции это функциональная область видимости.

У нас могут быть переменные с одинаковыми названиями на разных областей видимости,  
потому что эти переменные находятся в разных областях видимости.  
И когда переменная к примеру firstName было объявлено в текущей области видимости,  
и точно с таким же названием переменная firstName была объявлено в глобальной области видимости,  
и когда мы хотим получить доступ к нему в текущей области видимости, JS дает нам значения переменной  
которая была объявлено в текущей области видимости, а не значения переменной  
которая была объявлено в глобальной области видимости.

---

## ПРАКТИКА ОБЛАСТЕЙ ВИДИМОСТИ

```javascript
function calcAge(birthYear) {
  const age = 2037 - birthYear;
  console.log(firstName);
  return age;
}

const firstName = "Jonas";
calcAge(1991); // result / Jonas
```

Таким образом мы получаем доступ к переменной firstName внутри функции calcAge().  
Так как переменная firstName находится в глобальной области видимости,  
и объявили данную переменную в начале до вызова функции calcAge(1991).  
Но если бы мы вызвали функцию calcAge сперва, а потом объявили бы переменную firstName,  
в консоле нам выдали бы ошибку, так как JS пытается найти переменную firstName  
в родительском области видимости или в глобальном области видимости, но не может найти  
потому что код внутри функции уже запустилось код а переменная не объявлена до вызова функции calcAge().  
К примеру вот так:

```javascript
calcAge(1991); // result / Не удается получить доступ к 'FirstName' перед инициализацией calcAge
const firstName = "Jonas";
```

---

## ПОДНЯТИЕ ПЕРЕМЕННЫХ (Variable environment)

Мы знаем что контекст выполнения всегда состоит из 3 частей:  
1 - Окружение переменных (Variable environment)  
2 - Цепочка областей видимости и в текущей контексте (Scope chain)  
3 - Ключевое слово this (this keyword)

Мы уже изучили цепочку областей видимоcти (Scope chain),  
теперь пришло время подробнее рассмотреть окружение переменных (Variable environment),  
и в частности то, как создаются переменные в JavaScript.

И так в JS есть механизм который называется поднятие переменных.  
Он позволяет использовать некоторые типы переменных до того,  
как они будут объявлены в коде.

(Объявление функции)  
Поднятие: ДА  
Начальное значение: Фактическая функция (вызов функции до объявлении функции)  
Область видимости: (строгий режим) Блочная (не строгий) функциональную

(Переменная var)  
Поднятие: ДА  
Начальное значение: Undefined  
Область видимости: Функциональная

(Переменные let и const)  
Поднятие: НЕТ  
Начальное значение: uninitialized, TDZ (временная мертвая зона)  
Область видимости: Блочная

(Выражения функции и Стрелочные функции)  
Поднятие: Зависит от того были ли они созданы с помощью let const или var  
Начальное значение: Зависит от того были ли они созданы с помощью let const или var  
Область видимости: Зависит от того были ли они созданы с помощью let const или var  
Потому что они как переменные.

Давайте рассмотрим временную мертвую зону:  
Пример:

```javascript
const myName = "Jonas";
if (myName === "Jonas") {
  console.log(`Jonas is a ${job}`);
  const age = 2037 - 1989;
  console.log(age);
  const job = "teacher";
} // result / ReferenceError: Cannot access 'job' before initialization
```

Обращаем внимание на переменную (job), временная мертвая зона  
у этой переменной является все что выше него, внутри данного блока if.  
Данная переменная (job) была определено внутри области видимости данного блока.  
И мы хотим получить доступ к нему в console, это не сработает,  
так как переменные объявленные с помощью let и const не поднимаются.  
У этой переменной (job) временная мертвая зона начинается в начале области видимости данного блока,  
и заканчивается в строке где она объявлено.  
Использовать данную переменную (job) можно только после выхода из временной мертвой зоны.

---

## КЛЮЧЕВОЕ СЛОВО THIS

Давайте рассмотрим 4 разных вида вызова функции:

**1 - Method >this = Функция прикрепленная к объекту.**  
Когда мы вызываем Method то ключевое слово this внутри этого метода,  
будет указывать на объект котороый вызывает метод.  
Пример:

```javascript
const jonas = {
  name: "Jonas",
  year: 1989,
  calcAge: function () {
    return 2037 - this.year; // jonas.year
  },
};
jonas.calcAge(); // result / 48
```

**2 - Вызов обычных функции**  
То есть не как метод который привязан к какому либо объекту.  
В этом случае, ключевое слово this будет просто Undefined,  
однако это применимо в строгом режиме.  
Если строгий режим отключен, this будет указывать на глобальный объект,  
который в браузере является объект window.

**3 - Стрелочные функции**  
Не получают ключевое слово this.  
Вместо этого если мы используем ключевое слово this в стрелочных функции,  
она будет просто ключевым словом this внешней функции, то есть родительской функции,  
либо на объект window если данная стрелочная функция не является дочерней функции.

**4 - Обработчики событий**  
Если функция вызывается как обработчик события, то ключевое слово this  
всегда будет указывать на элемент DOM к которому прикреплена функция обработчика.

Чем не является ключевое слово this?  
Она никогда не будет указывает на функцию в котором мы его используем,  
и никогда не будет указывать на переменных в которых хранится функция.

---

## ПРАКТИКА С КЛЮЧЕВЫМ СЛОВОМ THIS

Ключевое слово this в глобальной области видимости,  
это просто объект window.  
Пример:

```javascript
console.log(this); // result / window
```

Ключевое слово this внутри обычной функции (без привязки к какому либо объекту):

```javascript
const calcAge = function (birthYear) {
  console.log(2037 - birthYear);
  console.log(this);
};
calcAge(1991); // result / 46, undefined(строгий режим) window(не строгий режим)
```

Ключевое слово this внутри стрелочной функции:

```javascript
const calcAgeArrow = (birthYear) => {
  console.log(2037 - birthYear);
  console.log(this); // здесь он указывает на родительский область видимости
};
calcAgeArrow(1980); // result / 57, window
```

Ключевое слово this внутри Method:

```javascript
const jonas = {
  year: 1991,
  calcAge: function () {
    console.log(this);
    console.log(2037 - this.year);
  },
};
jonas.calcAge(); // result / (объект) jonas, 46
```

На самом деле в этом примере ключевое слово this не указывает на объект jonas просто тупо без причины.  
Причина по которой ключевое слово this указывает на объект jonas в этом случае,  
заключается в том, что сам объект jonas вызвал этот метод calcAge().  
Вот так: jonas.calcAge();

Пример для этого:

```javascript
const matilda = {
  year: 2017,
};
matilda.calcAge = jonas.calcAge;
matilda.calcAge(); // result / 20
```

Здесь мы присвоили метод объекта jonas на другой метод объекта matilda.  
И мы видим что ключевое слово this указывает на объект matilda и свойству данного объекта year.  
То есть вот так: 2037 - this.year (matilda.year) (2037 - 2017 = 20).

---

## ПОДВОДНЫЕ КАМНИ THIS С ФУНКЦИЯМИ

```javascript
const jonas = {
  firstName: "Jonas",
  year: 1991,
  calcAge: function () {
    console.log(this);
    console.log(2037 - this.year);
  },

  greet: () => console.log(`Hey ${this.firstName}`),
};
jonas.greet(); // result / Hey undefined
```

Здесь мы видим что ключевое слово this внутри стрелочной функции  
указывает на родительский область видимости window.  
То есть вот так: window.firstName;  
Так как в родительском объекте window нет свойство firstName, мы видим значение undefined.  
А объект это не область видимости это не блок кода, по этому все что  
находится внутри объекта по прежнему находится в глобальном масштабе.  
А ключевое слово this в глобальном масштабе указывает на объект window.

Так вот, если мы объявим переменную с помощью var с именем firstName в глобальном области видимости,  
то он добавить свойство firstName в глобальном объекте window.  
И тогда ключевое слово this внутри стрелочной функции будет указывать на свойство firstName,  
который мы создали с помощью var.  
По этому лучшего всего не использовать стрелочную функцию в качестве метода внутри объекта.

Еще одна ошибка который может быть, при использовании ключевое слово this внутри функции:

```javascript
const jonas = {
  firstName: "Jonas",
  year: 1991,
  calcAge: function () {
    console.log(this);
    console.log(2037 - this.year);

    const isMillenial = function () {
      console.log(this);
      console.log(this.year >= 1981 && this.year <= 1996);
    };
    isMillenial();
  },

  greet: () => console.log(`Hey ${this.firstName}`),
};
jonas.calcAge(); // result / Undefined, Cannot read property 'year' of undefined
```

Здесь я создал функцию isMillenial() внутри функции calcAge(),  
и когда я попытался получить доступ к свойству year объекта jonas внутри функции isMillenial(),  
мы видим что в консоле выдает ошибку undefined.  
Потому что данная функция isMillenial() ни к чему не закреплена,  
так как данная функция находится внутри функции calcAge().  
Мы знаем что обычная функция которая не привязана к какому либо объекту,  
при использовании ключевое слово this внутри него, программа выдает ошибку undefined для this.  
Это тоже самое что и пример выше который я привел.

Как это можно исправить ?  
**1 - Способ**  
Для этого мы создаем переменную вне области видимости функции isMillenial(),  
то есть объявляем перемнную в родительской функции calcAge() со значением this.  
Потому что функция calcAge() имеет доступ к объекту jonas с помощью this,  
так как данная функция calcAge() привязана к объекту jonas.

```javascript
const jonas = {
  firstName: "Jonas",
  year: 1991,
  calcAge: function () {
    console.log(this);
    console.log(2037 - this.year);

    const self = this;
    const isMillenial = function () {
      console.log(self);
      console.log(self.year >= 1981 && self.year <= 1996);
    };
    isMillenial();
  },

  greet: () => console.log(`Hey ${this.firstName}`),
};
jonas.calcAge(); // result / true
```

Здесь я создал переменную self вне области видимости функции isMillenial(),  
и присвоил ему значение this.  
Потом данную переменную self использовал внутри функции isMillenial(),  
чтобы получить доступ к свойству year объекта jonas.

**2 - Способ:**  
Более современное в ES6.  
Это решение использовать стрелочную функцию.  
Как мы знаем что у стрелочных функции нет ключевое слово this,  
вместо этого стрелочная функция обращается к this родительской области видимости.  
В данном случае родительская область видимости данной стрелочной функции будет calcAge(),  
а ключевое слово this родительской функции calcAge() будет объект jonas,  
так как calcAge() привязан к объекту jonas.

```javascript
const jonas = {
  firstName: "Jonas",
  year: 1991,
  calcAge: function () {
    console.log(this);
    console.log(2037 - this.year);

    const isMillenial = () => {
      console.log(this);
      console.log(this.year >= 1981 && this.year <= 1996);
    };
    isMillenial();
  },

  greet: () => console.log(`Hey ${this.firstName}`),
};
jonas.calcAge(); // result / true
```

Мы видим что стрелочная функция isMillenial() использует ключевое слово this  
родительской области видимости, а родительская область видимости это функция calcAge().  
То есть стрелочная функция наследует ключевое слово this из родительской области видимости.

```

```
