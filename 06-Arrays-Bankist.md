## МЕТОДЫ ДЛЯ МАССИВОВ

Почему у массивов есть методы ?
Методы - это просто функции которые мы можем вызывать у объектов.
По сути это функции прикрепленные к объектом.
Если у нас есть методы для работы с массивами, значит и массивы это тоже объекты.

Давайте начнем с простого массива:

```javascript
let arr = ["a", "b", "c", "d", "e"];
```

Первый метод это slice():
Он очень похож на метод slice() который есть у строк.
С помощью метода slice() мы можем извлечь часть любого массива,
не меняя исходный массив.
Метод slice() вернет новый массив.
Пример:

```javascript
console.log(arr.slice(2)); // result / >(3)["c", "d", "e"]
```

Начиная с индекса 2 извлекается остальную часть массива.

Конечно мы можем указать второй параметр для метода slice():

```javascript
console.log(arr.slice(2, 4)); // result / >(2)["c", "d"]
```

Начиная с индекса 2 и до индекса 4, извлекается часть массива.
И мы видим что элемент с индексом 4 не извлекается из массива.
Значит от 2 до 4, это только второй и третий элемент.

Также мы можем указать отрицательные параметры для метода slice():
И тогда копирование начнется с конца массива.

```javascript
console.log(arr.slice(-2)); // result / >(2)["d", "e"]
```

Извлекли последние два элемента из массива.

Еще пример:

```javascript
console.log(arr.slice(1, -2)); // result / >(2)["b", "c"]
```

Копирование начинается с индекса 1 и извлекается все, кроме последних двух элементов.

Теперь мы можем использовать метод slice() для создания не глубокую копию массива:
Для этого вызываем метод slice() не указывая никаких аргументов.
Пример:

```javascript
console.log(arr.slice()); // result / >(5)['a', 'b', 'c', 'd', 'e']
```

Теперь мы создали точную копию массива arr.

Второй метод это splice():
Он работает почти также как и метод slice().
Но главное отличие в том, что он изменяет исходный массив.
Пример:

```javascript
console.log(arr.splice(2)); // result / >(3)["c", "d", "e"]
```

Результат здесь выглядит точно также и как в методе slice(2),
но наш исходный массив arr изменился.
Пример:

```javascript
console.log(arr); // result / >(2)["a", "b"]
```

Мы видим что в нашем исходном массиве arr, остались только первые два элемента.
А извлеченные элементы с помощью метода splice(), они исчезли из исходного массива arr.
Таким образом метод splice() удалил их из исходного массива arr.

Второй аргумент для метода splice():

```javascript
console.log(arr); // result / >(5)['a', 'b', 'c', 'd', 'e']
console.log(arr.splice(1, 2)); // result / >()["b, "c"]
```

Извлекли из исходно массива два элемента с индексами 1 и 2.
Исходный массив изменился:

```javascript
console.log(arr); // result / >(3)['a', 'd', 'e']
```

Третий метод это reverse():

```javascript
const arr2 = ["j", "i", "h", "g", "f"];
console.log(arr2.reverse()); // result / >(5)['f', 'g', 'h', 'i', 'j']
```

Теперь мы видим что метод reverse() вернул массив в обратном порядке.
И данный метод reverse() тоже меняет исходный массив:

```javascript
console.log(arr2); // result / >(5)['f', 'g', 'h', 'i', 'j']
```

Исходный массив тоже у нас изменился на обратный порядок элементов.

Четвертый метод это concat():
Он используется для объединения двух массивов.

```javascript
let arr = ["a", "b", "c", "d", "e"];
const arr2 = ["f", "g", "h", "i", "j"];
const letters = arr.concat(arr2);
console.log(letters); // result / >(10)['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
```

Теперь мы видим что объеденились два массива arr и arr2.
Первый массив arr - это тот к которому применяется метод concat().
Второй массив arr2 - это тот который мы передаем в метод concat().
Метод concat() не изменяет исходные массивы arr и arr2.

Пятый метод это join():
Данный метод объединяет все элементы массива в одну строку.
Пример:

```javascript
console.log(letters.join(" - ")); // result / a - b - c - d - e - f - g - h - i - j
```

Внутри метода join() мы добавляем тот аргумент, который мы хотим чтобы добавилось в строку.

// --------------------------------------------------------------------------------- //

## НОВЫЙ МЕТОД В ES2022 ДЛЯ МАССИВОВ

Метод добавление at():
Обычно когда мы хотим получить какой то элемент из массива,
пишем вот так:

```javascript
const arr = [23, 11, 64];
console.log(arr[0]); // result / 23
```

Теперь мы можем сделать то же самое с помощью метода at():

```javascript
console.log(arr.at(0)); // result / 23
```

На самом деле в методе добавление at() есть одна особенность,
который делает его весьма полезным для использования вместо обычных квадратных скобок.
Давайте теперь предположим, что мы хотим получить последний элемент из массива,
а теперь предположим что мы незнаем длину массива.
Для этого обычно без метода at() мы бы написали вот так:

```javascript
console.log(arr[arr.length - 1]); // result / 64
```

Еще есть еще один способ получить последний элемент из массива с помощью метода slice():
Таким образом мы получим копию массива, только с последним элементом.

```javascript
console.log(arr.slice(-1)); // result / >(1)[64]
```

И из этого массива >(1)[64] мы хотим получить этот один элемент:

```javascript
console.log(arr.slice(-1)[0]); // result / 64
```

И так, это два традиционных способов для получения
последнего элемента из массива без метода at().
Но метод at() делает этот процесс еще проще:
Для этого мы напишем отрицательный параметр как и в slice():

```javascript
console.log(arr.at(-1)); // result / 64
```

Также метод at() работает и со строками:

```javascript
console.log("Jonas".at(0)); // result / J
```

// --------------------------------------------------------------------------------- //

## ПЕРЕБОР МАССИВОВ С ПОМОЩЬЮ МЕТОДА FOREACH

Основные особенности forEach()
Синтаксис:

```javascript
array.forEach(callback(element, index, array), thisArg);
```

callback: Функция, выполняемая для каждого элемента массива.
Она принимает три аргумента:
element: текущий элемент массива.
index (необязательно): индекс текущего элемента.
array (необязательно): сам массив, по которому идет перебор.
thisArg (необязательно): значение, используемое как this внутри функции callback.

Возвращаемое значение:
forEach() ничего не возвращает.
Он используется исключительно для выполнения побочных действий.

Не останавливается:
В отличие от циклов (for, for...of), forEach() нельзя принудительно прервать с помощью break или return.
Примеры использования forEach():

1. Простая итерация по массиву

```javascript
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((number) => {
  console.log(number);
}); // Вывод: 1 2 3 4 5
```

2. Использование индекса

```javascript
const fruits = ['apple', 'banana', 'cherry'];
fruits.forEach((fruit, index) => {
  console.log(`${index}: ${fruit}`);
}); // Вывод: 0: apple
           1: banana
           2: cherry
```

3. Использование третьего аргумента (массив)

```javascript
const colors = ['red', 'green', 'blue'];
colors.forEach((color, index, array) => {
  console.log(`Color: ${color}, Original Array: ${array}`);
}); // Вывод: Color: red, Original Array: red,green,blue
           Color: green, Original Array: red,green,blue
           Color: blue, Original Array: red,green,blue
```

4. Изменение внешних данных

```javascript
const numbers = [1, 2, 3, 4, 5];
let sum = 0;
numbers.forEach((number) => {
  sum += number;
});
console.log(sum); // 15
```

Особенности и ограничения forEach()
Невозможность прерывания:
Если нужно выйти из цикла раньше времени, лучше использовать for или for...of.

```javascript
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((number) => {
  if (number > 3) return; // НЕ работает как "break"
  console.log(number);
});
// Вывод: 1
2;
3;
4;
5;
```

Работа с thisArg: Если требуется контекст, можно передать его как второй аргумент.

```javascript
const obj = {
  multiplier: 2,
  multiply(numbers) {
    numbers.forEach(function (num) {
      console.log(num * this.multiplier); // `this` из объекта obj
    }, this);
  },
};
obj.multiply([1, 2, 3]); // 2, 4, 6
```

Изменение массива внутри forEach():
Если модифицировать массив в процессе работы, это может повлиять на результаты итерации.

```javascript
const numbers = [1, 2, 3];
numbers.forEach((num, index, array) => {
  array[index] = num * 2;
});
console.log(numbers); // [2, 4, 6]
```

Работа с пустыми элементами:
forEach() пропускает пустые ячейки массива:

```javascript
const arr = [1, , 3]; // массив с "дырой" (пустой ячейкой)
arr.forEach((x) => console.log(x)); // 1, 3
```

// --------------------------------------------------------------------------------- //

## МЕТОД FOREACH ДЛЯ MAP И SET

forEach() для Map:
Коллекция Map представляет собой набор пар "ключ-значение".
Метод forEach() позволяет выполнить функцию для каждой такой пары.

Синтаксис:

```javascript
map.forEach(callback(value, key, map), thisArg);
```

callback: Функция, выполняемая для каждой пары "ключ-значение".
Аргументы:
value: значение текущей пары.
key: ключ текущей пары.
map: объект Map, по которому происходит итерация.
thisArg (опционально): значение, используемое как this внутри функции callback.
Примеры:

1. Простой пример:

```javascript
const map = new Map([
  ["name", "Alice"],
  ["age", 30],
  ["job", "Engineer"],
]);

map.forEach((value, key) => {
  console.log(`Key: ${key}, Value: ${value}`);
});
// Вывод:
// Key: name, Value: Alice
// Key: age, Value: 30
// Key: job, Value: Engineer
```

2. Использование thisArg:

```javascript
const map = new Map([
  ["a", 1],
  ["b", 2],
]);

const multiplier = {
  factor: 10,
};

map.forEach(function (value, key) {
  console.log(`${key}: ${value * this.factor}`);
}, multiplier);
// Вывод:
// a: 10
// b: 20
```

3. Обход и изменение внешнего объекта:

```javascript
const map = new Map([
  [1, 10],
  [2, 20],
  [3, 30],
]);

let sum = 0;

map.forEach((value) => {
  sum += value;
});
console.log(`Sum: ${sum}`); // Sum: 60
```

forEach() для Set:
Коллекция Set представляет собой набор уникальных значений.
Метод forEach() выполняет функцию для каждого значения.

Синтаксис:

```javascript
set.forEach(callback(value, value2, set), thisArg);
```

callback: Функция, выполняемая для каждого значения.
Аргументы:
value: текущее значение (используется дважды, так как Set не имеет ключей).
value2: дублирует первое значение.
set: объект Set, по которому идет итерация.
thisArg (опционально): значение, используемое как this внутри функции callback.

Примеры:

1. Простой пример:

```javascript
const set = new Set([1, 2, 3, 4]);

set.forEach((value) => {
  console.log(`Value: ${value}`);
});
// Вывод:
// Value: 1
// Value: 2
// Value: 3
// Value: 4
```

2. Использование thisArg:

```javascript
const set = new Set([2, 4, 6]);

const multiplier = {
  factor: 2,
};

set.forEach(function (value) {
  console.log(value * this.factor);
}, multiplier);
// Вывод:
// 4
// 8
// 12
```

3. Суммирование элементов:

```javascript
const set = new Set([5, 10, 15]);
let sum = 0;

set.forEach((value) => {
  sum += value;
});
console.log(`Sum: ${sum}`); // Sum: 30
```

Когда использовать forEach() в Map и Set?
Для Map:
Когда нужно обрабатывать пары "ключ-значение".
Например, при генерации строки из всех значений:

```javascript
const map = new Map([
  ["a", 1],
  ["b", 2],
]);

let result = "";
map.forEach((value, key) => {
  result += `${key}:${value} `;
});
console.log(result.trim()); // "a:1 b:2"
```

Для Set:
Когда нужно обработать уникальные значения.
Например, фильтрация или подсчет:

```javascript
const set = new Set([1, 2, 2, 3]);

set.forEach((value) => {
  console.log(value * 2);
});
// 2, 4, 6
```

Итог
forEach() в Map и Set используется для обработки их элементов.
Отличие в том, что:
В Map можно работать с ключами и значениями.
В Set обрабатываются только значения.

// --------------------------------------------------------------------------------- //

## МЕТОД INSERTADJACENTHTML

Метод insertAdjacentHTML позволяет вставить строку HTML в определённое место
относительно существующего элемента. Этот метод полезен, когда вы хотите добавить HTML-код
в документ без перезаписи содержимого элемента (в отличие от innerHTML).

Синтаксис:

```javascript
element.insertAdjacentHTML(position, text);
```

position: указывает место, где будет вставлен HTML. Возможные значения:
beforebegin
afterbegin
beforeend
afterend
text: строка HTML, которую вы хотите вставить.

Аргументы position с примерами:

1. beforebegin
   Вставляет HTML перед самим элементом (вне элемента).

Исходный HTML:

```html
<div class="example"></div>
```

javascript:

```javascript
const element = document.querySelector(".example");
element.insertAdjacentHTML("beforebegin", "<p>New</p>");
```

Результат:

```html
<p>New</p>
<div class="example"></div>
```

2. afterbegin
   Вставляет HTML внутрь элемента, сразу после его открывающего тега.

Исходный HTML:

```html
<div class="example"></div>
```

javascript:

```javascript
const element = document.querySelector(".example");
element.insertAdjacentHTML("afterbegin", "<p>New</p>");
```

Результат:

```html
<div class="example">
  <p>New</p>
</div>
```

3. beforeend
   Вставляет HTML внутрь элемента, сразу перед его закрывающим тегом.

Исходный HTML:

```html
<div class="example"></div>
```

javascript:

```javascript
const element = document.querySelector(".example");
element.insertAdjacentHTML("beforeend", "<p>New</p>");
```

Результат:

```html
<div class="example">
  <p>New</p>
</div>
```

4. afterend
   Вставляет HTML после элемента (вне элемента).

Исходный HTML:

```html
<div class="example"></div>
```

javascript:

```javascript
const element = document.querySelector(".example");
element.insertAdjacentHTML("afterend", "<p>New</p>");
```

Результат:

```html
<div class="example"></div>
<p>New</p>
```

Сравнение использования аргументов:
Пример кода:
html:

```html
<div class="example">Hello</div>
```

javascript:

```javascript
const element = document.querySelector(".example");

// beforebegin
element.insertAdjacentHTML("beforebegin", "<p>1. Before Begin</p>");

// afterbegin
element.insertAdjacentHTML("afterbegin", "<p>2. After Begin</p>");

// beforeend
element.insertAdjacentHTML("beforeend", "<p>3. Before End</p>");

// afterend
element.insertAdjacentHTML("afterend", "<p>4. After End</p>");
```

Результат:
html

```html
<p>1. Before Begin</p>
<div class="example">
  <p>2. After Begin</p>
  Hello
  <p>3. Before End</p>
</div>
<p>4. After End</p>
```

Почему это удобно:
Избегает перезаписи содержимого элемента. В отличие от innerHTML,
метод insertAdjacentHTML позволяет добавлять новый HTML-код,
не удаляя или перезаписывая уже существующий.

Гибкость расположения:
Можно легко выбрать место для вставки (до или после элемента, или внутрь).

Сравнение с innerHTML и insertAdjacentHTML:
innerHTML полностью перезаписывает содержимое элемента.
insertAdjacentHTML добавляет новый HTML, сохраняя существующее содержимое.
Пример:

javascript:

```javascript
const element = document.querySelector(".example");

// innerHTML (перезаписывает)
element.innerHTML = "<p>New Content</p>";

// insertAdjacentHTML (добавляет)
element.insertAdjacentHTML("afterbegin", "<p>New Content</p>");
```

// --------------------------------------------------------------------------------- //

## МЕТОД MAP ДЛЯ МАССИВОВ

Метод map()
Основное назначение: Создать новый массив, в котором каждый элемент является результатом
выполнения функции-обратного вызова на соответствующем элементе исходного массива.
Возвращаемое значение: Новый массив с преобразованными элементами.
Изменяет ли исходный массив:
Нет, исходный массив остаётся неизменным.

Синтаксис:

```javascript
const newArray = array.map((element, index, array) => {
  // return новое значение для нового массива
});
```

Пример:

```javascript
const numbers = [1, 2, 3, 4];
const squared = numbers.map((num) => num * num);
console.log(squared); // [1, 4, 9, 16]
console.log(numbers); // [1, 2, 3, 4] — исходный массив не изменился
```

Метод forEach():
Основное назначение:
Выполняет функцию-обработчик для каждого элемента массива, но ничего не возвращает.
Возвращаемое значение: undefined.
Изменяет ли исходный массив:
Может, если явно изменять его внутри функции-обратного вызова.

Синтаксис:

```javascript
array.forEach((element, index, array) => {
  // выполняем действие с элементом
});
```

Пример:

```javascript
const numbers = [1, 2, 3, 4];
numbers.forEach((num) => console.log(num * num)); // Выведет: 1, 4, 9, 16
console.log(numbers); // [1, 2, 3, 4] — исходный массив не изменился
```

Когда что использовать?
Используйте map(), если вам нужен новый массив на основе изменений исходного массива.
Используйте forEach(), если вам нужно просто выполнить какие-либо действия с элементами массива,
например, вывести их в консоль, обновить внешний объект и т.д.
Пример для сравнения:

```javascript
const numbers = [1, 2, 3, 4];

// Используем map, чтобы создать новый массив
const doubled = numbers.map((num) => num * 2);
console.log(doubled); // [2, 4, 6, 8]

// Используем forEach, чтобы выполнить действие (например, вывести в консоль)
numbers.forEach((num) => console.log(num * 2)); // Выводит: 2, 4, 6, 8
```

// --------------------------------------------------------------------------------- //

## ПРАКТИКА С МЕТОДОМ MAP()

```javascript
const user = "Steven Thomas Williams";
const username = user
  .toLowerCase()
  .split(" ")
  .map(function (name) {
    return name[0];
  });
console.log(username); // result / >(3)["s", "t", "w"]
```

Здесь мы видим что метод map() вернул новый массив с первыми буквами у каждого слово.

```javascript
const username = user
  .toLowerCase()
  .split(" ")
  .map(function (name) {
    return name[0];
  })
  .join("");
console.log(username); // result / stw
```

Мы можем написать тоже самое но более коротким способом:

```javascript
const username = user
  .toLowerCase()
  .split(" ")
  .map((name) => name[0])
  .join("");
console.log(username); // result / stw
```

// --------------------------------------------------------------------------------- //

## МЕТОД FILTER ДЛЯ МАССИВОВ

Назначение:
Метод filter() создаёт новый массив, включающий только те элементы исходного массива,
которые соответствуют условию, заданному в функции-обратного вызова.

Характеристики:
Возвращаемое значение: Новый массив, содержащий элементы, которые прошли проверку.
Изменяет исходный массив: Нет.
Параметры обработчика:
element — текущий элемент массива.
index — индекс текущего элемента (необязательно).
array — исходный массив (необязательно).

Синтаксис:

```javascript
const filteredArray = array.filter((element, index, array) => {
  return /* условие, возвращающее true или false */;
});
```

Примеры:
Фильтрация чисел больше 5:

```javascript
const numbers = [1, 6, 3, 8, 4, 10];
const greaterThanFive = numbers.filter((num) => num > 5);
console.log(greaterThanFive); // [6, 8, 10]
console.log(numbers); // [1, 6, 3, 8, 4, 10] — исходный массив не изменился
```

Фильтрация строк по длине:
// выводи тот элемент у которого длина строк больше пяти

```javascript
const words = ["apple", "banana", "kiwi", "cherry"];
const longWords = words.filter((word) => word.length > 5);
console.log(longWords); // ['banana', 'cherry']
```

Фильтрация объектов в массиве:

Фильтрация объектов в массиве:
Выводи тот объект у которого логическое значения является истинным.

```javascript
const users = [
  { id: 1, name: "Alice", isActive: true },
  { id: 2, name: "Bob", isActive: false },
  { id: 3, name: "Charlie", isActive: true },
];
const activeUsers = users.filter((user) => user.isActive);
console.log(activeUsers);
// [
//   { id: 1, name: 'Alice', isActive: true },
//   { id: 3, name: 'Charlie', isActive: true }
// ]
```

Фильтрация уникальных значений (с дополнительной проверкой):
Выводи те элементы, которые совпадают с индексоми.

```javascript
const numbers = [1, 2, 3, 2, 4, 3, 5];
const uniqueNumbers = numbers.filter(
  (num, index, arr) => arr.indexOf(num) === index
);
console.log(uniqueNumbers); // [1, 2, 3, 4, 5]
```

Как работает метод filter()?
Для каждого элемента массива выполняется функция-обратного вызова.
Если обработчик возвращает true, элемент включается в новый массив.
Если обработчик возвращает false, элемент игнорируется.
Новый массив создаётся на основе только тех элементов, которые прошли проверку.

// --------------------------------------------------------------------------------- //

## МЕТОД REDUCE ДЛЯ МАССИВОВ

Подробное объяснение метода reduce() с разбором примеров для новичков:
Метод reduce() применяется для обработки массива и преобразования его элементов в одно итоговое значение.

Вот полный разбор каждого примера:

1. Сумма всех элементов массива
   Код:

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15
```

Как это работает:
reduce() принимает два аргумента:

Функцию (acc, num) => acc + num.
Начальное значение acc равно 0 (это то, с чего начинаются вычисления).

Процесс вычисления:

Первая итерация: acc = 0, num = 1 → acc = 0 + 1 = 1.
Вторая итерация: acc = 1, num = 2 → acc = 1 + 2 = 3.
Третья итерация: acc = 3, num = 3 → acc = 3 + 3 = 6.
Четвёртая итерация: acc = 6, num = 4 → acc = 6 + 4 = 10.
Пятая итерация: acc = 10, num = 5 → acc = 10 + 5 = 15.

Итог:
После последней итерации reduce() возвращает итоговое значение 15.

2. Произведение всех элементов массива
   Код:

```javascript
const numbers = [1, 2, 3, 4];
const product = numbers.reduce((acc, num) => acc * num, 1);
console.log(product); // 24
```

Как это работает:
Начальное значение acc равно 1.

Процесс умножения:
Первая итерация: acc = 1, num = 1 → acc = 1 _ 1 = 1.
Вторая итерация: acc = 1, num = 2 → acc = 1 _ 2 = 2.
Третья итерация: acc = 2, num = 3 → acc = 2 _ 3 = 6.
Четвёртая итерация: acc = 6, num = 4 → acc = 6 _ 4 = 24.
Итог: Возвращается произведение всех чисел — 24.

3. Преобразование массива объектов в объект
   Код:

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const userMap = users.reduce((acc, user) => {
  acc[user.id] = user.name;
  return acc;
}, {});

console.log(userMap); // { 1: 'Alice', 2: 'Bob', 3: 'Charlie' }
```

Как это работает:
Начальное значение acc — пустой объект {}.

На каждой итерации добавляем в acc новую пару ключ-значение:
Ключ — это user.id.
Значение — это user.name.

Процесс:
Первая итерация: acc = {}, user = { id: 1, name: 'Alice' } → Добавляем 1: 'Alice'.
Вторая итерация: acc = { 1: 'Alice' }, user = { id: 2, name: 'Bob' } → Добавляем 2: 'Bob'.
Третья итерация: acc = { 1: 'Alice', 2: 'Bob' }, user = { id: 3, name: 'Charlie' } → Добавляем 3: 'Charlie'.
Итог: Объект { 1: 'Alice', 2: 'Bob', 3: 'Charlie' }.

4 - Подробное объяснение примера подсчёта количества элементов в массиве:
Код:

```javascript
const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];

const count = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});

console.log(count); // { apple: 3, banana: 2, orange: 1 }
```

1. Что делает код?
   Цель — посчитать, сколько раз каждый фрукт встречается в массиве fruits,
   и сохранить результаты в объекте.
   Каждому фрукту ставится в соответствие количество его повторений в массиве.

2. Что такое reduce() в этом коде?
   acc (аккумулятор) — это объект, в который мы записываем счётчики фруктов. Он начинается с пустого объекта {}.
   fruit (текущий элемент) — это текущий фрукт из массива fruits, который обрабатывается на каждой итерации.

3. Как работает код на каждой итерации?
   Давайте разберём шаг за шагом.
   Начало работы
   Начальное значение аккумулятора: acc = {};

Итерация 1
Текущий фрукт: 'apple'.
Проверяем, есть ли apple в объекте acc:
Так как acc пустой, ключа 'apple' ещё нет.
Логика:
acc['apple'] = (acc['apple'] || 0) + 1;
acc['apple'] || 0 → undefined || 0 → 0.
0 + 1 → 1.

Обновляем acc:
acc = { apple: 1 };

Итерация 2
Текущий фрукт: 'banana'.
Проверяем, есть ли banana в acc:
banana ещё нет.
Логика:
acc['banana'] = (acc['banana'] || 0) + 1;
acc['banana'] || 0 → undefined || 0 → 0.
0 + 1 → 1.

Обновляем acc:
acc = { apple: 1, banana: 1 };

Итерация 3
Текущий фрукт: 'apple'.
Проверяем, есть ли apple в acc:
apple уже есть, и его значение равно 1.
Логика:
acc['apple'] = (acc['apple'] || 0) + 1;
acc['apple'] || 0 → 1 || 0 → 1.
1 + 1 → 2.

Обновляем acc:
acc = { apple: 2, banana: 1 };

Итерация 4
Текущий фрукт: 'orange'.
Проверяем, есть ли orange в acc:
orange ещё нет.
Логика:
acc['orange'] = (acc['orange'] || 0) + 1;
acc['orange'] || 0 → undefined || 0 → 0.
0 + 1 → 1.

Обновляем acc:
acc = { apple: 2, banana: 1, orange: 1 };

Итерация 5
Текущий фрукт: 'banana'.
Проверяем, есть ли banana в acc:
banana уже есть, и его значение равно 1.
Логика:
acc['banana'] = (acc['banana'] || 0) + 1;
acc['banana'] || 0 → 1 || 0 → 1.
1 + 1 → 2.

Обновляем acc:
acc = { apple: 2, banana: 2, orange: 1 };

Итерация 6
Текущий фрукт: 'apple'.
Проверяем, есть ли apple в acc:
apple уже есть, и его значение равно 2.
Логика:
acc['apple'] = (acc['apple'] || 0) + 1;
acc['apple'] || 0 → 2 || 0 → 2.
2 + 1 → 3.

Обновляем acc:
acc = { apple: 3, banana: 2, orange: 1 };

4. Итоговое значение
   После всех итераций reduce() возвращает объект:
   { apple: 3, banana: 2, orange: 1 }

Объяснение ключевых частей:
(acc[fruit] || 0) + 1:
Если фрукт уже есть в объекте acc, используем его текущее значение.
Если фрукта нет, используем значение 0 (так как undefined || 0 → 0).
После этого прибавляем 1, чтобы увеличить счётчик.

return acc:
На каждой итерации возвращаем обновлённый объект acc.

Начальное значение {}:
Указываем пустой объект как начальное значение,
чтобы на первой итерации у нас был доступен аккумулятор.

Для чего это полезно?
Этот подход универсален и может быть использован:
Для подсчёта частоты слов в тексте.
Для анализа данных (например, количества товаров или пользователей).
Для построения статистики.

5. Объединение вложенных массивов
   Код:

```javascript
const arrays = [
  [1, 2],
  [3, 4],
  [5, 6],
];

const flattened = arrays.reduce((acc, arr) => acc.concat(arr), []);
console.log(flattened); // [1, 2, 3, 4, 5, 6]
```

Как это работает:
Начальное значение acc — пустой массив [].
На каждой итерации добавляем текущий массив arr в аккумулятор с помощью concat().

Процесс:

Первая итерация: acc = [], arr = [1, 2] → acc = [1, 2].
Вторая итерация: acc = [1, 2], arr = [3, 4] → acc = [1, 2, 3, 4].
Третья итерация: acc = [1, 2, 3, 4], arr = [5, 6] → acc = [1, 2, 3, 4, 5, 6].
Итог: Новый массив [1, 2, 3, 4, 5, 6].

// --------------------------------------------------------------------------------- //

## ОБЪЕДИНЕНИЕ ВСЕХ МЕТОДОВ (MAP, FILTER, REDUCE) В ЦЕПОЧКУ:

//Давайте создадим элементы в еврах:

```javascript
const movements = [10, -35, 50, 100, 800];

//Цена евро - это 1.1 долларов:
const eurToUsd = 1.1;

//Конвертация евро в доллары:
const totalDepositsUSD = movements
  .filter((mov) => mov > 0)
  .map((mov) => mov * eurToUsd)
  .reduce((acc, mov) => acc + mov, 0);
console.log(totalDepositsUSD); // result / 1056usd
```

// --------------------------------------------------------------------------------- //

## МЕТОД FIND ДЛЯ МАССИВОВ

Метод find() используется для поиска первого элемента массива,
который удовлетворяет условию, заданному функцией-обратного вызова.
Если элемент найден, метод возвращает этот элемент.
Если нет, возвращается undefined.

Синтаксис:

```javascript
array.find(function(element, index, array), thisArg);
```

callback — функция, которая вызывается для каждого элемента массива.
Она возвращает true, если элемент удовлетворяет условию, или false, если нет.
element — текущий элемент массива.
index (опционально) — индекс текущего элемента.
array (опционально) — сам массив.
thisArg (опционально) — значение, используемое как this внутри callback.

Примеры работы find():

1. Поиск первого чётного числа

```javascript
const numbers = [1, 3, 7, 8, 9, 10];

const firstEven = numbers.find((num) => num % 2 === 0);
console.log(firstEven); // 8
```

Как это работает:
Метод начинает с первого элемента массива.
Проверяет: 1 % 2 === 0 → false.
Переходит ко второму элементу: 3 % 2 === 0 → false.
Третий элемент: 7 % 2 === 0 → false.
Четвёртый элемент: 8 % 2 === 0 → true. Возвращается 8.

2. Поиск объекта по значению свойства

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const user = users.find((user) => user.name === "Bob");
console.log(user); // { id: 2, name: 'Bob' }
```

Как это работает:

Проверяет первый объект: { id: 1, name: 'Alice' } → name === 'Bob' → false.
Проверяет второй объект: { id: 2, name: 'Bob' } → name === 'Bob' → true.
Возвращается этот объект.

3. Поиск с использованием индекса

```javascript
const numbers = [5, 12, 8, 130, 44];

const foundIndex = numbers.find((num, index) => index > 2 && num > 10);
console.log(foundIndex); // 130
```

Как это работает:
Проверяет первые три элемента (индексы 0, 1, 2) и игнорирует их, потому что index > 2 не выполняется.
На четвёртом элементе (индекс 3): 130 > 10 → true. Возвращается 130.

Что возвращает метод find()?
Элемент массива, если найден.
undefined, если ни один элемент не удовлетворяет условию.

Пример:

```javascript
const numbers = [1, 3, 5];
const result = numbers.find((num) => num > 10);
console.log(result); // undefined
```

Отличие find() от filter():
Метод find():
Возвращает только первый элемент, который удовлетворяет условию.
Если ничего не найдено, возвращает undefined.

Пример:

```javascript
const numbers = [1, 3, 7, 8, 10];
const result = numbers.find((num) => num > 5);
console.log(result); // 7 (первый подходящий элемент)
```

Метод filter():
Возвращает все элементы, которые удовлетворяют условию, в виде нового массива.
Если ничего не найдено, возвращает пустой массив [].

Пример:

```javascript
const numbers = [1, 3, 7, 8, 10];
const result = numbers.filter((num) => num > 5);
console.log(result); // [7, 8, 10] (все подходящие элементы)
```

Сравнение find() и filter() на одном примере:

```javascript
const numbers = [1, 3, 7, 8, 10];

// Используем find()
const findResult = numbers.find((num) => num > 5);
console.log(findResult); // 7 (первый элемент > 5)

// Используем filter()
const filterResult = numbers.filter((num) => num > 5);
console.log(filterResult); // [7, 8, 10] (все элементы > 5)
```

Когда использовать?

Используйте find(), если нужен только первый подходящий элемент.
Используйте filter(), если нужны все подходящие элементы.

Подводим итог:
find() ищет первый подходящий элемент.
filter() ищет все подходящие элементы.

Если ничего не найдено:
find() возвращает undefined.
filter() возвращает пустой массив [].

// --------------------------------------------------------------------------------- //

## МЕТОД FINDINDEX ДЛЯ МАССИВОВ

Метод findIndex() используется для нахождения индекса первого элемента массива,
который удовлетворяет заданному условию (переданному в виде функции-обратного вызова).
Если элемент найден, возвращается его индекс. Если нет, метод возвращает -1.

Синтаксис:

```javascript
array.findIndex(function(element, index, array), thisArg);
```

callback — функция, которая выполняется для каждого элемента массива.
Она должна возвращать:
true, если элемент соответствует условию;
false, если не соответствует.

Параметры функции:
element — текущий элемент массива.
index (опционально) — индекс текущего элемента.
array (опционально) — сам массив.
thisArg (опционально) — значение, которое будет использоваться как this внутри функции.

Пример работы findIndex():

1. Поиск индекса объекта по значению свойства

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const index = users.findIndex((user) => user.name === "Bob");
console.log(index); // 1
```

Как это работает:

Перебирает объекты:
Проверяет: { id: 1, name: 'Alice' } → name === 'Bob' → false.
Проверяет: { id: 2, name: 'Bob' } → name === 'Bob' → true.
Возвращается индекс объекта { id: 2, name: 'Bob' }, то есть 1.

2. Если условие не выполнено
   Если ни один элемент не удовлетворяет условию, метод возвращает -1:

```javascript
const numbers = [1, 3, 5, 7];

const index = numbers.findIndex((num) => num > 10);
console.log(index); // -1
```

3. Поиск индекса первого чётного числа

```javascript
const numbers = [1, 3, 7, 8, 10];

const index = numbers.findIndex((num) => num % 2 === 0);
console.log(index); // 3
```

Что происходит в коде?
У нас есть массив чисел numbers: [1, 3, 7, 8, 10].
Мы используем метод findIndex(), чтобы найти индекс первого чётного числа в массиве.

В качестве условия мы передаём функцию:
num => num % 2 === 0
Эта функция проверяет, является ли число чётным (делится ли оно на 2 без остатка).
Если число чётное, функция возвращает true.
Если нечётное, возвращает false.

Что означает num % 2 === 0 ?
% — это оператор остатка от деления.
Когда вы делите число на другое, % возвращает остаток от деления.

Примеры:
4 % 2 = 0 (4 делится на 2 без остатка, значит, оно чётное).

5 % 2 = 1 (5 делится на 2 с остатком 1, значит, оно нечётное).

8 % 2 = 0 (8 делится на 2 без остатка, значит, оно чётное).

=== — это оператор строгого сравнения, который проверяет:

Левая и правая стороны должны быть равны и одного типа.
Например:
0 === 0 → true.
1 === 0 → false.

Как работает проверка num % 2 === 0?
Она проверяет, делится ли число num на 2 без остатка:

Если остаток равен 0, число чётное.
Если остаток не равен 0, число нечётное.

Как работает метод findIndex() в этом коде?
Начало работы:

Метод начинает перебирать массив numbers по одному элементу.

Итерации:

Первая итерация:
Текущий элемент: 1.
Проверка: 1 % 2 === 0 → 1 % 2 = 1, значит 1 !== 0 → false.

Вторая итерация:
Текущий элемент: 3.
Проверка: 3 % 2 === 0 → 3 % 2 = 1, значит 3 !== 0 → false.

Третья итерация:
Текущий элемент: 7.
Проверка: 7 % 2 === 0 → 7 % 2 = 1, значит 7 !== 0 → false.

Четвёртая итерация:
Текущий элемент: 8.
Проверка: 8 % 2 === 0 → 8 % 2 = 0, значит 8 === 0 → true.
Элемент найден! Метод останавливается и возвращает индекс 3.

Результат:
Метод findIndex() вернул индекс 3, потому что:

Первый чётный элемент — это 8.
Его индекс в массиве равен 3.

Чем отличается findIndex() от indexOf() ?
Метод findIndex():
Позволяет искать индекс элемента с использованием сложного условия.
Работает с объектами, массивами и любыми другими структурами данных.

Возвращает:
Индекс первого элемента, который удовлетворяет условию.
-1, если ничего не найдено.

Метод indexOf():
Используется для поиска точного совпадения элемента.
Не поддерживает сложные условия.
Работает только с примитивами (строки, числа и т.д.), не подходит для объектов.

Возвращает:
Индекс первого найденного элемента.
-1, если элемент не найден.

Пример:

```javascript
const numbers = [10, 20, 30, 40];

// Ищем индекс числа 30
const index = numbers.indexOf(30);
console.log(index); // 2
```

Сравнение на одном примере:

```javascript
const numbers = [10, 20, 30, 40];

// Найти индекс числа > 25
const findIndexResult = numbers.findIndex((num) => num > 25);
console.log(findIndexResult); // 2 (первый элемент > 25)

// Найти индекс числа 30
const indexOfResult = numbers.indexOf(30);
console.log(indexOfResult); // 2 (точное совпадение с 30)
```

Когда использовать?
Используйте findIndex():
Если нужно задать сложное условие (например, проверка свойства объекта или сложная логика).
Используйте indexOf():
Если нужно найти индекс элемента по точному совпадению примитива.

// --------------------------------------------------------------------------------- //

## МЕТОДЫ SOME И EVERY ДЛЯ МАССИВОВ

Метод some() используется для проверки, есть ли в массиве хотя бы один элемент,
который удовлетворяет заданному условию.
Если такой элемент найден, метод возвращает true. Если нет — возвращает false.

Синтаксис:

```javascript
array.some(callback(element, index, array), thisArg);
```

callback — функция, которая вызывается для каждого элемента массива.
Она должна вернуть:
true, если элемент соответствует условию.
false, если элемент не соответствует условию.

Параметры функции:
element — текущий элемент массива.
index (опционально) — индекс текущего элемента.
array (опционально) — сам массив.
thisArg (опционально) — значение, которое будет использоваться как this внутри функции.

Примеры работы some():

1. Проверка на наличие чётных чисел

```javascript
const numbers = [1, 3, 7, 8, 10];

const hasEven = numbers.some((num) => num % 2 === 0);
console.log(hasEven); // true
```

Как это работает:
Метод начинает проверять элементы массива:
1 % 2 === 0 → false.
3 % 2 === 0 → false.
7 % 2 === 0 → false.
8 % 2 === 0 → true.
Как только найден первый подходящий элемент (8), метод возвращает true и останавливается.

2. Проверка наличия объекта с определённым свойством

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const hasBob = users.some((user) => user.name === "Bob");
console.log(hasBob); // true
```

Как это работает:
Проверяет: { id: 1, name: 'Alice' } → name === 'Bob' → false.
Проверяет: { id: 2, name: 'Bob' } → name === 'Bob' → true.
Как только найден элемент, метод возвращает true.

3. Если ничего не найдено

```javascript
const numbers = [1, 3, 5, 7];

const hasEven = numbers.some((num) => num % 2 === 0);
console.log(hasEven); // false
```

Как это работает:
Метод проверяет все элементы массива.
Никакое число не удовлетворяет условию (num % 2 === 0).
Возвращается false.

Что возвращает метод some()?
true, если хотя бы один элемент удовлетворяет условию.
false, если ни один элемент не удовлетворяет условию.

Метод includes():
Метод includes() проверяет, содержит ли массив определённое значение.
Если значение найдено, метод возвращает true. Если нет — false.

Синтаксис:

```javascript
array.includes(valueToFind, fromIndex);
```

valueToFind — значение, которое нужно найти.
fromIndex (опционально) — индекс, с которого начать поиск. По умолчанию 0.

Примеры работы includes():

1. Проверка наличия числа в массиве

```javascript
const numbers = [1, 3, 7, 8, 10];

const hasSeven = numbers.includes(7);
console.log(hasSeven); // true
```

Как это работает:
Метод проверяет, содержится ли число 7 в массиве.
Так как число есть, возвращается true.

2. Если значение не найдено

```javascript
const numbers = [1, 3, 7, 8, 10];

const hasFive = numbers.includes(5);
console.log(hasFive); // false
```

Как это работает:
Метод проверяет, есть ли число 5.
Так как его нет, возвращается false.

3. С указанием индекса начала

```javascript
const numbers = [1, 3, 7, 8, 10];

const hasThreeAfterIndex2 = numbers.includes(3, 2);
console.log(hasThreeAfterIndex2); // false
```

Как это работает:
Метод начинает поиск с индекса 2.
Число 3 находится раньше (на индексе 1), поэтому возвращается false.

Пример для сравнения:

```javascript
const numbers = [1, 3, 7, 8, 10];

// Используем some()
const hasEven = numbers.some((num) => num % 2 === 0);
console.log(hasEven); // true (найдено чётное число)

// Используем includes()
const hasSeven = numbers.includes(7);
console.log(hasSeven); // true (7 есть в массиве)
```

Когда использовать?
some():
Если нужно проверить сложное условие (например, чётность, наличие объекта с определённым свойством и т.д.).
includes():
Если нужно проверить наличие конкретного значения в массиве.

Метод every() для массивов:
Метод every() проверяет, удовлетворяют ли все элементы массива определённому условию, заданному функцией.
Если все элементы удовлетворяют условию, метод возвращает true.
Если хотя бы один элемент не соответствует условию, метод возвращает false.

Синтаксис:

```javascript
array.every(callback(element, index, array), thisArg);
```

callback — функция, которая вызывается для каждого элемента массива.
Она должна вернуть:
true, если элемент соответствует условию.
false, если элемент не соответствует условию.

Параметры функции:
element — текущий элемент массива.
index (опционально) — индекс текущего элемента.
array (опционально) — сам массив.
thisArg (опционально) — значение, которое будет использоваться как this внутри функции.

Примеры работы every():

1. Проверка, все ли числа чётные

```javascript
const numbers = [2, 4, 6, 8];

const allEven = numbers.every((num) => num % 2 === 0);
console.log(allEven); // true
```

Как это работает:
Метод проверяет каждый элемент массива:
2 % 2 === 0 → true.
4 % 2 === 0 → true.
6 % 2 === 0 → true.
8 % 2 === 0 → true.
Все проверки вернули true, поэтому метод возвращает true.

2. Проверка, все ли числа больше 0

```javascript
const numbers = [1, 3, 7, -2];

const allPositive = numbers.every((num) => num > 0);
console.log(allPositive); // false
```

Как это работает:
Метод проверяет:
1 > 0 → true.
3 > 0 → true.
7 > 0 → true.
-2 > 0 → false.
Как только найден элемент, который не соответствует условию (-2),
метод возвращает false и останавливается.

3. Проверка всех строк на длину больше 3

```javascript
const strings = ["apple", "banana", "cat"];

const allLong = strings.every((str) => str.length > 3);
console.log(allLong); // false
```

Как это работает:
Метод проверяет:
'apple'.length > 3 → true.
'banana'.length > 3 → true.
'cat'.length > 3 → false.
Поскольку одна строка ('cat') не соответствует условию, метод возвращает false.

4. Проверка, все ли объекты содержат определённое свойство

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const allHaveName = users.every((user) => user.hasOwnProperty("name"));
console.log(allHaveName); // true
```

Как это работает:
Метод проверяет:
{ id: 1, name: 'Alice' } → содержит свойство name → true.
{ id: 2, name: 'Bob' } → содержит свойство name → true.
{ id: 3, name: 'Charlie' } → содержит свойство name → true.
Все проверки вернули true, поэтому метод возвращает true.

5. Если массив пустой

```javascript
const emptyArray = [];

const result = emptyArray.every((num) => num > 0);
console.log(result); // true
```

Почему результат true:
Метод every() на пустом массиве всегда возвращает true, так как "нет элементов, которые нарушают условие".

Что возвращает метод every()?
true, если все элементы массива удовлетворяют условию.
false, если хотя бы один элемент не удовлетворяет условию.

Отличия от метода some():
Характеристика every() some():
Назначение:
Проверяет, соответствуют ли все элементы условию. Проверяет, соответствует ли хотя бы один элемент условию.
Результат:
true, если все элементы удовлетворяют условию. true, если хотя бы один элемент удовлетворяет условию.
Когда завершает:
Останавливается, как только находит элемент, не соответствующий условию.
Останавливается, как только находит элемент, удовлетворяющий условию.

Пример для сравнения:

```javascript
const numbers = [2, 4, 6, 8];

// Проверяем с every(): Все ли числа чётные
const allEven = numbers.every((num) => num % 2 === 0);
console.log(allEven); // true

// Проверяем с some(): Есть ли хотя бы одно чётное число
const hasEven = numbers.some((num) => num % 2 === 0);
console.log(hasEven); // true
```

Когда использовать every() ?
Когда нужно убедиться, что все элементы массива соответствуют условию:
Например, проверка всех чисел на положительность.
Проверка всех объектов на наличие определённого свойства.
Проверка, что все строки имеют минимальную длину.

Итог
every() — мощный инструмент для проверки массива на соответствие всех элементов заданному условию.
Если хотя бы один элемент не соответствует условию, метод сразу возвращает false.

На примерах выше для методов массивы, ты всегда передовал функцию обратного вызова
непосредственно в качестве аргументов в методы массивы.
Но мы также можем написать эту функцию отдельно, и передать его в качестве обратного вызова, верно ?
Если да, расскажи логику работы подробнее с примерами.

Да, вы абсолютно правы! Вместо передачи функции прямо в метод массива,
вы можете определить функцию отдельно и затем передать её в качестве аргумента.
Это особенно полезно, если функция сложная или должна быть использована несколько раз в разных местах.
Рассмотрим логику работы такого подхода на примерах.

Как это работает?
Определение функции отдельно:

Вы создаёте функцию, которая принимает те же параметры, что и функция обратного вызова (element, index, array).
Эта функция возвращает true или false (или любое значение, которое ожидает метод).

Передача функции в метод:
Вместо определения функции прямо в аргументах метода (как num => num % 2 === 0),
вы передаёте имя ранее определённой функции.

Примеры:

1. Проверка, все ли числа положительные (для every())

Без отдельной функции:

```javascript
const numbers = [1, 3, 7, 8];

const allPositive = numbers.every((num) => num > 0);
console.log(allPositive); // true
```

С отдельной функцией:

```javascript
const isPositive = (num) => num > 0; // Отдельная функция

const numbers = [1, 3, 7, 8];
const allPositive = numbers.every(isPositive); // Передаём функцию
console.log(allPositive); // true
```

Объяснение:
Мы определили функцию isPositive, которая проверяет, является ли число больше нуля.
Затем передали её в every(). Метод вызывает эту функцию для каждого элемента массива.

2. Поиск индекса первого чётного числа (для findIndex())

Без отдельной функции:

```javascript
const numbers = [1, 3, 7, 8, 10];

const firstEvenIndex = numbers.findIndex((num) => num % 2 === 0);
console.log(firstEvenIndex); // 3
```

С отдельной функцией:

```javascript
const isEven = (num) => num % 2 === 0; // Функция проверки чётности

const numbers = [1, 3, 7, 8, 10];
const firstEvenIndex = numbers.findIndex(isEven); // Передаём функцию
console.log(firstEvenIndex); // 3
```

Объяснение:
Функция isEven проверяет, делится ли число на 2 без остатка.
Метод findIndex вызывает эту функцию для каждого элемента массива, пока не находит подходящий.

3. Проверка наличия имени "Bob" в массиве объектов (для some())

Без отдельной функции:

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const hasBob = users.some((user) => user.name === "Bob");
console.log(hasBob); // true
```

С отдельной функцией:

```javascript
const isNameBob = (user) => user.name === "Bob"; // Проверка имени

const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];

const hasBob = users.some(isNameBob); // Передаём функцию
console.log(hasBob); // true
```

Объяснение:
Функция isNameBob проверяет, равно ли свойство name объекта строке 'Bob'.
Метод some вызывает эту функцию для каждого объекта в массиве, пока не найдёт подходящий.

4. Создание нового массива квадратов чисел (для map())

Без отдельной функции:

```javascript
const numbers = [1, 2, 3, 4];

const squares = numbers.map((num) => num ** 2);
console.log(squares); // [1, 4, 9, 16]
```

С отдельной функцией:

```javascript
const square = (num) => num ** 2; // Возведение в квадрат

const numbers = [1, 2, 3, 4];
const squares = numbers.map(square); // Передаём функцию
console.log(squares); // [1, 4, 9, 16]
```

Объяснение:
Функция square принимает число и возвращает его квадрат.
Метод map вызывает эту функцию для каждого элемента массива и создаёт новый массив из результатов.

Когда лучше использовать отдельные функции?
Повторное использование: Если функция может быть вызвана в нескольких местах, лучше определить её отдельно.

Улучшение читаемости: Длинные функции в методах массива могут сделать код трудночитаемым.
Вынесение функции в отдельную переменную делает код более понятным.

Тестирование: Отдельные функции проще тестировать отдельно от основного кода.

Итог:
Вынос функции в отдельную переменную:
Делает код более структурированным.
Повышает читаемость.
Позволяет легко использовать одну и ту же логику в разных местах.
Таким образом, это полезный и рекомендуемый подход для работы с методами массивов.

// --------------------------------------------------------------------------------- //

## МЕТОДЫ FLAT И FLATMAP ДЛЯ МАССИВОВ

Методы flat() и flatMap() для массивов:
Оба метода предназначены для работы с массивами,
которые содержат вложенные массивы или требуют преобразования.
Рассмотрим каждый из них подробно, а затем сравним их.

Метод flat():
Метод flat() "разворачивает" вложенные массивы в один массив,
убирая указанное количество уровней вложенности.

Синтаксис:

```javascript
array.flat(depth);
```

depth (опционально) — число, указывающее, сколько уровней вложенности нужно развернуть. По умолчанию значение равно 1.

Примеры:
Простой пример (разворачивание на 1 уровень):

```javascript
const arr = [1, 2, [3, 4], [5, [6, 7]]];

const flatArr = arr.flat();
console.log(flatArr); // [1, 2, 3, 4, 5, [6, 7]]
```

Как это работает:
Метод убирает вложенность только на один уровень.
[3, 4] разворачивается в 3, 4, а [6, 7] остаётся вложенным.

Указание глубины:

```javascript
const arr = [1, 2, [3, 4], [5, [6, 7, [8, 9]]]];

const flatArr = arr.flat(2); // Разворачиваем на 2 уровня
console.log(flatArr); // [1, 2, 3, 4, 5, 6, 7, [8, 9]]
```

Объяснение:
depth = 2 убирает два уровня вложенности. Теперь [8, 9] остаётся вложенным.

Полное разворачивание массива:

```javascript
const arr = [1, [2, [3, [4, 5]]]];

const completelyFlat = arr.flat(Infinity); // Убираем все уровни вложенности
console.log(completelyFlat); // [1, 2, 3, 4, 5]
```

Как это работает:
Параметр Infinity заставляет flat() полностью развернуть массив, независимо от глубины.

Удаление пустых элементов:

```javascript
const arr = [1, 2, , 4, [5, , 6]];

const flatArr = arr.flat();
console.log(flatArr); // [1, 2, 4, 5, 6]
```

Как это работает:
flat() автоматически убирает "дыры" (пустые элементы).

Метод flatMap():
Метод flatMap() объединяет функциональность map() и flat(1):

Сначала он применяет функцию обратного вызова (callback) к каждому элементу массива.
Затем "разворачивает" получившиеся массивы на один уровень вложенности.

Синтаксис:

```javascript
array.flatMap(callback(element, index, array), thisArg);
```

callback — функция, которая применяется к каждому элементу.
thisArg (опционально) — значение, которое будет использоваться как this внутри callback.

Примеры:
Преобразование и разворачивание:

```javascript
const arr = [1, 2, 3];

const flatMapped = arr.flatMap((num) => [num, num * 2]);
console.log(flatMapped); // [1, 2, 2, 4, 3, 6]
```

Объяснение:
Функция num => [num, num * 2] создаёт новый массив для каждого элемента.
Метод flatMap() разворачивает эти массивы на один уровень:
[[1, 2], [2, 4], [3, 6]] → [1, 2, 2, 4, 3, 6].

Удаление пустых элементов:

```javascript
const arr = ["a", "", "b"];

const result = arr.flatMap((str) => (str ? [str] : []));
console.log(result); // ['a', 'b']
```

Объяснение:
Функция возвращает пустой массив для пустых строк,
а для остальных возвращает массив с самим значением.

Работа с объектами:

```javascript
const users = [
  { name: "Alice", tags: ["student", "programmer"] },
  { name: "Bob", tags: ["teacher"] },
  { name: "Charlie", tags: [] },
];

const allTags = users.flatMap((user) => user.tags);
console.log(allTags); // ['student', 'programmer', 'teacher']
```

Объяснение:
user => user.tags возвращает массив тегов для каждого пользователя.
flatMap() объединяет их в один массив.

Различие с map() и flat():

```javascript
const arr = [1, 2, 3];

const mapped = arr.map((num) => [num, num * 2]);
console.log(mapped); // [[1, 2], [2, 4], [3, 6]]

const flatMapped = arr.flatMap((num) => [num, num * 2]);
console.log(flatMapped); // [1, 2, 2, 4, 3, 6]
```

Объяснение:
map() создаёт вложенный массив.
flatMap() автоматически разворачивает его на один уровень.

Сравнение flat() и flatMap():
Характеристика:
Назначение:
flat()
Разворачивает вложенные массивы.
flatMap()
Преобразует элементы с помощью функции, затем разворачивает результат.

Функция обратного вызова:
flat()
Не принимает.
flatMap()
Требуется для обработки каждого элемента.

Глубина разворачивания:
flat()
Задаётся явно с помощью параметра depth.
flatMap()
Всегда разворачивает только на один уровень.

Удаление вложенности:
flat()
Только удаляет вложенность.
flatMap()
Одновременно преобразует и удаляет вложенность.

Итог:
Когда использовать flat():
Если нужно просто убрать уровни вложенности в массиве.
Когда не требуется обработка элементов перед разворачиванием.

Когда использовать flatMap():
Если нужно одновременно обработать элементы массива и убрать вложенность.
Удобен для комбинации действий, которые иначе потребовали бы вызова map() и flat().
Этот подход делает код лаконичным и более читаемым!

// --------------------------------------------------------------------------------- //

## МЕТОД SORT ДЛЯ СОРТИРОВКИ МАССИВОВ

Чтобы понять, как работают параметры (a, b) в методе sort(),
нужно понять, что делает JavaScript при сортировке массива.

Как передаются параметры (a, b) в функцию сравнения?
Метод sort() перебирает массив и поочерёдно передаёт пары элементов
(два элемента за раз) в функцию сравнения, которую вы указываете.
Порядок этих элементов (a и b) зависит от текущего состояния массива на момент вызова функции.

Процесс сортировки:
Метод sort() начинает с первых двух элементов массива.
Передаёт их в вашу функцию сравнения как аргументы a и b.

Функция сравнения возвращает:
Отрицательное значение, если a должно быть перед b.
Положительное значение, если b должно быть перед a.
Ноль, если порядок a и b не изменяется.

После сравнения элементов, массив перестраивается на основе результата.
Этот процесс повторяется для всех элементов массива, пока массив не будет полностью отсортирован.

Пример 1: Сортировка чисел

```javascript
const numbers = [10, 5, 20, 15];

numbers.sort((a, b) => a - b);
console.log(numbers); // [5, 10, 15, 20]
```

Как это работает:
На первой итерации sort() передаёт первые два элемента массива:
a = 10 и b = 5.
Вычисляется a - b = 10 - 5 = 5 (положительное значение).
b (5) ставится перед a (10).
Теперь массив: [5, 10, 20, 15].

Следующая пара: a = 10, b = 20.
Вычисляется a - b = 10 - 20 = -10 (отрицательное значение).
a (10) остаётся перед b (20).
Теперь массив: [5, 10, 20, 15].

Следующая пара: a = 20, b = 15.
Вычисляется a - b = 20 - 15 = 5 (положительное значение).
b (15) ставится перед a (20).
Теперь массив: [5, 10, 15, 20].
Массив отсортирован, процесс завершён.

Пример 2: Сортировка строк

```javascript
const fruits = ["banana", "apple", "cherry"];

fruits.sort((a, b) => a.localeCompare(b));
console.log(fruits); // ['apple', 'banana', 'cherry']
```

Как это работает:
На первой итерации sort() передаёт a = 'banana' и b = 'apple'.
Вызывается a.localeCompare(b):
Возвращает положительное значение, так как 'banana' идёт после 'apple' по алфавиту.
b ('apple') ставится перед a ('banana').
Теперь массив: ['apple', 'banana', 'cherry'].

Следующая пара: a = 'banana', b = 'cherry'.
Вызывается a.localeCompare(b):
Возвращает отрицательное значение, так как 'banana' идёт перед 'cherry'.
Порядок не меняется.
Массив остаётся: ['apple', 'banana', 'cherry'].

Пример 3: Сортировка объектов

```javascript
const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 20 },
  { name: "Charlie", age: 30 },
];

users.sort((a, b) => a.age - b.age);
console.log(users);
```

Как это работает:
На первой итерации sort() передаёт два объекта:
a = { name: 'Alice', age: 25 }
b = { name: 'Bob', age: 20 }.
Вычисляется a.age - b.age = 25 - 20 = 5 (положительное значение).
b (Bob) ставится перед a (Alice).
Теперь массив: [ { name: 'Bob', age: 20 }, { name: 'Alice', age: 25 }, { name: 'Charlie', age: 30 } ].

Следующая пара: a = { name: 'Alice', age: 25 } и b = { name: 'Charlie', age: 30 }.
Вычисляется a.age - b.age = 25 - 30 = -5 (отрицательное значение).
Порядок остаётся.
Массив остаётся: [ { name: 'Bob', age: 20 }, { name: 'Alice', age: 25 }, { name: 'Charlie', age: 30 } ].

Ключевые моменты:
Кто решает, какие элементы сравнивать?

Это делает сам метод sort() — он автоматически перебирает массив и сравнивает элементы попарно.

Порядок элементов:
На каждой итерации sort() переставляет элементы массива в зависимости от результата функции сравнения (a, b).

Что возвращает функция сравнения:
Отрицательное значение: a остаётся перед b.
Положительное значение: b перемещается перед a.
Ноль: порядок элементов не изменяется.

Почему передаются разные пары элементов?
Метод sort() использует алгоритм сортировки под названием Timsort.
Он сравнивает элементы, переставляет их и повторяет процесс, пока массив не будет отсортирован.

Заключение:
Параметры (a, b) — это две текущие сравниваемые функции sort() элементы.
Вы управляете их порядком с помощью функции сравнения,
возвращая отрицательное, положительное значение или ноль.
Это позволяет настроить сортировку под любые требования:
от чисел до строк, от дат до сложных объектов.

// --------------------------------------------------------------------------------- //

## КАК СОЗДАВАТЬ И ЗАПОЛНЯТЬ МАССИВЫ МЕТОДЫ NEW ARRAY - ARRAY.FROM

1. Создание массива через литерал и через конструктор Array

```javascript
const arr = [1, 2, 3, 4, 5, 6, 7];
console.log(new Array(1, 2, 3, 4, 5, 6, 7));
```

Логика:
Литерал массива:
const arr = [1, 2, 3, 4, 5, 6, 7]; создаёт массив с элементами 1, 2, 3, ..., 7.
Это самый распространённый способ создания массива.

Конструктор Array:
new Array(1, 2, 3, 4, 5, 6, 7) тоже создаёт массив с элементами 1, 2, 3, ..., 7.

Вывод в консоль:
Оба способа дают один и тот же результат:
[1, 2, 3, 4, 5, 6, 7]

2. Создание пустого массива и заполнение с помощью fill

```javascript
const x = new Array(7);
console.log(x);
```

Логика:
new Array(7):
Создаёт пустой массив длиной 7.
При этом массив не содержит значений (только пустые слоты).
[empty × 7]
Это важно: "пустые слоты" отличаются от значений undefined или null.
console.log(x):
Показывает массив длиной 7, в котором все слоты пусты.

```javascript
x.fill(1, 2, 5);
console.log(x);
```

Логика:
fill(1, 2, 5):
Заполняет массив значением 1 начиная с индекса 2 и до индекса 5 (не включая его).
Результат:
[empty × 2, 1, 1, 1, empty × 2]

Как работает:
fill изменяет существующий массив.
Пустые слоты с индексами 2, 3, 4 заменяются на 1.

```javascript
x.fill(3);
console.log(x);
```

Логика:
fill(3):
Заполняет весь массив значением 3.
Теперь весь массив выглядит так:
[3, 3, 3, 3, 3, 3, 3]

3. Заполнение массива через fill на примере arr

```javascript
arr.fill(23, 2, 6);
console.log(arr);
```

Логика:
fill(23, 2, 6):
Заполняет массив значением 23 с индекса 2 до 6 (не включая его).
Исходный массив arr:
[1, 2, 3, 4, 5, 6, 7]
После заполнения:
[1, 2, 23, 23, 23, 23, 7]

Как работает:
fill заменяет элементы с индексами 2, 3, 4, 5 на значение 23.

4. Создание массива через Array.from
   Пример 1: Массив, заполненный единицами

```javascript
const y = Array.from({ length: 7 }, () => 1);
console.log(y); // [1, 1, 1, 1, 1, 1, 1]
```

Array.from:
Создаёт массив длиной 7 (указано в объекте { length: 7 }).
Коллбэк () => 1:
Для каждого элемента массива вызывается функция () => 1, которая возвращает 1.

Результат:
Каждый элемент массива становится равен 1:
[1, 1, 1, 1, 1, 1, 1]

Пример 2: Массив с числами от 1 до 7

```javascript
const z = Array.from({ length: 7 }, (cur, i) => i + 1);
console.log(z); // [1, 2, 3, 4, 5, 6, 7]
```

Коллбэк (cur, i) => i + 1:
cur — текущий элемент (для Array.from всегда undefined в данном случае).
i — текущий индекс.
i + 1 добавляет 1 к индексу.

Результат:
Массив создаётся с элементами от 1 до 7:
[1, 2, 3, 4, 5, 6, 7]

Пример 3: Тоже самое, но с подчёркиванием \_ вместо cur

```javascript
const p = Array.from({ length: 7 }, (_, i) => i + 1);
console.log(p); // [1, 2, 3, 4, 5, 6, 7]
```

Почему используется _:
Подчёркивание _ часто используется для обозначения неиспользуемого параметра (в данном случае cur).

Логика:
Результат абсолютно идентичен предыдущему:
[1, 2, 3, 4, 5, 6, 7]

Итоги по коду:
Array и new Array:
Создают массив. Если передан один аргумент (число),
создаётся массив заданной длины с пустыми слотами.

fill:
Изменяет существующий массив, заполняя его указанным значением.
Вы можете указать диапазон индексов для заполнения.

Array.from:
Создаёт новый массив из объекта, подобного массиву.
Удобен для заполнения массивов значениями или для генерации последовательностей.

Пример с использованием метода Array.from():

```javascript
labelBalance.addEventListener("click", function () {
  const movementsUI = Array.from(
    document.querySelectorAll(".movements__value"),
    (el) => Number(el.textContent.replace("$", ""))
  );

  console.log(movementsUI);
});
```

Что происходит в коде?
Назначается обработчик события на элемент labelBalance:

Событие click — это клик мышью.
При клике запускается функция (обработчик).
Собираются элементы с классом .movements\_\_value:

document.querySelectorAll('.movements\_\_value') находит все элементы
с указанным классом на странице и возвращает их как NodeList.

Array.from преобразует этот NodeList в массив:
Это делается для удобства работы с методами массивов, такими как map, filter, и т.д.

Во втором аргументе Array.from используется функция преобразования:
Для каждого элемента массива el:
el.textContent извлекает текстовое содержимое.
.replace('$', '') удаляет символ $ из текста.
Number(...) преобразует текст в число.

Результат:
Получается массив чисел, соответствующий значениям внутри элементов .movements\_\_value.

console.log(movementsUI):
Выводит результат в консоль для проверки.

Почему используется Array.from()?

1. document.querySelectorAll возвращает NodeList
   NodeList не является настоящим массивом.
   NodeList поддерживает только базовые методы, например, forEach.
   Методы массивов, такие как map, filter, reduce, и другие, на нём не работают.

2. Преобразование NodeList в массив
   Array.from() позволяет создать массив из любого объекта, который похож на массив (например, NodeList).
   Это делает работу с элементами более гибкой, так как теперь мы можем использовать все методы массива.

3. Оптимизация с помощью второго аргумента
   Array.from(DOM, mapEl) позволяет одновременно преобразовать элементы, что упрощает код.
   Вместо двух операций (сначала преобразовать в массив, а затем применить map), мы делаем это в одном шаге.

Разбор примера:
Предположим, HTML-код выглядит так:

```html
<div class="movements__value">$200</div>
<div class="movements__value">$300</div>
<div class="movements__value">$150</div>
```

Код работает следующим образом:
document.querySelectorAll('.movements**value'):
Возвращает NodeList:
[div.movements**value, div.movements**value, div.movements**value]

Array.from:
Преобразует этот NodeList в массив:
[div, div, div]

Функция преобразования:
Для каждого элемента извлекается текст, удаляется $, и преобразуется в число:

Для первого элемента:
el.textContent → "$200"
.replace('$', '') → "200"
Number("200") → 200

Для второго элемента:
Аналогично, результат: 300

Для третьего элемента:
Результат: 150

Результат:
Получаем массив чисел:
[200, 300, 150]

Заключение:
Array.from используется, чтобы:
Преобразовать NodeList в массив.
Сразу применить функцию преобразования к элементам.

Результат movementsUI:
Массив чисел, соответствующих значениям в элементах .movements\_\_value.

Как переписать код без Array.from?
Если бы мы не использовали Array.from, код мог бы выглядеть так:

```javascript
labelBalance.addEventListener("click", function () {
  const movementsUI = [...document.querySelectorAll(".movements__value")].map(
    (el) => Number(el.textContent.replace("$", ""))
  );

  console.log(movementsUI);
});
```

Здесь мы используем оператор spread (...)
для преобразования NodeList в массив, а затем применяем метод map.

Однако вариант с Array.from короче и эффективнее.

```

```
