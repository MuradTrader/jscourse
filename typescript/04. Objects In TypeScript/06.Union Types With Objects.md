## Общее введение

Автор переходит от union types с примитивами к union types с объектами. Это важная концепция, которая часто встречается в реальных приложениях, особенно при работе с разными типами данных, которые могут иметь общие и уникальные свойства.

---

## 1. Создание базовых типов

### Тип Dog (Собака):

```typescript
type Dog = {
  name: string;
  barks: boolean; // лает ли
  wags: boolean; // виляет ли хвостом
};
```

### Тип Cat (Кошка):

```typescript
type Cat = {
  name: string;
  purrs: boolean; // мурлыкает ли
};
```

### Union тип DogAndCatUnion:

```typescript
type DogAndCatUnion = Dog | Cat;
```

---

## 2. Основные случаи использования union types с объектами

### Случай 1: Объект, соответствующий только типу Dog

```typescript
let dog: DogAndCatUnion = {
  name: "Buddy",
  barks: true,
  wags: true,
  // purrs отсутствует - это нормально
};
```

**Что происходит:** TypeScript видит, что объект содержит все свойства `Dog` и не содержит свойств, которые есть только в `Cat`.

### Случай 2: Объект, соответствующий только типу Cat

```typescript
let cat: DogAndCatUnion = {
  name: "Bella",
  purrs: true,
  // barks и wags отсутствуют - это нормально
};
```

**Что происходит:** TypeScript видит, что объект содержит все свойства `Cat` и не содержит свойств, которые есть только в `Dog`.

---

## 3. Ключевое правило union types с объектами

### Правило полной совместимости:

> **Объект в union type должен содержать ВСЕ свойства хотя бы одного из типов объединения**

Это означает:

- Можно иметь все свойства одного типа + некоторые свойства другого
- Нельзя иметь частичные свойства из разных типов

---

## 4. Сложные случаи и их разбор

### Допустимый случай: Все свойства Dog + некоторые свойства Cat

```typescript
let hybridAnimal1: DogAndCatUnion = {
  name: "Max",
  barks: true,
  wags: true, // Все свойства Dog присутствуют
  purrs: false, // Дополнительное свойство из Cat
};
```

### Допустимый случай: Все свойства Cat + некоторые свойства Dog

```typescript
let hybridAnimal2: DogAndCatUnion = {
  name: "Luna",
  purrs: true, // Все свойства Cat присутствуют
  barks: false, // Дополнительное свойство из Dog
};
```

### НЕдопустимый случай: Частичные свойства из разных типов

```typescript
// ❌ ОШИБКА TypeScript
let invalidAnimal: DogAndCatUnion = {
  name: "Invalid",
  barks: true,
  // НЕТ wags (не все свойства Dog)
  // НЕТ purrs (не все свойства Cat)
};
```

**Ошибка TypeScript:** "Type '{ name: string; barks: boolean; }' is not assignable to type 'DogAndCatUnion'"

---

## 5. Почему так работает? Structural Typing в действии

### Принцип структурной типизации:

TypeScript проверяет **структуру** объекта, а не его явный тип.

```typescript
// Объект должен быть структурно совместим с хотя бы одним типом в объединении

// ✅ Совместим с Dog (имеет name, barks, wags)
{ name: "A", barks: true, wags: true }

// ✅ Совместим с Cat (имеет name, purrs)
{ name: "B", purrs: true }

// ✅ Совместим с Dog (имеет все свойства Dog + дополнительные)
{ name: "C", barks: true, wags: true, purrs: false }

// ❌ Не совместим ни с Dog (нет wags), ни с Cat (нет purrs)
{ name: "D", barks: true }
```

---

## 6. Практические примеры из реальных приложений

### Пример 1: API ответы с разными форматами

```typescript
type SuccessResponse = {
  status: "success";
  data: any;
  timestamp: Date;
};

type ErrorResponse = {
  status: "error";
  error: string;
  code: number;
};

type ApiResponse = SuccessResponse | ErrorResponse;

// ✅ Допустимо - полный SuccessResponse
const response1: ApiResponse = {
  status: "success",
  data: { user: "John" },
  timestamp: new Date(),
};

// ✅ Допустимо - полный ErrorResponse
const response2: ApiResponse = {
  status: "error",
  error: "Not found",
  code: 404,
};
```

### Пример 2: Разные виды пользователей

```typescript
type AdminUser = {
  role: "admin";
  permissions: string[];
  managedUsers: number;
};

type RegularUser = {
  role: "user";
  preferences: string[];
  lastLogin: Date;
};

type User = AdminUser | RegularUser;

// ✅ Допустимо - полный AdminUser
const admin: User = {
  role: "admin",
  permissions: ["read", "write"],
  managedUsers: 5,
};

// ✅ Допустимо - полный RegularUser
const user: User = {
  role: "user",
  preferences: ["theme-dark"],
  lastLogin: new Date(),
};
```

---

## 7. Type Narrowing с union types объектов

### Проверка типа через свойство-дискриминатор:

```typescript
function processAnimal(animal: DogAndCatUnion) {
  // TypeScript не знает точный тип animal

  if ("barks" in animal) {
    // Здесь TypeScript знает, что animal - Dog (или содержит свойства Dog)
    console.log(animal.barks); // ✅ OK
    // console.log(animal.purrs); // ❌ Может не существовать
  }

  if ("purrs" in animal) {
    // Здесь TypeScript знает, что animal - Cat (или содержит свойства Cat)
    console.log(animal.purrs); // ✅ OK
  }
}
```

### Discriminated Unions (будет рассмотрено позже):

```typescript
// Более безопасный подход с дискриминатором
type Dog = {
  type: "dog"; // Дискриминатор
  name: string;
  barks: boolean;
  wags: boolean;
};

type Cat = {
  type: "cat"; // Дискриминатор
  name: string;
  purrs: boolean;
};

type Animal = Dog | Cat;

function processAnimal(animal: Animal) {
  switch (animal.type) {
    case "dog":
      console.log(animal.barks); // ✅ TypeScript знает, что это Dog
      break;
    case "cat":
      console.log(animal.purrs); // ✅ TypeScript знает, что это Cat
      break;
  }
}
```

---

## Итог от автора

Автор подчеркивает:

1. **Union types с объектами** должны содержать все свойства хотя бы одного типа
2. **Допустимо** добавлять свойства других типов объединения
3. **Недопустимо** создавать частичные объекты, не соответствующие ни одному типу
4. **Structural typing** - TypeScript проверяет структуру, а не имя типа

### Мой итог как разработчика

Вы изучили важный аспект системы типов TypeScript:

1. **Философия проектирования:** Union types позволяют создавать гибкие, но безопасные контракты для данных, которые могут быть в разных формах.

2. **Практические правила:**

   ```typescript
   // ✅ ХОРОШО - полная совместимость с одним типом
   type A = { x: number; y: number };
   type B = { a: string; b: string };
   type Union = A | B;

   const val1: Union = { x: 1, y: 2 }; // ✅ Полный A
   const val2: Union = { a: "hi", b: "bye" }; // ✅ Полный B
   const val3: Union = { x: 1, y: 2, a: "hi" }; // ✅ Полный A + свойства B

   // ❌ ПЛОХО - частичная совместимость
   const val4: Union = { x: 1, a: "hi" }; // ❌ Не полный A и не полный B
   ```

3. **Безопасность типов:** TypeScript предотвращает создание "неопределенных" объектов, которые не соответствуют ни одному известному типу.

4. **Реальные применения:**

   - **API responses** - успешные и ошибочные ответы
   - **Состояния UI** - разные состояния компонента
   - **Бизнес-сущности** - разные типы пользователей, заказов и т.д.
   - **События** - разные типы событий в системе

5. **Подготовка к продвинутым темам:**
   - **Type Guards** - функции для проверки типов
   - **Discriminated Unions** - объединения с общим свойством-дискриминатором
   - **Exhaustiveness Checking** - проверка полноты обработки всех случаев

**Резюме:** Union types с объектами — это мощный инструмент для моделирования данных, которые могут существовать в нескольких различных, но четко определенных формах. Понимание правила полной совместимости критически важно для создания корректных типобезопасных систем в TypeScript.
