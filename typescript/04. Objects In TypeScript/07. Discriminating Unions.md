## Общее введение

Автор продолжает тему union types, но теперь показывает специальный случай — **дискриминативные объединения**, где типы в объединении имеют общее свойство-дискриминатор, позволяющее их различать.

---

## 1. Создание дискриминативных типов для состояний сети

### Три отдельных типа с общим дискриминатором:

**Тип для состояния загрузки:**

```typescript
type NetworkLoadingState = {
  state: "loading"; // Дискриминатор - литеральный тип "loading"
};
```

**Тип для состояния ошибки:**

```typescript
type NetworkFailedState = {
  state: "failed"; // Дискриминатор - литеральный тип "failed"
  code: number; // Дополнительное свойство только для этого типа
};
```

**Тип для состояния успеха:**

```typescript
type NetworkSuccessState = {
  state: "success"; // Дискриминатор - литеральный тип "success"
  response: {
    // Дополнительный сложный объект
    title: string;
    duration: number;
    summary: string;
  };
};
```

### Ключевые моменты:

1. **Общее свойство `state`** присутствует во всех трех типах
2. **Литеральные типы** — каждому типу соответствует конкретное строковое значение
3. **Разные дополнительные свойства** у каждого типа

---

## 2. Создание объединенного типа

### Union type из трех состояний:

```typescript
type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState;
```

**Что это означает:**

- Любое значение типа `NetworkState` может быть одним из трех типов
- TypeScript не знает заранее, какой именно тип будет передан
- Но все они имеют свойство `state` с разными литеральными значениями

---

## 3. Функция с дискриминацией типов

### Объявление функции logger:

```typescript
function logger(state: NetworkState) {
  // Параметр state может быть любым из трех типов
  // TypeScript еще не знает конкретный тип
}
```

### Использование switch для дискриминации:

```typescript
function logger(state: NetworkState) {
  switch (
    state.state // Проверяем свойство-дискриминатор
  ) {
    case "loading":
      // Здесь TypeScript ТОЧНО знает, что state = NetworkLoadingState
      return "We are loading";

    case "failed":
      // Здесь TypeScript ТОЧНО знает, что state = NetworkFailedState
      // Можно безопасно обращаться к state.code
      return `Error code: ${state.code}`;

    case "success":
      // Здесь TypeScript ТОЧНО знает, что state = NetworkSuccessState
      // Можно безопасно обращаться к state.response
      return `Response title: ${state.response.title}`;
  }
}
```

---

## 4. Магия сужения типов (Type Narrowing)

### Как это работает:

**До проверки дискриминатора:**

```typescript
function logger(state: NetworkState) {
  // ❌ НЕЛЬЗЯ - TypeScript не знает точный тип
  console.log(state.code); // Ошибка: свойство не существует
  console.log(state.response); // Ошибка: свойство не существует
}
```

**После проверки дискриминатора:**

```typescript
function logger(state: NetworkState) {
  switch (state.state) {
    case "loading":
      // TypeScript знает: здесь только NetworkLoadingState
      // Можно использовать только свойства NetworkLoadingState
      return "Loading...";

    case "failed":
      // TypeScript знает: здесь только NetworkFailedState
      console.log(state.code); // ✅ OK - code существует в NetworkFailedState
      return `Error: ${state.code}`;

    case "success":
      // TypeScript знает: здесь только NetworkSuccessState
      console.log(state.response.title); // ✅ OK - response существует
      return `Title: ${state.response.title}`;
  }
}
```

---

## 5. Почему это безопасно?

### Без дискриминации - опасный код:

```typescript
// ❌ Потенциальная ошибка времени выполнения
function unsafeLogger(state: NetworkState) {
  if (state.code) {
    // code может быть undefined
    console.log(state.code);
  }
}
```

### С дискриминацией - безопасный код:

```typescript
// ✅ TypeScript гарантирует безопасность
function safeLogger(state: NetworkState) {
  switch (state.state) {
    case "failed":
      console.log(state.code); // ✅ Гарантировано существует
      break;
    case "success":
      console.log(state.response.title); // ✅ Гарантировано существует
      break;
    case "loading":
      // Никаких лишних свойств - только state
      console.log("Loading...");
      break;
  }
}
```

---

## 6. Практическое использование

### Создание объектов разных типов:

```typescript
// Объект состояния загрузки
const loadingState: NetworkState = {
  state: "loading",
};

// Объект состояния ошибки
const failedState: NetworkState = {
  state: "failed",
  code: 404,
};

// Объект состояния успеха
const successState: NetworkState = {
  state: "success",
  response: {
    title: "Data loaded",
    duration: 5,
    summary: "Successfully fetched user data",
  },
};
```

### Использование функции logger:

```typescript
console.log(logger(loadingState)); // "We are loading"
console.log(logger(failedState)); // "Error code: 404"
console.log(logger(successState)); // "Response title: Data loaded"
```

---

## Итог от автора

Автор подчеркивает:

1. **Дискриминативные объединения** используют общее свойство с литеральным типом для различения типов
2. **Switch/case** позволяет TypeScript автоматически сужать типы
3. **Безопасный доступ** к свойствам только после проверки дискриминатора
4. **Практическая ценность** — обработка разных состояний в приложениях

### Мой итог как разработчика

Вы изучили мощный паттерн TypeScript:

1. **Ключевая идея:** Использование общего свойства с литеральным типом как "метки" для различения типов в объединении.

2. **Преимущества:**

   - **Типобезопасность** — ошибки обнаруживаются на этапе компиляции
   - **Читаемость** — явно видно все возможные состояния
   - **Поддержка** — легко добавлять новые типы в объединение

3. **Области применения:**

   - Состояния загрузки данных
   - Результаты операций (успех/ошибка)
   - Различные типы событий
   - Состояния конечного автомата (state machine)

4. **Важное правило:** Все типы в дискриминативном объединении должны иметь общее свойство с разными литеральными значениями.

**Резюме:** Дискриминативные объединения превращают потенциальные runtime-ошибки в ошибки компиляции, делая код более надежным и предсказуемым. Это один из самых мощных инструментов TypeScript для создания типобезопасных приложений.
