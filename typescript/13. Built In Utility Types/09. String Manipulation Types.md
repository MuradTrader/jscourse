## Что такое String Manipulation Utility Types?

Автор упоминает четыре основных типа:

- **`Uppercase<T>`** - преобразует строку в верхний регистр
- **`Lowercase<T>`** - преобразует строку в нижний регистр
- **`Capitalize<T>`** - делает первую букву заглавной
- **`Uncapitalize<T>`** - делает первую букву строчной

**Ключевая идея:** Эти утилиты работают не с runtime-строками, а со **строковыми литералами в системе типов**.

## Детальный разбор примера

### Исходный тип

```typescript
type City = "new york" | "london" | "tokyo";
```

### 1. `Uppercase<T>` - Все буквы заглавные

```typescript
type UppercaseCity = Uppercase<City>;
// Результат: "NEW YORK" | "LONDON" | "TOKYO"
```

**Что происходит:**

- Каждый строковый литерал в юнион-типе преобразуется в верхний регистр
- "new york" → "NEW YORK"
- "london" → "LONDON"
- "tokyo" → "TOKYO"

### 2. `Lowercase<T>` - Все буквы строчные

```typescript
type LowercaseCity = Lowercase<City>;
// Результат: "new york" | "london" | "tokyo"
// (остается без изменений, так как уже в нижнем регистре)
```

Если бы у нас были города с разным регистром:

```typescript
type MixedCity = "New York" | "LONDON" | "Tokyo";
type LowercaseMixed = Lowercase<MixedCity>;
// Результат: "new york" | "london" | "tokyo"
```

### 3. `Capitalize<T>` - Первая буква заглавная

```typescript
type CapitalizeCity = Capitalize<City>;
// Результат: "New york" | "London" | "Tokyo"
```

**Важное замечание автора:**

> "it only capitalizes the first letter of the first word"

То есть `Capitalize` работает только с первой буквой первого слова:

- "new york" → "New york" (а не "New York")
- "london" → "London"
- "tokyo" → "Tokyo"

### 4. `Uncapitalize<T>` - Первая буква строчная

```typescript
type UncapitalizeCity = Uncapitalize<CapitalizeCity>;
// Результат: "new york" | "london" | "tokyo"
```

## Как TypeScript реализует это внутри?

Эти утилитарные типы являются **встроенными (intrinsic)** и реализованы непосредственно на уровне компилятора TypeScript. Они не могут быть реализованы через обычные TypeScript-конструкции.

## Практические сценарии использования

### 1. Единообразие API ответов

```typescript
// Допустим, API возвращает ключи в разном регистре
type ApiResponse = {
  userName: string;
  user_age: number;
  UserEmail: string;
};

// Приводим все ключи к единому формату
type NormalizedResponse = {
  [K in keyof ApiResponse as Lowercase<K>]: ApiResponse[K];
};
// Результат: { username: string; user_age: number; useremail: string; }
```

### 2. Генерация CSS классов

```typescript
type Color = "primary" | "secondary" | "danger";

type ColorClasses = `bg-${Capitalize<Color>}`;
// Результат: "bg-Primary" | "bg-Secondary" | "bg-Danger"
```

### 3. Согласованность констант

```typescript
type EventNames = "click" | "hover" | "focus";

// Преобразуем в формат CONSTANT_CASE для конфигурации
type ConstantEvents = Uppercase<EventNames>;
// Результат: "CLICK" | "HOVER" | "FOCUS"
```

## Ограничения и важные особенности

### 1. Работа только со строковыми литералами

```typescript
type Test1 = Uppercase<"hello">; // "HELLO" - работает
type Test2 = Uppercase<string>; // string - не преобразуется
```

### 2. Сохранение структуры составных строк

```typescript
type Compound = "hello-world" | "test_case";
type UpperCompound = Uppercase<Compound>;
// Результат: "HELLO-WORLD" | "TEST_CASE"
// Дефисы и подчеркивания сохраняются
```

### 3. Работа с юнион-типами

Как показывает пример автора, утилиты автоматически применяются ко всем членам юнион-типа.

## Профессиональное применение

### Комбинирование с Template Literal Types

```typescript
type Actions = "create" | "update" | "delete";

// Генерация типов для методов API
type ApiMethods = `handle${Capitalize<Actions>}`;
// Результат: "handleCreate" | "handleUpdate" | "handleDelete"
```

### Создание производных типов

```typescript
type BaseRoutes = "home" | "profile" | "settings";

type RouteConstants = Uppercase<BaseRoutes>;
// Используем для констант в Redux-экшенах и т.д.
```

## Итог

String manipulation utility types — это простые, но мощные инструменты для:

1. **Обеспечения консистентности** - единообразие строковых литералов
2. **Генерации производных типов** - создание новых типов на основе существующих
3. **Работы с шаблонными литералами** - комбинация с template literal types
4. **Улучшения читаемости** - явное указание ожидаемого формата строк

Автор абсолютно прав — эти утилиты очень просты для понимания, но их правильное использование может значительно улучшить качество и поддерживаемость кода.
