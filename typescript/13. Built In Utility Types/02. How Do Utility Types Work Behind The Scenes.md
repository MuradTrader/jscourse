### Общее введение

Автор начинает с напоминания о том, что утилитарные типы (Utility Types) — это, по сути, **функции для типов**.

**Что это значит на практике?**

- Обычная функция принимает значения (например, числа или строки) и возвращает новое значение.
  `const double = (x: number) => x * 2;`
- Утилитарный тип принимает _типы_ и возвращает _новый тип_.
  `type Partial<T> = ... // Мы создаем новый тип на основе T`

TypeScript предоставляет набор таких "функций" из коробки, например, `Partial`, `Pick`, `Exclude` и многие другие. Главная мысль, которую подчеркивает автор, заключается в том, что эти волшебные типы **не являются магией**. Они построены на фундаментальных возможностям самой системы типов TypeScript, а именно на **Mapped Types (Сопоставленных типах)** и **Conditional Types (Условных типах)**.

---

### Часть 1: Mapped Types (Сопоставленные типы) и пример с `Partial`

Автор говорит:

> "Mapped types allow you to create new types based on existing types by applying a mapping function to each property of the original type."

**Подробное объяснение:**

Представьте, что у вас есть тип `Person`:

```typescript
type Person = {
  name: string;
  age: number;
};
```

Вы хотите создать новый тип, где все свойства `Person` являются необязательными (optional). Вручную это выглядело бы так:

```typescript
type PartialPerson = {
  name?: string;
  age?: number;
};
```

Mapped Types позволяют автоматизировать этот процесс. Они "проходят" по каждому свойству исходного типа и применяют к нему определенное преобразование.

**Разбор реализации `Partial` из видео:**

```typescript
type Partial<T> = {
  [P in keyof T]?: T[P];
};
```

Давайте "скомпилируем" эту строчку в человеческий язык:

1.  **`<T>`**: Это дженерик (обобщенный параметр). `T` — это входной тип, с которым мы работаем. В нашем примере `T` — это `Person`.
2.  **`keyof T`**: Эта операция возвращает **юнион-тип (union type)** всех ключей (имен свойств) типа `T`. Для `Person` это `"name" | "age"`.
3.  **`P in ...`**: Это цикл. Мы говорим: "Для каждого свойства `P` в наборе ключей типа `T`...". `P` поочередно будет принимать значения `"name"` и `"age"`.
4.  **`[P in keyof T]?: T[P]`**: Это тело нашего "цикла". Для каждого свойства `P` мы:
    - Объявляем свойство с тем же именем `P`.
    - Добавляем к нему знак **`?`**, делая его необязательным.
    - Указываем тип этого свойства как `T[P]`. Это **Lookup Type (тип-индекс)** — он извлекает тип свойства `P` из исходного типа `T`. Для `P="name"`, `T[P]` будет `string`.

**Итог:** `Partial<Person>` берет каждый ключ из `Person`, делает его необязательным и сохраняет его исходный тип. Результат — `{ name?: string; age?: number; }`.

---

### Часть 2: Conditional Types (Условные типы) и пример с `Exclude`

Автор переходит к условным типам:

> "This conditional type checks whether each property of t is assignable to u using the extends keyword..."

**Подробное объяснение:**

Условные типы позволяют выбирать один из двух типов на основе условия. Синтаксис: `SomeType extends OtherType ? TrueType : FalseType`. Это аналог тернарного оператора `condition ? a : b`, но для типов.

**Разбор реализации `Exclude` из видео:**

```typescript
type Exclude<T, U> = T extends U ? never : T;
```

`Exclude<T, U>` предназначен для исключения из типа `T` всех тех типов, которые можно присвоить типу `U`.

Давайте разберем на примере. Допустим, у нас есть юнион-тип: `T = "a" | "b" | "c"`. Мы хотим исключить из него тип `U = "a"`.

1.  **Как работает условие `extends` для юнион-типов?**
    TypeScript применяет **дистрибутивность (distributivity)**. Условный тип автоматически распределится на каждый член юниона. Наш `Exclude` будет вычислен так:
    ```typescript
    // Это не буквальный код, а иллюстрация процесса
    ("a" extends "a" ? never : "a") // -> never
    | ("b" extends "a" ? never : "b") // -> "b"
    | ("c" extends "a" ? never : "c") // -> "c"
    ```
2.  **Результат:** `never | "b" | "c"`.
3.  **Что такое `never`?** `never` в TypeScript — это тип, означающий "значения, которого никогда не существует". В контексте юнион-типа `never` автоматически "исчезает" (поскольку добавить его в юнион невозможно). Аналогично: `x | never` равно `x`.

    Таким образом, `never | "b" | "c"` упрощается до `"b" | "c"`.

**Итог:** Мы исключили `"a"` из исходного юниона. `Exclude<"a" | "b" | "c", "a">` равно `"b" | "c"`.

_Замечание:_ Автор в тексте немного упрощает, говоря "properties of T". `Exclude` работает не со свойствами объектов, а с типами внутри юнион-типов. Это распространенный способ фильтрации юнионов.

---

### Ключевые выводы, которые делает автор (и с которыми я полностью согласен)

1.  **Утилитарные типы — это абстракция.** Это готовые, протестированные "функции" для частых операций с типами. Вам не нужно помнить их сложную реализацию, достаточно знать, что делает `Partial` или `Exclude`.
2.  **Понимание устройства дает силу.** Зная, что внутри используются Mapped Types и Conditional Types, вы перестаете воспринимать систему типов TypeScript как черный ящик. Вы начинаете понимать ее логику.
3.  **Вы можете создавать свои утилиты.** Это самый мощный вывод. Поняв принципы, вы можете написать свои собственные утилитарные типы для специфичных задач в вашем проекте. Например, `type MakeAllPropsNullable<T> = { [P in keyof T]: T[P] | null }`.

Автор прав, если сейчас не все детали `Partial` и `Exclude` кажутся кристально чистыми — не переживайте. Главное — уловить общую концепцию: **"Utility Types = Mapped Types + Conditional Types"**.

Надеюсь, это объяснение было полезным. Жду следующего отрывка из курса
