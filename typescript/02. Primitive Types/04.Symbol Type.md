### Общее введение

Автор представляет Symbol — примитивный тип, который гарантирует **уникальность значения**. Символы часто используются как ключи свойств объектов и могут имитировать приватные свойства.

---

### 1. Создание символов

**Что такое Symbol?**
Symbol — это примитивный тип, главная особенность которого — гарантированная уникальность. Каждый созданный символ уникален, даже если он создан с одинаковым описанием.

**Создание символов в TypeScript:**

```typescript
let id: symbol = Symbol();
```

- `symbol` — это тип в TypeScript для аннотации символов
- `Symbol()` — конструктор, создающий новый уникальный символ

**Символы с описанием:**

```typescript
let alphabeticId: symbol = Symbol("1234");
```

- Строка `"1234"` — это **описание** (description) символа, используемое только для отладки
- Даже символы с одинаковым описанием будут разными:
  ```typescript
  let sym1 = Symbol("test");
  let sym2 = Symbol("test");
  console.log(sym1 === sym2); // false
  ```

**Важно:** Как и с BigInt, для использования Symbol нужна целевая версия ES2015 или выше в `tsconfig.json`.

---

### 2. Символы как "приватные" свойства объектов

#### Проблема, которую решают символы

В JavaScript нет настоящих приватных свойств в объектах (до недавнего времени). Символы предоставляют способ создавать свойства, которые сложно случайно получить или изменить.

#### Пример создания объекта с символьным свойством:

```typescript
const user = {
  name: "Mark",
  [id]: "1234", // Используем символ как ключ свойства
};
```

**Синтаксис квадратных скобок `[id]`:**

- Это **вычисляемое свойство** (computed property name)
- В качестве ключа используется значение переменной `id` (наш символ), а не строка "id"

---

### 3. Демонстрация "приватности"

**Прямой доступ не работает:**

```typescript
console.log(user.name); // "Mark" - работает
console.log(user.id); // undefined - не работает!
```

- Свойство `user.id` не существует, потому что наш ключ — это символ, а не строка "id"

**Почему это считается "приватным":**

- Чтобы получить доступ к свойству, нужно иметь ссылку на исходный символ
- При обычном переборе свойств объекта (`for...in`, `Object.keys()`) символьные свойства не показываются

**Как получить доступ к символьному свойству:**

```typescript
console.log(user[id]); // "1234" - работает!
```

Доступ возможен только если у вас есть исходный символ `id`.

---

### 4. Практическое использование: геттер для символа

Автор показывает, как создать метод для контролируемого доступа к символьному свойству:

```typescript
const user = {
  name: "Mark",
  [id]: "1234",

  // Метод для получения "приватного" свойства
  getId: function () {
    return this[id]; // Возвращаем значение по символьному ключу
  },
};

console.log(user.getId()); // "1234" - получаем значение через метод
```

**Почему это полезно:**

- Мы контролируем доступ к "приватным" данным
- Можем добавить дополнительную логику (валидацию, преобразования)
- Скрываем внутреннюю реализацию

---

### 5. Вывод символов в консоль

```typescript
console.log(id); // Выведет что-то вроде: Symbol()
console.log(alphabeticId); // Выведет: Symbol(1234)
```

При выводе символа показывается его описание (если оно было указано).

---

### Итог от автора

Автор подчеркивает, что символы:

1. Гарантируют уникальность
2. Могут использоваться как ключи свойств объектов
3. Создают иллюзию приватности (не настоящая приватность, а "скрытность")
4. Имеют строгую типизацию в TypeScript

### Мой итог как разработчика

Вы изучили важную концепцию, которая часто используется в продвинутом JavaScript/TypeScript:

1. **Уникальность:** Каждый символ уникален, даже созданные с одинаковым описанием.

2. **Использование как ключей:** Символы — единственный примитивный тип, который может использоваться как ключ в объектах (кроме строк).

3. **"Приватность":** Символьные свойства:

   - Не видны при обычном переборе (`for...in`, `Object.keys()`, `Object.getOwnPropertyNames()`)
   - Видны при использовании `Object.getOwnPropertySymbols()`
   - Доступны только если у вас есть ссылка на исходный символ

4. **Настоящая приватность в TypeScript:**

   - Важно понимать, что это не настоящая приватность, а "скрытность"
   - В современных классах TypeScript лучше использовать настоящие приватные поля с префиксом `#` или модификатором `private`

5. **Практические применения:**
   - Добавление "скрытых" метаданных к объектам
   - Создание уникальных идентификаторов
   - Избежание конфликтов имен свойств в библиотеках
   - Определение специальных методов (well-known symbols)

```typescript
// Пример: хорошо известные символы
const array = [1, 2, 3];
const iterator = array[Symbol.iterator](); // Использование встроенного символа
```

**Резюме:** Символы — мощный инструмент для создания уникальных идентификаторов и организации доступа к свойствам, но для настоящей приватности в классах лучше использовать современные возможности TypeScript.
