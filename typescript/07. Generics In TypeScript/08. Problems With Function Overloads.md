Отлично! В этом уроке автор демонстрирует, почему **перегрузка функций (function overloading)** не является оптимальным решением для создания полиморфных функций, и подготавливает нас к использованию дженериков. Давайте разберем это подробно.

## Попытка решения через перегрузку функций

Автор пытается создать тип `Filter` с помощью перегрузки:

```typescript
type Filter = {
  (array: number[], predicate: (item: number) => boolean): number[];
  (array: string[], predicate: (item: string) => boolean): string[];
  (array: object[], predicate: (item: object) => boolean): object[];
};
```

**Разберем первую сигнатуру:**

- `(array: number[], predicate: (item: number) => boolean): number[]`
- Если передаем массив чисел → предикат получает числа → возвращаем массив чисел

**Вторая сигнатура:**

- `(array: string[], predicate: (item: string) => boolean): string[]`
- Если передаем массив строк → предикат получает строки → возвращаем массив строк

---

## Проблемы подхода с перегрузкой

### 1. **Комбинаторный взрыв типов**

Автор показывает, что для каждого типа нужно писать отдельную сигнатуру:

```typescript
// Для чисел
(array: number[], predicate: (item: number) => boolean): number[];

// Для строк
(array: string[], predicate: (item: string) => boolean): string[];

// Для объектов
(array: object[], predicate: (item: object) => boolean): object[];

// А что с этими?
// Для boolean[]
// Для User[]
// Для Post[]
// И так до бесконечности...
```

**Проблема:** Невозможно предугадать все типы, которые могут понадобиться.

### 2. **Потеря специфичности типов объектов**

```typescript
type User = {
    id: number;
    name: string;
    email: string;
};

// В перегрузке мы можем указать только object[]
(array: object[], predicate: (item: object) => boolean): object[];

// Но тогда мы теряем информацию о конкретных свойствах User
```

**Что теряется:**

- Автодополнение для `user.name`, `user.email`
- Проверка типов для свойств объекта
- Возврат конкретного типа (не просто `object[]`, а `User[]`)

### 3. **Дублирование кода**

Каждая сигнатура по сути повторяет одну и ту же логику, но с разными типами:

```typescript
// Дублирование одинаковой логики с разными типами
(number[]) => number[]
(string[]) => string[]
(object[]) => object[]
```

---

## Почему перегрузка не работает для фильтра

### Функция `filter` по своей природе полиморфна:

```typescript
// Должна работать с ЛЮБЫМ типом массива
filter(users, (user) => user.age > 18); // User[]
filter(posts, (post) => post.published); // Post[]
filter(numbers, (num) => num > 0); // number[]
filter(arrays, (arr) => arr.length > 0); // any[][]
```

### Перегрузка требует явного перечисления:

```typescript
// Нужно заранее знать ВСЕ возможные типы
type Filter = {
  (array: User[], predicate: (item: User) => boolean): User[];
  (array: Post[], predicate: (item: Post) => boolean): Post[];
  (array: number[], predicate: (item: number) => boolean): number[];
  // ... и так для каждого типа
};
```

**Это невозможно**, потому что:

- Типы создаются в процессе разработки
- Сторонние библиотеки добавляют свои типы
- Generic-типы могут быть бесконечно сложными

---

## Конкретный пример проблемы

Допустим, у нас есть тип `User`:

```typescript
type User = {
  id: number;
  name: string;
  age: number;
};
```

### С перегрузкой:

```typescript
// ❌ Не можем создать сигнатуру для User[]
// Мы можем использовать только object[], но тогда:
const users: User[] = [...];
const result = filter(users, user => user.age > 18);
// result будет object[], а не User[]
// В предикате user будет object, а не User
```

### С дженериками (решение):

```typescript
// ✅ Одна сигнатура для всех случаев
type Filter = {
  <T>(array: T[], predicate: (item: T) => boolean): T[];
};

const result = filter(users, (user) => user.age > 18);
// result: User[]
// user в предикате: User
```

---

## Ментальная модель автора

Автор проводит нас через процесс мышления профессионального разработчика:

1. **Попробовать очевидное решение** — перегрузка функций
2. **Обнаружить limitations** — перегрузка не масштабируется
3. **Поиск лучшего решения** — дженерики как универсальный инструмент
4. **Принять решение** — отказаться от перегрузки в пользу дженериков

---

## Подготовка к решению с дженериками

Автор заканчивает урок, указывая на правильное направление:

> "That's why we need generics. So we are going to ditch function overloading. And in the next video we're going to see how instead of using function overloading we can use generics."

**Ключевые моменты для следующего урока:**

- Одна generic-сигнатура заменит бесконечное количество перегрузок
- Сохранится полная типобезопасность для любых типов
- Код станет проще и поддерживаемее

---

## Итог урока

Автор продемонстрировал важный урок на практике:

1. **Перегрузка функций имеет ограничения** — не подходит для по-настоящему полиморфных функций
2. **Проблема масштабируемости** — невозможно предугадать все типы заранее
3. **Потеря типобезопасности** — для объектов теряется информация о конкретных свойствах
4. **Необходимость дженериков** — как единственного корректного решения для таких случаев

**Фундаментальный вывод:** Когда функция должна работать с **любым типом** (а не с конкретным набором типов), дженерики — это единственно правильное решение в TypeScript.

Этот урок отлично показывает эволюцию мышления TypeScript-разработчика: от простых решений к более продвинутым и корректным!
