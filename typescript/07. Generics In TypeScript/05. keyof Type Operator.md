## Что такое оператор `keyof`?

**`keyof`** — это оператор TypeScript, который создает **объединение (union) всех ключей объекта**.

Проще говоря: он берет все свойства объекта и делает из них тип-объединение.

---

## Базовый пример с `keyof`

Автор начинает с создания типа `Events`:

```typescript
type Events = {
  id: number;
  date: Date;
  type: "indoor" | "outdoor";
};
```

Теперь используем `keyof`:

```typescript
type UnionOfKeysOfEvents = keyof Events;
```

**Что происходит:**

- TypeScript анализирует тип `Events`
- Берет все его ключи: `"id"`, `"date"`, `"type"`
- Создает union-тип: `"id" | "date" | "type"`

**Практическая проверка:**

```typescript
let idOfEvents: UnionOfKeysOfEvents = "id"; // ✅
let dateOfEvents: UnionOfKeysOfEvents = "date"; // ✅
let typeOfEvents: UnionOfKeysOfEvents = "type"; // ✅

let someOfEvents: UnionOfKeysOfEvents = "some"; // ❌ Ошибка!
// Type '"some"' is not assignable to type 'keyof Events'
```

---

## `keyof` с индексными сигнатурами

### Случай 1: Числовые ключи

```typescript
type Numeric = {
  [key: number]: string;
};

type NumericKeyOf = keyof Numeric;
// Результат: type NumericKeyOf = number
```

**Почему?** Потому что все ключи в этом объекте — числа, поэтому их объединение — просто `number`.

### Случай 2: Строковые ключи

```typescript
type NumberAndString = {
  [key: string]: string;
};

type NumberAndStringKeyOf = keyof NumberAndString;
// Результат: type NumberAndStringKeyOf = string | number
```

**Почему так?** Автор объясняет важное поведение JavaScript:

> "Object keys in JavaScript are always coerced to string, even if they are numbers"

**Пример из JavaScript:**

```javascript
const obj = {};
obj[0] = "first"; // Ключ 0 преобразуется в "0"
obj["1"] = "second"; // Ключ "1" остается строкой

console.log(obj[0]); // "first" - но под капотом это obj["0"]
console.log(obj["0"]); // "first" - тот же результат
```

TypeScript учитывает это поведение и для строковых индексных сигнатур включает в `keyof` и `string`, и `number`.

---

## Мощная комбинация: `keyof` + Дженерики

Автор показывает практическое применение — создание Partial-типов.

### Исходный тип:

```typescript
type Person = {
  name: string;
  age: string;
  address: string;
};
```

### Задача:

Создать тип `PartialPerson`, где все свойства становятся необязательными.

### Решение с `keyof` и дженериками:

```typescript
type PartialPerson = {
  [K in keyof Person]?: Person[K] | null;
};
```

**Разберем эту конструкцию по частям:**

1. **`[K in keyof Person]`** — "для каждого ключа `K` в объединении ключей `Person`"

   - `keyof Person` создает: `"name" | "age" | "address"`
   - `K` последовательно принимает значения: `"name"`, `"age"`, `"address"`

2. **`?:`** — делает каждое свойство необязательным

3. **`Person[K] | null`** — "тип значения берется из оригинального `Person` для ключа `K`, или может быть `null`"
   - Для `K = "name"`: `Person["name"]` = `string`
   - Для `K = "age"`: `Person["age"]` = `string`
   - И добавляем `| null` к каждому

**Результат:**

```typescript
type PartialPerson = {
  name?: string | null;
  age?: string | null;
  address?: string | null;
};
```

**Использование:**

```typescript
const partial: PartialPerson = {
  name: "John", // только name - допустимо
};
```

---

## Почему это лучше чем просто добавить `?`

Автор объясняет преимущество:

> "While creating this user inside a database, you might need all these properties, but you might also need a partial person where you're just retrieving or sending back partial information"

**Разные сценарии:**

- **Полный объект** — для создания записи в базе данных
- **Partial объект** — для обновления или частичного отображения данных

---

## Альтернатива без `null`

Если не нужно разрешать `null`, можно написать так:

```typescript
type PartialPerson = {
  [K in keyof Person]?: Person[K];
};
// Результат: свойства optional, но без null
```

---

## Как это работает "под капотом"

### Lookup Types (типы-поиски)

Конструкция `Person[K]` называется **Lookup Type** — TypeScript "заглядывает" в тип `Person` и берет тип свойства с ключом `K`.

### Mapped Types (сопоставленные типы)

Конструкция `[K in keyof T]` создает **Mapped Type** — он проходит по всем ключам исходного типа и преобразует их.

---

## Итог урока

Автор показал три основных аспекта `keyof`:

1. **Базовое использование** — создание union-типа из ключей объекта

   ```typescript
   type Keys = keyof { a: number; b: string }; // "a" | "b"
   ```

2. **С индексными сигнатурами** — особенности поведения с числовыми и строковыми ключами

   ```typescript
   type A = keyof { [key: number]: string }; // number
   type B = keyof { [key: string]: string }; // string | number
   ```

3. **Комбинация с дженериками** — создание производных типов
   ```typescript
   type Partial<T> = { [K in keyof T]?: T[K] };
   ```

**Ключевая идея:** `keyof` — это мост между типами объектов и union-типами, который открывает мощные возможности для метапрограммирования на уровне типов в TypeScript.

Это фундаментальный оператор, который активно используется в продвинутых TypeScript-шаблонах!
