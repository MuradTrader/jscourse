## Проблема: Разные объекты с одинаковой структурой

Автор начинает с двух объектов, которые имеют одинаковую структуру, но разные типы:

```typescript
// Объект 1: ключ-строка, значение-число
const stringNumberPair = {
  key: "age",
  value: 30,
};

// Объект 2: ключ-число, значение-массив строк
const numberArrayPair = {
  key: 1234,
  value: ["hello", "world"],
};
```

**Что общего у этих объектов:**

- Оба имеют свойства `key` и `value`
- Оба имеют одинаковую структуру

**В чем проблема:**

- Типы `key` и `value` разные
- Нужен универсальный тип, который может работать с разными комбинациями типов

---

## Решение: Дженерики для объектов

Автор создает универсальный тип с двумя дженерик-параметрами:

```typescript
type KeyValuePair<K, V> = {
  key: K;
  value: V;
};
```

**Разберем эту запись:**

- `<K, V>` - два дженерик-параметра: `K` для ключа, `V` для значения
- `key: K` - свойство `key` будет типа `K`
- `value: V` - свойство `value` будет типа `V`

**Применение на практике:**

```typescript
// Теперь можно типизировать объекты конкретными типами:
const stringNumberPair: KeyValuePair<string, number> = {
  key: "age",
  value: 30,
};

const numberArrayPair: KeyValuePair<number, string[]> = {
  key: 1234,
  value: ["hello", "world"],
};
```

---

## Почему это лучше чем `any`?

Автор подчеркивает важность: использование `any` разрушило бы типобезопасность:

```typescript
// ❌ ПЛОХО: теряем информацию о типах
type BadKeyValuePair = {
  key: any;
  value: any;
};

// ✅ ХОРОШО: сохраняем точную информацию о типах
type GoodKeyValuePair<K, V> = {
  key: K;
  value: V;
};
```

**Преимущество дженериков:** TypeScript знает точные типы и может проверять их на этапе компиляции.

---

## Ограничения дженериков с объектами

Теперь автор показывает, как применять ограничения (`extends`) с объектами.

### Создание базового типа-ограничения:

```typescript
type HasId = {
  id: number;
};
```

Этот тип описывает любой объект, который должен иметь свойство `id: number`.

### Создание функции с ограничением:

```typescript
function printId<T extends HasId>(obj: T): void {
  console.log(obj.id);
}
```

**Разберем синтаксис:**

- `<T extends HasId>` - "тип `T` должен соответствовать типу `HasId`"
- `obj: T` - параметр должен быть типа `T`
- Функция может обращаться к `obj.id`, потому что гарантировано, что у `T` есть свойство `id`

---

## Практические примеры с ограничениями

### ✅ Корректное использование:

```typescript
const user = {
  id: 1,
  name: "John",
};

printId(user); // ✅ Работает - у user есть id
```

### ❌ Некорректное использование:

```typescript
const product = {
  name: "laptop",
};

printId(product); // ❌ Ошибка! У product нет id
```

### ✅ Исправление ошибки:

```typescript
const product = {
  id: 100, // Добавляем обязательное свойство
  name: "laptop",
};

printId(product); // ✅ Теперь работает
```

---

## Что происходит "под капотом"?

### Без ограничения (проблема):

```typescript
function printId(obj: any): void {
  console.log(obj.id); // ❌ Может быть ошибкой в runtime
}
```

### С ограничением (решение):

```typescript
function printId<T extends HasId>(obj: T): void {
  console.log(obj.id); // ✅ TypeScript гарантирует, что id существует
}
```

**TypeScript делает три вещи:**

1. **Проверяет на этапе компиляции**, что передаваемый объект имеет `id`
2. **Предоставляет автодополнение** для свойства `id`
3. **Знает точный тип** `id` (в данном случае `number`)

---

## Расширенные возможности

Ограничения могут быть более сложными:

```typescript
// Ограничение несколькими свойствами
type HasIdAndName = {
  id: number;
  name: string;
};

function processUser<T extends HasIdAndName>(user: T): void {
  console.log(`User ${user.name} has ID: ${user.id}`);
}
```

---

## Сравнение с предыдущими уроками

| Контекст        | Синтаксис                    | Пример                         |
| --------------- | ---------------------------- | ------------------------------ |
| **Функции**     | `<T>(param: T) => T`         | Универсальные функции          |
| **Массивы**     | `<T>(arr: T[]) => T`         | Работа с массивами любого типа |
| **Объекты**     | `<K, V>{ key: K, value: V }` | Универсальные структуры данных |
| **Ограничения** | `<T extends Constraint>`     | Гарантии о свойствах типа      |

---

## Итог урока

Автор показал два основных способа использования дженериков с объектами:

1. **Универсальные типы объектов** - создание гибких структур данных, которые могут работать с разными типами свойств

   ```typescript
   type KeyValuePair<K, V> = { key: K; value: V };
   ```

2. **Ограничения дженериков** - гарантии того, что объекты имеют определенные свойства
   ```typescript
   function process<T extends HasId>(obj: T) { ... }
   ```

**Ключевая идея:** Дженерики с объектами позволяют создавать переиспользуемые, типобезопасные структуры данных, которые адаптируются к конкретным типам, сохраняя при этом все преимущества статической типизации.

Это фундаментальный паттерн, который широко используется в реальных TypeScript-приложениях для создания гибких и безопасных API!
