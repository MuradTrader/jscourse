Отлично! В этом уроке автор переходит к практической реализации дженериков на примере создания собственной функции `filter`. Давайте разберем всё максимально подробно.

## Введение: Что такое метод `filter` в JavaScript

Автор начинает с объяснения встроенного метода `filter`:

```javascript
const ages = [16, 25, 18, 21];
const adults = ages.filter((age) => age > 18);
// Результат: [25, 21]
```

**Ключевые концепции:**

- **Predicate (предикат)** — функция, которая возвращает `true` или `false`
- **Фильтрация** — создание нового массива только с элементами, для которых предикат вернул `true`
- **Итерация** — метод перебирает каждый элемент массива

---

## Создание собственной функции `filter`

### Шаг 1: Объявление функции без типов

```typescript
const filter = (array, predicate) => {
  let result = [];
  for (let i = 0; i < array.length; i++) {
    let item = array[i];
    if (predicate(item)) {
      result.push(item);
    }
  }
  return result;
};
```

**Проблема:** Без типов TypeScript не может проверить корректность использования.

### Шаг 2: Добавление базовых типов (пока без дженериков)

```typescript
const filter = (array: any[], predicate: (item: any) => boolean): any[] => {
  let result: any[] = [];
  for (let i = 0; i < array.length; i++) {
    let item = array[i];
    if (predicate(item)) {
      result.push(item);
    }
  }
  return result;
};
```

**Разберем типы:**

- `array: any[]` — массив любых элементов
- `predicate: (item: any) => boolean` — функция, принимающая любой элемент и возвращающая boolean
- `: any[]` — функция возвращает массив любых элементов

---

## Тестирование реализации

### Пример 1: Фильтрация чисел

```typescript
const numbers = [5, 10, 15, 3, 8];
const predicateNumbers = (item: number) => {
  return item > 7;
};

console.log(filter(numbers, predicateNumbers));
// Ожидаемый результат: [10, 15, 8]
```

### Пример 2: Фильтрация строк

```typescript
const animals = ["cat", "dog", "rat"];
const filterCat = (item: string) => {
  return item === "cat";
};

console.log(filter(animals, filterCat));
// Ожидаемый результат: ["cat"]
```

---

## Анализ текущей реализации

### Что работает хорошо:

- Функция действительно **полиморфна** — работает с любыми типами массивов
- Логика корректна — фильтрует элементы по условию

### Проблемы типобезопасности:

1. **Потеря информации о типах:**

   ```typescript
   const numbers = [1, 2, 3];
   const filtered = filter(numbers, (n) => n > 1);
   // filtered имеет тип any[], а не number[]
   ```

2. **Нет проверки совместимости типов:**

   ```typescript
   const numbers = [1, 2, 3];
   const wrongPredicate = (item: string) => item === "hello";
   // ❌ Должна быть ошибка, но TypeScript не проверяет
   ```

3. **Отсутствует автодополнение** в предикате

---

## Почему это "полиморфная" функция

Автор подчеркивает важное свойство:

> "This function is polymorphic because it can be used along with any type of an array"

**Полиморфизм** — способность функции работать с разными типами данных, сохраняя одну и ту же логику.

---

## Подготовка к улучшению

Автор указывает на два подхода, которые будут рассмотрены далее:

1. **Перегрузка функций (Function Overloads)** — объявление нескольких сигнатур для одной функции
2. **Дженерики (Generics)** — универсальное решение для полиморфных функций

### Сравнение подходов:

| Подход         | Преимущества                        | Недостатки                         |
| -------------- | ----------------------------------- | ---------------------------------- |
| **Перегрузка** | Явное описание всех вариантов       | Дублирование кода для каждого типа |
| **Дженерики**  | Универсальность, переиспользуемость | Более абстрактный синтаксис        |

---

## Как работает текущая реализация "под капотом"

### Алгоритм функции `filter`:

1. **Инициализация** — создание пустого массива `result`
2. **Итерация** — цикл по всем элементам исходного массива
3. **Проверка** — вызов предиката для каждого элемента
4. **Добавление** — если предикат вернул `true`, элемент добавляется в результат
5. **Возврат** — возврат отфильтрованного массива

### Визуализация для чисел `[5, 10, 15, 3, 8]`:

```
Элемент: 5 → predicate(5) = false → пропускаем
Элемент: 10 → predicate(10) = true → добавляем
Элемент: 15 → predicate(15) = true → добавляем
Элемент: 3 → predicate(3) = false → пропускаем
Элемент: 8 → predicate(8) = true → добавляем
Результат: [10, 15, 8]
```

---

## Практическое значение

Автор создал упрощенную, но рабочую версию реального JavaScript метода. Это помогает понять:

1. **Как работают встроенные методы массива**
2. **Почему полиморфизм важен** — одна функция для многих типов
3. **Ограничения TypeScript без дженериков** — потеря типобезопасности

---

## Итог урока

Автор показал:

1. **Практическую реализацию** функции `filter` на TypeScript
2. **Проблемы подхода с `any`** — потеря информации о типах
3. **Демонстрацию полиморфизма** — одна функция работает с разными типами
4. **Подготовку к решению** — указание на два подхода (перегрузки и дженерики)

**Ключевая мысль:** Функция работает корректно с точки зрения логики, но не оптимально с точки зрения TypeScript — она теряет информацию о типах, которую можно сохранить с помощью дженериков.

В следующем видео автор покажет, как улучшить эту реализацию с помощью перегрузки функций и дженериков, чтобы сохранить полиморфизм, но при этом получить полную типобезопасность!
