## Общее введение

Автор обсуждает **иерархию типов** — концепцию, которая помогает понять, как типы соотносятся друг с другом в TypeScript. Понимание этой иерархии критически важно для эффективной работы с типами.

---

## 1. Основные принципы иерархии типов

### Движение по иерархии:

- **Вниз** → к более **строгим** (конкретным) типам
- **Вверх** → к более **либеральным** (общим) типам

### Примеры отношений:

```typescript
// any более либерален, чем string
let a: any = "hello"; // Может быть чем угодно
let b: string = "hello"; // Только строка

// string более либерален, чем строковый enum
type StringEnum = "A" | "B" | "C";
let c: string = "anything"; // Любая строка
let d: StringEnum = "A"; // Только "A", "B" или "C"

// object более либерален, чем array
let e: object = { key: "value" }; // Любой объект
let f: string[] = ["a", "b"]; // Только массив строк

// array более либерален, чем tuple
let g: string[] = ["a", "b"]; // Любой массив строк
let h: [string, number] = ["a", 1]; // Строго 2 элемента: string и number
```

---

## 2. Верхние типы в иерархии

### Пять верхних типов:

1. **`any`** — самый либеральный тип
2. **`unknown`** — безопасная альтернатива `any`
3. **`void`** — отсутствие возвращаемого значения
4. **`undefined`** — неопределенное значение
5. **`null`** — явное отсутствие значения

**Важно:** Только `undefined` и `null` являются примитивами JavaScript. Остальные — TypeScript-специфичные типы.

---

## 3. Тип `never` — самый строгий тип

`never` представляет тип значений, которые **никогда не возникают**.

### Примеры использования `never`:

```typescript
// Функция, которая всегда выбрасывает ошибку
const throwError = (errorMessage: string): never => {
  throw new Error(errorMessage);
};

// Функция, которая никогда не завершается
const infiniteLoop = (): never => {
  while (true) {
    // Бесконечный цикл
  }
};
```

**TypeScript автоматически выводит `never`** для функций, которые никогда не завершаются нормально.

---

## 4. Отношения "родитель-потомок" в иерархии

### Концепция подтипов:

- **Подтип** (subtype) — более конкретный тип
- **Супертип** (supertype) — более общий тип
- Подтип **расширяет** (extends) супертип

### Проверка отношений с помощью условных типов:

```typescript
// any extends unknown?
type Check1 = any extends unknown ? true : false; // true

// string extends any?
type Check2 = string extends any ? true : false; // true

// null extends any?
type Check3 = null extends any ? true : false; // true

// undefined extends void?
type Check4 = undefined extends void ? true : false; // true

// Array extends object?
type Check5 = Array<any> extends object ? true : false; // true

// Function extends object?
type Check6 = Function extends object ? true : false; // true
```

---

## 5. Практическое значение иерархии

### Возможность использования супертипов вместо подтипов:

```typescript
// Массив строк (строгий тип)
let strings: string[] = ["a", "b", "c"];

// Но можно использовать object (либеральный тип), так как array extends object
let stringsAsObject: object = ["a", "b", "c"];

// Функция (строгий тип)
let myFunction: Function = () => 2;

// Но можно использовать object (либеральный тип), так как Function extends object
let myFunctionAsObject: object = () => 2;
```

### Почему это работает, но не рекомендуется:

- **TypeScript позволяет это**, потому что это типобезопасно
- **Но не следует злоупотреблять** — теряются преимущества строгой типизации
- **Всегда используйте наиболее подходящий тип**

---

## 6. Визуальное представление иерархии (упрощенное)

```
unknown (самый либеральный)
    │
    ├── any
    │     │
    │     ├── string
    │     │     └── "literal" (строковые литералы)
    │     │
    │     ├── number
    │     │     └── 42 (числовые литералы)
    │     │
    │     ├── boolean
    │     │     └── true (булевы литералы)
    │     │
    │     ├── object
    │     │     ├── Array
    │     │     │     └── Tuple
    │     │     └── Function
    │     │
    │     ├── void
    │     │     └── undefined
    │     │
    │     └── null
    │
    └── never (самый строгий)
```

---

## 7. Ключевые выводы об иерархии

### A. Совместимость типов:

```typescript
// Подтип может быть присвоен супертипу (безопасно)
let supertype: any;
let subtype: string = "hello";
supertype = subtype; // ✅ OK

// Супертип не может быть присвоен подтипу (опасно)
let subtype2: string;
let supertype2: any = 123;
subtype2 = supertype2; // ❌ Ошибка только с strictNullChecks
```

### B. Правило использования типов:

> "Всегда используйте наиболее строгий тип, который точно описывает ваши данные"

### C. Исключения:

- При миграции с JavaScript
- При работе с динамическими данными
- В универсальных утилитах и библиотеках

---

## Итог от автора

Автор подчеркивает:

1. **Иерархия типов** — фундамент системы типов TypeScript
2. **Движение вниз** — к более строгим типам, **вверх** — к более либеральным
3. **`never`** — самый строгий тип для "невозможных" значений
4. **Подтипы расширяют супертипы** — это основа совместимости типов
5. **Используйте строгие типы** там, где это возможно

### Мой итог как разработчика

Вы изучили одну из самых важных концепций TypeScript:

1. **Философская основа:** TypeScript — это структурная система типов, где совместимость определяется иерархией, а не явными декларациями.

2. **Практическое применение иерархии:**

   - **Type Narrowing** — сужение типов основано на иерархии
   - **Function Overloading** — зависит от отношений типов
   - **Generic Constraints** — используют `extends` для ограничений
   - **Type Compatibility** — определяет, что можно присваивать чему

3. **Профессиональные практики:**

   ```typescript
   // ❌ ПЛОХО - слишком либерально
   function process(data: any) { ... }

   // ✅ ХОРОШО - баланс безопасности и гибкости
   function process(data: unknown) {
       if (typeof data === 'string') {
           // Сужение типа
       }
   }

   // ✅ ЛУЧШЕ - максимальная типобезопасность
   function process(data: string) { ... }
   ```

4. **Понимание ошибок компилятора:**

   - "Type 'X' is not assignable to type 'Y'" — нарушение иерархии
   - "Property 'Z' does not exist on type 'X'" — слишком общий тип

5. **Подготовка к продвинутым темам:**
   - **Ковариантность/контравариантность** в функциях
   - **Типы высшего порядка** (higher-kinded types)
   - **Условные типы** с распределением

**Резюме:** Иерархия типов — это не просто академическая концепция, а практический инструмент для написания безопасного и поддерживаемого кода. Понимание того, как типы соотносятся друг с другом, позволяет предсказывать поведение TypeScript и эффективно использовать его сильные стороны.
