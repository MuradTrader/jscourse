### Общее введение

Автор представляет тип `unknown` — эксклюзивный тип TypeScript (отсутствующий в JavaScript), который является **более безопасной альтернативой типу `any`**. Основная идея: когда тип значения неизвестен в момент объявления, но может быть определен позже.

---

### 1. Проблема с типом `any`

**Исходный пример с `any`:**

```typescript
function multiplyByTwo(number: any) {
  return number * 2;
}
```

**Проблемы подхода с `any`:**

- Можно передать ЛЮБОЙ тип данных: `string`, `array`, `object`, `null`, `undefined`
- TypeScript не предоставляет никакой защиты от ошибок типов
- В runtime могут происходить непредсказуемые ошибки:
  ```typescript
  multiplyByTwo("hello"); // Вернет NaN (не число)
  multiplyByTwo([1, 2]); // Вернет "1,21,2" (странное поведение)
  ```

---

### 2. Введение типа `unknown`

**Замена `any` на `unknown`:**

```typescript
function multiplyByTwo(number: unknown) {
  return number * 2; // ОШИБКА TypeScript!
}
```

**Что происходит:**

- TypeScript сразу сообщает об ошибке: "Object is of type 'unknown'"
- **Ключевое отличие от `any`:** TypeScript НЕ позволяет выполнять операции со значениями типа `unknown` без предварительной проверки типов
- Это защищает от случайных ошибок времени выполнения

---

### 3. Правильная работа с `unknown` — сужение типов

**Решение: проверка типа перед использованием**

```typescript
function multiplyByTwo(number: unknown) {
  if (typeof number === "number") {
    return number * 2; // Теперь TypeScript знает, что number - число
  }
  return "Please provide a valid number";
}
```

**Как это работает:**

1. **`typeof number === 'number'`** — это проверка типа во время выполнения (runtime type check)
2. TypeScript анализирует эту проверку и **сужает тип** `unknown` до `number` внутри блока `if`
3. Теперь операция умножения разрешена, так как TypeScript уверен в типе

**Механизм "сужения типов" (Type Narrowing):**

- TypeScript отслеживает проверки типов в коде
- После проверки `typeof number === 'number'` TypeScript "запоминает", что в этой области видимости `number` имеет тип `number`
- Это называется **control flow analysis**

---

### 4. Практическая демонстрация

**Тестирование функции:**

```typescript
console.log(multiplyByTwo(4)); // 8
console.log(multiplyByTwo("hello")); // "Please provide a valid number"
```

**Преимущества подхода:**

- Предсказуемое поведение для всех входных данных
- Ясные сообщения об ошибках
- Защита от непредвиденных ошибок времени выполнения

---

### 5. Когда использовать `unknown` вместо конкретных типов

**Важное замечание автора:** В данном примере лучше было бы сразу использовать `number`:

```typescript
function multiplyByTwo(number: number): number {
  return number * 2;
}
```

**Реальные сценарии для `unknown`:**

- Данные из внешних источников (API, файлы, пользовательский ввод)
- Динамически создаваемые значения
- Работа с библиотеками, возвращающими данные неизвестного типа
- Ситуации, когда тип определяется в процессе выполнения программы

---

### Итог от автора

Автор подчеркивает:

1. **`unknown` безопаснее `any`** — требует проверки типов перед использованием
2. **TypeScript защищает от операций с `unknown`** без предварительной проверки
3. **Используйте сужение типов** через `typeof` и другие проверки для работы с `unknown`
4. **В идеале используйте конкретные типы**, когда они известны

### Мой итог как разработчика

Вы изучили важнейшую концепцию TypeScript — тип `unknown` и сужение типов:

1. **Иерархия безопасности типов:**

   - `any` ❌ (опасно — нет проверки)
   - `unknown` ✅ (безопасно — требует проверки)
   - `конкретный_тип` ✅✅ (идеально — максимальная безопасность)

2. **Стратегия работы с `unknown`:**

   ```typescript
   function handleUnknown(value: unknown) {
     // 1. Проверяем тип
     if (typeof value === "string") {
       // 2. TypeScript автоматически сужает тип
       console.log(value.toUpperCase()); // Безопасно!
     }
     // 3. Обрабатываем другие возможные типы
   }
   ```

3. **Методы сужения типов для `unknown`:**

   - `typeof` — для примитивов
   - `instanceof` — для классов
   - Проверки на `null`/`undefined`
   - Пользовательские type guards (будут рассмотрены позже)

4. **Практическое применение:**

   ```typescript
   // Данные из API — тип неизвестен заранее
   async function fetchData(): Promise<unknown> {
     const response = await fetch("/api/data");
     return response.json();
   }

   // Обработка с проверкой типа
   const data = await fetchData();
   if (typeof data === "object" && data !== null && "users" in data) {
     // Теперь мы знаем структуру данных
     console.log(data.users);
   }
   ```

5. **Философский аспект:** TypeScript поощряет явное описание намерений через типы. `unknown` — это честное признание "я не знаю тип, но обещаю его проверить", в то время как `any` — это "мне всё равно, оставьте меня в покое".

**Резюме:** `unknown` — это мост между нетипизированным JavaScript и строгой системой типов TypeScript. Используйте его осознанно, когда тип действительно неизвестен, и всегда проверяйте перед использованием.
