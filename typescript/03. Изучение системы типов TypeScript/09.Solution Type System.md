## Обзор упражнения

Это практическое задание на закрепление понимания:

- Вывода типов (type inference)
- Литеральных типов (literal types)
- Приведения типов (type casting)
- Условных типов (conditional types)
- Проверки совместимости типов

---

## 1. Анализ объявлений переменных

### Строка 1: `let city = 'New York';`

```typescript
let city = "New York";
// TypeScript выводит: string
```

**Объяснение:** TypeScript видит строковое значение и выводит общий тип `string`.

### Строка 2: `let population = 8491079;`

```typescript
let population = 8491079;
// TypeScript выводит: number
```

**Объяснение:** Числовое значение → тип `number`.

### Строка 3: `const age = 32;`

```typescript
const age = 32;
// TypeScript выводит: 32 (литеральный тип)
```

**Объяснение:** Для `const` TypeScript использует литеральный тип, так как значение никогда не изменится.

### Строка 4: `let oldAge = 79 as const;`

```typescript
let oldAge = 79 as const;
// TypeScript выводит: 79 (литеральный тип)
```

**Объяснение:** `as const` утверждает литеральный тип, даже для `let`.

### Строка 5: `let newAge = oldAge;`

```typescript
let newAge = oldAge;
// TypeScript выводит: 79 (литеральный тип)
```

**Объяснение:** TypeScript следует за типом исходной переменной.

### Строка 6: `let data = new Map();`

```typescript
let data = new Map();
// TypeScript выводит: Map<unknown, unknown>
```

**Объяснение:** TypeScript выводит обобщенный тип Map, так как не указаны типы ключей и значений.

### Строка 7: `let score = [1, 2, 3];`

```typescript
let score = [1, 2, 3];
// TypeScript выводит: number[]
```

**Объяснение:** Массив чисел → тип `number[]`.

---

## 2. Анализ объявлений типов

### Строка 8: `type Primitive = string | number | boolean;`

```typescript
type Primitive = string | number | boolean;
// Объединение трех примитивных типов
```

### Строка 9: Условный тип `CustomName`

```typescript
type CustomName = "John" extends string ? string : "John";
// Результат: string
```

**Объяснение:** Условие истинно, так как строковый литерал `'John'` расширяет тип `string`.

### Строка 10: Условный тип `CustomAge`

```typescript
type CustomAge = typeof newAge extends number ? 79 : number;
// Результат: 79
```

**Объяснение:**

- `typeof newAge` = `79` (литеральный тип)
- `79 extends number` = `true` (литеральный тип является подтипом number)
- Результат: `79`

### Строка 11: Условный тип `CheckData`

```typescript
type CheckData = typeof data extends object ? true : false;
// Результат: true
```

**Объяснение:**

- `Map` является подтипом `object`
- Условие истинно → результат `true`

### Строка 12: Условный тип `CheckScore`

```typescript
type CheckScore = typeof score extends never ? never : [];
// Результат: [] (пустой кортеж)
```

**Объяснение:**

- `number[]` НЕ расширяет `never`
- Условие ложно → результат `[]`

---

## 3. Проверка операций на ошибки

### Строка 13: `age = 85;`

```typescript
age = 85; // ❌ ОШИБКА
```

**Причина:** `age` объявлен как `const` с литеральным типом `32`. Переприсваивание невозможно.

### Строка 14: `score.push(10);`

```typescript
score.push(10); // ✅ УСПЕХ
```

**Причина:** `score` имеет тип `number[]`, поэтому добавление числа разрешено.

### Строка 15: `score.push('10');`

```typescript
score.push("10"); // ❌ ОШИБКА
```

**Причина:** Нельзя добавить строку в массив чисел.

### Строка 16: `let customAge: CustomAge = 50;`

```typescript
let customAge: CustomAge = 50; // ❌ ОШИБКА
```

**Причина:** `CustomAge` имеет литеральный тип `79`, а не общий `number`.

### Строка 17: `let primitive: Primitive = new Date();`

```typescript
let primitive: Primitive = new Date(); // ❌ ОШИБКА
```

**Причина:** `Date` не входит в объединение `string | number | boolean`.

### Строка 18: `let years: CheckScore = [];`

```typescript
let years: CheckScore = []; // ✅ УСПЕХ
```

**Причина:** `CheckScore` = `[]`, что совместимо с пустым массивом.

---

## 4. Ключевые выводы из упражнения

### A. Литеральные типы и `const`:

```typescript
const x = 5; // тип: 5 (литеральный)
let y = 5 as const; // тип: 5 (литеральный, даже с let)
```

### B. Иерархия типов в действии:

```typescript
79 extends number    // true - литеральный тип ⊂ number
Map extends object   // true - Map ⊂ object
number[] extends never // false - массив не ⊂ never
```

### C. Условные типы как фильтры:

```typescript
// Условные типы проверяют отношения в иерархии
type Test<T> = T extends U ? TrueType : FalseType;
```

### D. Практическая типизация:

- TypeScript предотвращает несовместимые операции
- Литеральные типы обеспечивают дополнительную безопасность
- Условные типы позволяют создавать "интеллектуальные" типы

---

## Итог от автора

Автор демонстрирует, что понимание системы типов TypeScript позволяет:

1. **Предсказывать поведение** компилятора
2. **Находить ошибки** на этапе разработки
3. **Создавать более надежный** код
4. **Использовать продвинутые возможности** системы типов

### Мой итог как разработчика

Это упражнение прекрасно демонстрирует мощь TypeScript:

1. **Проактивная безопасность:** TypeScript не просто указывает на ошибки, а предотвращает целые классы проблем.

2. **Глубокая интеграция типов:** Система типов пронизывает все аспекты языка — от переменных до сложных условных типов.

3. **Практическая ценность навыков:**

   - Умение читать вывод типов — ключ к пониманию чужого кода
   - Знание иерархии типов помогает в рефакторинге
   - Условные типы — основа для создания reusable type utilities

4. **Эволюция мышления:** От "TypeScript показывает ошибки" к "TypeScript помогает проектировать корректные системы".

5. **Подготовка к реальным сценариям:**
   ```typescript
   // Похожие проверки встречаются в реальных проектах
   type ApiResponse<T> = T extends Error ? never : { data: T };
   type Validator<T> = T extends invalid ? never : T;
   ```

**Резюме:** Это упражнение — отличный тест на понимание фундаментальных концепций TypeScript. Если вы смогли пройти его самостоятельно или поняли объяснение — вы хорошо усвоили основы системы типов и готовы к более сложным темам.
