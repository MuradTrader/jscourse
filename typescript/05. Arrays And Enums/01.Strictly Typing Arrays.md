## Общее введение

Автор переходит от объектов к массивам и показывает, как TypeScript обеспечивает типобезопасность при работе с коллекциями данных.

---

## 1. Базовые способы типизации массивов

### Синтаксис 1: Literal syntax (рекомендуется)

```typescript
let a: number[] = [1, 2, 3];
```

**Разбор синтаксиса:**

- `number` — тип элементов массива
- `[]` — указывает, что это массив
- Результат: массив, содержащий только числа

### Синтаксис 2: Generic syntax (альтернативный)

```typescript
let b: Array<string> = ["a", "b", "c"];
```

**Разбор синтаксиса:**

- `Array` — встроенный тип TypeScript для массивов
- `<string>` — тип элементов в угловых скобках
- Результат: тот же самый — массив строк

---

## 2. Сравнение двух синтаксисов

### Эквивалентность:

```typescript
// Оба способа дают одинаковый результат
let numbers1: number[] = [1, 2, 3];
let numbers2: Array<number> = [1, 2, 3];

let strings1: string[] = ["a", "b", "c"];
let strings2: Array<string> = ["a", "b", "c"];
```

### Рекомендация автора:

- **Предпочтительнее** `number[]` синтаксис
- **Причина**: более читаемый и меньше путаницы с дженериками

---

## 3. Массивы с объединенными типами (Union types)

### Массивы с несколькими типами элементов:

```typescript
let c: (string | number)[] = [1, "hello", 2, "world"];
```

**Разбор синтаксиса:**

- `(string | number)` — объединение типов в скобках
- `[]` — применяется ко всему объединению
- Результат: массив, который может содержать и строки, и числа

### Расширение с дополнительными типами:

```typescript
let d: (string | number | boolean)[] = [1, "hello", true, 2, false];
```

**Важное замечание автора:**

> "В реальном программировании вы обычно не хотите этого делать, но в TypeScript это возможно"

---

## 4. Массивы объектов

### Использование существующего типа:

```typescript
// Предположим, у нас есть тип Airplane
type Airplane = {
  model: string;
  capacity: number;
  year: number;
};

// Массив объектов Airplane
type Airplanes = Airplane[];
```

### Альтернативный синтаксис:

```typescript
// То же самое, но с generic синтаксисом
type Airplanes = Array<Airplane>;
```

### Создание и использование:

```typescript
let airplanes: Airplanes = [
  {
    model: "Boeing 737",
    capacity: 180,
    year: 2020,
  },
  {
    model: "Airbus A320",
    capacity: 150,
    year: 2019,
  },
];
```

---

## 5. Проверка типобезопасности

### TypeScript предотвращает ошибки:

```typescript
// ❌ ОШИБКА: отсутствует свойство model
let invalidAirplanes: Airplanes = [
  {
    capacity: 180, // Есть
    year: 2020, // Есть
    // model отсутствует - ОШИБКА!
  },
];

// ❌ ОШИБКА: неверный тип свойства
let wrongTypeAirplanes: Airplanes = [
  {
    model: "Boeing 737",
    capacity: "180", // Должен быть number, а не string
    year: 2020,
  },
];
```

### Правильное исправление:

```typescript
// ✅ КОРРЕКТНО: все свойства на месте с правильными типами
let validAirplanes: Airplanes = [
  {
    model: "Boeing 737",
    capacity: 180,
    year: 2020,
  },
];
```

---

## 6. Практические примеры из реальной разработки

### Пример 1: Пользователи в системе

```typescript
type User = {
  id: number;
  name: string;
  email: string;
};

type Users = User[];

const users: Users = [
  { id: 1, name: "John", email: "john@example.com" },
  { id: 2, name: "Jane", email: "jane@example.com" },
];
```

### Пример 2: Разные типы данных

```typescript
// Массив только чисел (часто используется)
let prices: number[] = [19.99, 29.99, 39.99];

// Массив только строк
let names: string[] = ["Alice", "Bob", "Charlie"];

// Смешанный массив (редко, но бывает нужно)
let mixedData: (string | number)[] = ["Total", 100, "items", 25];
```

---

## 7. Преимущества строгой типизации массивов

### A. Автодополнение в IDE:

```typescript
let users: User[] = [...];

users[0].  // IDE предложит: id, name, email
```

### B. Защита от ошибок:

```typescript
// ❌ TypeScript поймает эту ошибку
users.push({ name: "Tom" }); // Ошибка: отсутствуют id и email

// ✅ Правильно
users.push({ id: 3, name: "Tom", email: "tom@example.com" });
```

### C. Безопасные операции с массивом:

```typescript
let numbers: number[] = [1, 2, 3];

// TypeScript знает, что map вернет number[]
let doubled = numbers.map((n) => n * 2); // Тип: number[]

// TypeScript знает, что filter вернет number[]
let even = numbers.filter((n) => n % 2 === 0); // Тип: number[]
```

---

## Итог от автора

Автор подчеркивает:

1. **Два синтаксиса** типизации массивов: `Type[]` и `Array<Type>`
2. **Рекомендуется** `Type[]` как более читаемый
3. **Union types** для массивов с разными типами: `(Type1 | Type2)[]`
4. **Массивы объектов** используют существующие type aliases
5. **TypeScript обеспечивает безопасность** для операций с массивами

### Мой итог как разработчика

Вы изучили фундаментальные принципы работы с массивами в TypeScript:

1. **Основные паттерны типизации:**

   - `number[]` — для однородных данных
   - `(string | number)[]` — для смешанных данных (используйте осторожно)
   - `User[]` — для коллекций объектов

2. **Практические рекомендации:**

   ```typescript
   // ✅ ХОРОШО - предсказуемые структуры
   type Product = { id: number; name: string; price: number };
   type Products = Product[];

   // ❌ ПЛОХО - слишком свободные типы
   type LooseArray = any[];
   type VeryMixed = (string | number | boolean | object)[];
   ```

3. **Безопасность при операциях:**

   - TypeScript проверяет методы массивов (`push`, `map`, `filter`)
   - Обеспечивает корректность данных при добавлении/изменении
   - Предоставляет автодополнение для элементов массива

4. **Производительность:** Вся проверка типов происходит на этапе компиляции.

5. **Подготовка к будущим темам:**
   - **Дженерики** — более сложные сценарии типизации массивов
   - **Readonly arrays** — неизменяемые массивы
   - **Tuple types** — массивы фиксированной длины

**Резюме:** Правильная типизация массивов — это ключ к созданию надежных приложений, работающих с коллекциями данных. TypeScript превращает потенциальные runtime-ошибки в ошибки компиляции, обеспечивая безопасность данных на всех этапах работы с массивами.
