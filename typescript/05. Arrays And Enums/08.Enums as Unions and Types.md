## Общее введение

Автор углубляется в понимание того, как enum работают как типы в TypeScript и как они автоматически становятся объединениями (unions) своих свойств, обеспечивая типобезопасность.

---

## 1. Создание enum для видов фигур

### Базовый enum с строковыми значениями:

```typescript
enum ShapeKind {
  Circle = "circle",
  Square = "square",
}
```

**Особенности:**

- Строковые литералы делают значения понятными
- Каждое значение уникально и неизменно
- Enum служит единым источником истины для видов фигур

---

## 2. Использование enum как типов в объектах

### Тип Circle с зависимостью от enum:

```typescript
type Circle = {
  kind: ShapeKind.Circle; // Конкретный член enum как тип
  radius: number;
};
```

### Тип Square с зависимостью от enum:

```typescript
type Square = {
  kind: ShapeKind.Square; // Конкретный член enum как тип
  sideLength: number;
};
```

---

## 3. Type Safety с enum

### Правильное создание объекта:

```typescript
let circle: Circle = {
  kind: ShapeKind.Circle, // ✅ Корректно - соответствует ShapeKind.Circle
  radius: 100,
};
```

### Некорректные попытки (ошибки TypeScript):

```typescript
// ❌ ОШИБКА - неверный kind
let invalidCircle: Circle = {
  kind: ShapeKind.Square, // Должен быть ShapeKind.Circle
  radius: 100,
};

// ❌ ОШИБКА - несуществующее значение
let wrongCircle: Circle = {
  kind: "triangle", // Не существует в ShapeKind
  radius: 100,
};
```

---

## 4. Enum как объединение (Union) свойств

### Функция, принимающая любой член enum:

```typescript
function printShape(shape: ShapeKind) {
  console.log(shape);
}
```

### Что на самом деле представляет `ShapeKind`:

```typescript
// TypeScript неявно создает union тип
// ShapeKind эквивалентно:
type ShapeKindUnion = ShapeKind.Circle | ShapeKind.Square;
```

### Использование функции:

```typescript
printShape(ShapeKind.Circle); // ✅ "circle"
printShape(ShapeKind.Square); // ✅ "square"

// ❌ НЕВОЗМОЖНО - передать весь enum
printShape(ShapeKind); // Ошибка: ожидается член enum

// ❌ НЕВОЗМОЖНО - передать произвольную строку
printShape("circle"); // Ошибка: не совместимо с ShapeKind
```

---

## 5. Преимущества подхода с enum

### A. Централизованное управление:

```typescript
// Добавление новой фигуры требует только обновления enum
enum ShapeKind {
  Circle = "circle",
  Square = "square",
  Triangle = "triangle", // Новый тип
}
```

### B. Автоматическое распространение изменений:

```typescript
// Все типы, использующие ShapeKind, получают новые возможности
type Triangle = {
  kind: ShapeKind.Triangle; // Автоматически доступен
  base: number;
  height: number;
};
```

### C. Защита от опечаток и ошибок:

```typescript
// TypeScript предотвращает:
circle.kind = "cirlce"; // ❌ Опечатка
circle.kind = "CIRCLE"; // ❌ Неверный регистр
circle.kind = 1; // ❌ Неверный тип
```

---

## 6. Расширенный пример: обработка разных фигур

### Функция с проверкой типа через enum:

```typescript
function calculateArea(shape: Circle | Square): number {
  switch (shape.kind) {
    case ShapeKind.Circle:
      // TypeScript знает, что shape - Circle
      return Math.PI * shape.radius ** 2;

    case ShapeKind.Square:
      // TypeScript знает, что shape - Square
      return shape.sideLength ** 2;

    // Если добавить Triangle, TypeScript потребует обработать этот случай
  }
}
```

### Использование:

```typescript
const circleArea = calculateArea({
  kind: ShapeKind.Circle,
  radius: 5,
}); // 78.54

const squareArea = calculateArea({
  kind: ShapeKind.Square,
  sideLength: 4,
}); // 16
```

---

## 7. Сравнение с альтернативными подходами

### Подход с union типов (без enum):

```typescript
type ShapeType = "circle" | "square";

type Circle = {
  kind: "circle"; // Жестко закодировано
  radius: number;
};

type Square = {
  kind: "square"; // Жестко закодировано
  sideLength: number;
};
```

### Преимущества enum подхода:

- **Единый источник истины** - изменения в одном месте
- **Лучшая рефакторинг** - переименование только в enum
- **Явность** - четко видно все возможные значения

---

## 8. Практические сценарии использования

### Сценарий 1: Система статусов заказов

```typescript
enum OrderStatus {
  Pending = "pending",
  Processing = "processing",
  Shipped = "shipped",
  Delivered = "delivered",
}

type Order = {
  id: number;
  status: OrderStatus; // Гарантированно одно из значений enum
  // ...
};
```

### Сценарий 2: Настройки приложения

```typescript
enum Theme {
  Light = "light",
  Dark = "dark",
  Auto = "auto",
}

type UserPreferences = {
  theme: Theme;
  language: string;
  // ...
};
```

---

## Итог от автора

Автор подчеркивает:

1. **Enum как типы** - могут использоваться для аннотации типов и обеспечения типобезопасности
2. **Enum как объединения** - автоматически становятся union типами своих членов
3. **Централизованное управление** - изменения в enum распространяются автоматически
4. **Защита от ошибок** - предотвращает неверные присваивания

### Мой итог как разработчика

Вы изучили глубокие аспекты работы enum в TypeScript:

1. **Двойственная природа enum:**

   - **Как namespace** - предоставляет значения в runtime
   - **Как тип** - обеспечивает типобезопасность в compile-time

2. **Архитектурные преимущества:**

   ```typescript
   // Единая точка определения возможных значений
   enum UserRole {
       Admin = "admin",
       User = "user",
       Moderator = "moderator"
   }

   // Множественное использование с гарантированной безопасностью
   type User = { role: UserRole };
   type Permission = { allowedRoles: UserRole[] };
   function checkAccess(role: UserRole): boolean { ... }
   ```

3. **Практические рекомендации:**

   - Используйте enum для фиксированных наборов взаимосвязанных значений
   - Предпочитайте строковые значения для лучшей отладки
   - Комбинируйте с discriminated unions для сложных структур

4. **Безопасность и надежность:**

   - **Компилятор проверяет** соответствие значений
   - **IDE предоставляет автодополнение**
   - **Рефакторинг становится безопаснее** - изменения в enum требуют обработки всех случаев

5. **Производительность:** Вся проверка типов происходит на этапе компиляции.

**Резюме:** Понимание того, что enum работают одновременно как значения и как типы (в частности, как объединения своих членов), является ключевым для создания надежных, поддерживаемых TypeScript приложений. Этот подход позволяет создавать самодокументирующийся код с высокой степенью типобезопасности, где ошибки обнаруживаются на этапе разработки, а не в production.
