## Базовое сходство: контракты

### Абстрактный класс и интерфейс как контракты

**Абстрактный класс Person:**

```typescript
abstract class Person {
  abstract name: string;
  abstract email: string;
  abstract phone: number;
}
```

**Интерфейс User:**

```typescript
interface User {
  name: string;
  email: string;
  phone: number;
}
```

**Что общего:**

- Оба задают обязательные свойства
- Оба обеспечивают соблюдение контракта
- Оба вызывают ошибки TypeScript при неполной реализации

## Ключевое различие: реализация методов

### Абстрактные классы могут содержать реализацию

**Добавление метода с реализацией:**

```typescript
abstract class Person {
  abstract name: string;
  abstract email: string;
  abstract phone: number;

  // Конкретная реализация метода
  public greeting(): void {
    console.log(`Hello ${this.name}`);
  }
}
```

**Что это дает:**

- Метод `greeting` уже реализован
- Дочерние классы получают его "бесплатно"
- Можно переопределить при необходимости

### Наследование реализации

**Класс RegisteredPerson:**

```typescript
class RegisteredPerson extends Person {
  constructor(public name: string, public email: string, public phone: number) {
    super(); // Вызов конструктора родителя
  }

  // greeting метод уже доступен через наследование!
}
```

**Использование:**

```typescript
const person = new RegisteredPerson("John", "john@email.com", 1234567890);
person.greeting(); // "Hello John" - метод работает!
```

## Механика наследования в действии

### Цепочка прототипов

**Что происходит в JavaScript после компиляции:**

```javascript
class Person {
  greeting() {
    console.log(`Hello ${this.name}`);
  }
}

class RegisteredPerson extends Person {
  constructor(name, email, phone) {
    super();
    this.name = name;
    this.email = email;
    this.phone = phone;
  }
}

const person = new RegisteredPerson("John", "...", 1234567890);
person.greeting(); // Ищет в person -> не находит -> ищет в RegisteredPerson.prototype -> не находит -> ищет в Person.prototype -> находит!
```

**В консоли разработчика:**

```
RegisteredPerson {
  name: "John",
  email: "john@email.com",
  phone: 1234567890
}
__proto__: Person {
  greeting: function() { ... }
}
```

## Преимущества реализации в абстрактных классах

### 1. **Повторное использование кода**

```typescript
abstract class Person {
  // Общая логика для всех персоналий
  public getFullInfo(): string {
    return `${this.name} <${this.email}> Phone: ${this.phone}`;
  }

  public validateEmail(): boolean {
    return this.email.includes("@");
  }
}
```

### 2. **Стандартное поведение**

```typescript
abstract class Logger {
  abstract logLevel: string;

  // Стандартная реализация
  public log(message: string): void {
    console.log(`[${this.logLevel}] ${new Date().toISOString()}: ${message}`);
  }
}
```

### 3. **Шаблонный метод (Template Method)**

```typescript
abstract class DataProcessor {
  // Общий алгоритм
  public process(): void {
    this.loadData();
    this.transformData();
    this.saveData();
  }

  // Абстрактные шаги - должны быть реализованы
  abstract loadData(): void;
  abstract transformData(): void;
  abstract saveData(): void;
}
```

## Сравнительная таблица на данном этапе

| Аспект                      | Абстрактные классы | Интерфейсы     |
| --------------------------- | ------------------ | -------------- |
| **Абстрактные свойства**    | ✅                 | ✅             |
| **Конкретные свойства**     | ✅                 | ❌             |
| **Абстрактные методы**      | ✅                 | ✅ (сигнатуры) |
| **Конкретные методы**       | ✅                 | ❌             |
| **Наследование реализации** | ✅                 | ❌             |
| **Цепочка прототипов**      | ✅                 | ❌             |

## Практические последствия

### Когда выбирать абстрактные классы:

**1. Есть общая логика:**

```typescript
abstract class PaymentProcessor {
  // Общая логика для всех процессоров
  public processPayment(amount: number): boolean {
    this.validateAmount(amount);
    const result = this.executePayment(amount);
    this.logTransaction(amount, result);
    return result;
  }

  private validateAmount(amount: number): void { ... }
  private logTransaction(amount: number, success: boolean): void { ... }

  // Должны быть реализованы в дочерних классах
  abstract executePayment(amount: number): boolean;
}
```

**2. Нужна стандартная реализация:**

```typescript
abstract class Animal {
  // Стандартное поведение
  public sleep(): void {
    console.log("Zzzzz...");
  }

  // Должно быть переопределено
  abstract makeSound(): void;
}
```

### Архитектурные преимущества:

**1. Соблюдение принципа DRY:**

```typescript
// Без абстрактного класса (дублирование):
class CreditCardProcessor {
  processPayment(amount: number) {
    this.validateAmount(amount);
    // специфичная логика
    this.logTransaction(amount, result);
  }
  validateAmount(amount: number) { ... }
  logTransaction(amount: number, success: boolean) { ... }
}

class PayPalProcessor {
  processPayment(amount: number) {
    this.validateAmount(amount); // ДУБЛИРОВАНИЕ
    // другая логика
    this.logTransaction(amount, result); // ДУБЛИРОВАНИЕ
  }
  validateAmount(amount: number) { ... } // ДУБЛИРОВАНИЕ
  logTransaction(amount: number, success: boolean) { ... } // ДУБЛИРОВАНИЕ
}
```

**2. Единая точка изменения:**
Если нужно изменить логику валидации, меняем в одном месте - абстрактном классе.

## Подготовка к следующей части

Автор намекает, что в следующем видео будет рассмотрено:

> "how we would have implemented the greeting method in the class implementing the interface and some other differences"

**Что это значит:**

- Как эмулировать поведение абстрактных классов с интерфейсами
- Другие различия (конструкторы, модификаторы доступа, состояние)
- Когда предпочесть интерфейсы над абстрактными классами

## Ключевые выводы этой части

### 1. **Абстрактные классы = контракт + реализация**

Могут содержать как абстрактные члены (требующие реализации), так и конкретные (готовые к использованию).

### 2. **Интерфейсы = чистый контракт**

Только сигнатуры, без реализации.

### 3. **Наследование vs Реализация**

- `extends` - получаешь и контракт, и реализацию
- `implements` - получаешь только контракт

### 4. **Практическое значение:**

- **Абстрактные классы** - когда есть общая логика для группы классов
- **Интерфейсы** - когда нужно только описать форму

### 5. **Производительность:**

Наследование от абстрактных классов создает цепочку прототипов, что может быть немного эффективнее в runtime.

Это сравнение показывает, что хотя абстрактные классы и интерфейсы выглядят похоже, они решают разные задачи и должны использоваться в соответствующих сценариях!
