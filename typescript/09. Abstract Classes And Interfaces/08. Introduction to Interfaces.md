## Основная концепция интерфейсов

### Что такое интерфейс?

**Интерфейс** — это контракт или соглашение между различными частями приложения. Автор использует прекрасную аналогию с USB:

```typescript
// Интерфейс = USB-порт на ноутбуке
// Классы = устройства (мышь, телефон, клавиатура)
```

**Суть аналогии:**

- USB-порт задает "контракт": форма разъема, напряжение, протокол передачи данных
- Любое устройство, соблюдающее этот контракт, будет работать
- Вам не важно, КАК именно работает устройство внутри - важно, что оно совместимо с USB

### Применение в программировании

В приложении интерфейс `User` работает так же:

- Задает контракт: какие свойства и методы должен иметь пользователь
- Любой класс, реализующий этот интерфейс, будет совместим с системой
- Система аутентификации может работать с ЛЮБЫМ пользователем, соблюдающим контракт

## Практическая реализация

### 1. Объявление интерфейса

```typescript
interface User {
  username: string;
  email: string;
  login(): void;
}
```

**Что здесь происходит:**

- `interface` — ключевое слово для создания интерфейса
- `User` — имя интерфейса (обычно с большой буквы)
- Содержит требования:
  - `username: string` — свойство типа string
  - `email: string` — свойство типа string
  - `login(): void` — метод без возвращаемого значения

### 2. Реализация интерфейса в классе

```typescript
class Admin implements User {
  public username: string;
  public email: string;
  public adminLevel: number; // Дополнительное свойство

  constructor(username: string, email: string, adminLevel: number) {
    this.username = username;
    this.email = email;
    this.adminLevel = adminLevel;
  }

  login(): void {
    console.log("Admin is now logged in");
  }
}
```

**Ключевые моменты:**

- `implements User` — класс обязуется выполнить контракт интерфейса User
- **Обязательно** должны быть все свойства и методы из интерфейса
- **Можно добавлять** дополнительные свойства (`adminLevel`)
- TypeScript проверяет compliance с контрактом на этапе компиляции

### 3. Второй класс с тем же интерфейсом

```typescript
class Customer implements User {
  public username: string;
  public email: string;

  constructor(username: string, email: string) {
    this.username = username;
    this.email = email;
  }

  login(): void {
    console.log("Customer is now logged in");
  }
}
```

**Важное наблюдение:**

- Тот же интерфейс, но разная реализация
- У `Customer` нет `adminLevel` — это нормально
- Метод `login` делает то же самое, но выводит другое сообщение

## Сила интерфейсов - полиморфизм

### Класс Auth - получатель интерфейса

```typescript
class Auth {
  static login(user: User): void {
    user.login();
  }
}
```

**Вот где проявляется магия:**

- Метод принимает параметр типа `User` (интерфейс)
- Ему не важно, КАКОЙ именно объект передадут
- Важно, что у объекта есть метод `login()`
- Это называется **полиморфизм** - один интерфейс, много реализаций

### Использование на практике

```typescript
const adminUser = new Admin("Mark", "mark@email.com", 1);
const customerUser = new Customer("John", "john@email.com");

Auth.login(adminUser); // "Admin is now logged in"
Auth.login(customerUser); // "Customer is now logged in"
```

**Что здесь происходит:**

1. Создаем объекты разных классов
2. Передаем их в один и тот же метод `Auth.login()`
3. Метод работает с обоими, потому что оба соблюдают контракт `User`
4. Вызываются РАЗНЫЕ реализации метода `login()` для каждого класса

## Ключевые преимущества интерфейсов

### 1. **Стандартизация**

```typescript
// Без интерфейса - каждый делает по-своему
class Admin {
  /* одна структура */
}
class Customer {
  /* совсем другая структура */
}

// С интерфейсом - единый стандарт
interface User {
  /* общий контракт */
}
class Admin implements User {
  /* соблюдает стандарт */
}
class Customer implements User {
  /* соблюдает стандарт */
}
```

### 2. **Гибкость и расширяемость**

- Можно добавить новый класс `Moderator implements User`
- Класс `Auth` будет работать с ним автоматически
- Не нужно переписывать существующий код

### 3. **Контроль на этапе компиляции**

TypeScript сразу покажет ошибку, если класс не реализует все требования интерфейса.

## Сравнение с абстрактными классами

Хотя мы не проходили это глубоко, автор намекает на сравнение:

| Абстрактные классы         | Интерфейсы            |
| -------------------------- | --------------------- |
| Могут содержать реализацию | Только сигнатуры      |
| Используют наследование    | Используют реализацию |
| Более тяжеловесны          | Легковесны            |

## Итог

**Интерфейс — это как "паспорт" для объектов:**

- Задает минимальные требования
- Гарантирует совместимость
- Позволяет разным объектам работать в единой системе

Это фундаментальная концепция, которая открывает дорогу к:

- Полиморфизму
- Слабому связыванию компонентов
- Легкому тестированию (моки и стабы)
- Архитектурной гибкости

Автор готовит вас к более сложным темам, где интерфейсы станут незаменимым инструментом для создания масштабируемых приложений.
