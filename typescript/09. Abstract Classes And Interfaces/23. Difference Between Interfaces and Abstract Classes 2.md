## Добавление методов в интерфейсы

### Сигнатура метода в интерфейсе

**Обновленный интерфейс User:**

```typescript
interface User {
  name: string;
  email: string;
  phone: number;
  greeting(): void; // Только сигнатура, без реализации
}
```

**Ключевой момент:** В интерфейсе мы указываем ЧТО должно быть, но не КАК это реализовать.

## Реализация метода в классе

### Класс RegisteredUser с методом greeting

```typescript
class RegisteredUser implements User {
  constructor(
    public name: string,
    public email: string,
    public phone: number
  ) {}

  // Реализация метода greeting ОБЯЗАТЕЛЬНА
  public greeting(): void {
    console.log(`Hello ${this.name}`);
  }
}
```

## Сравнение подходов

### Абстрактный класс vs Интерфейс

**Абстрактный класс (с реализацией):**

```typescript
abstract class Person {
  abstract name: string;
  abstract email: string;
  abstract phone: number;

  // Готовая реализация
  public greeting(): void {
    console.log(`Hello ${this.name}`);
  }
}

// Дочерний класс получает метод "бесплатно"
class RegisteredPerson extends Person {
  constructor(public name: string, public email: string, public phone: number) {
    super();
  }
  // greeting уже доступен через наследование!
}
```

**Интерфейс (только контракт):**

```typescript
interface User {
  name: string;
  email: string;
  phone: number;
  greeting(): void; // Только требование
}

// Класс должен сам реализовать метод
class RegisteredUser implements User {
  constructor(
    public name: string,
    public email: string,
    public phone: number
  ) {}

  // Должен предоставить свою реализацию
  public greeting(): void {
    console.log(`Hello ${this.name}`);
  }
}
```

## Ключевые различия

### 1. **Реализация методов**

**Абстрактные классы:**

- Могут содержать готовую реализацию методов
- Наследники получают эту реализацию автоматически
- Можно переопределить при необходимости

**Интерфейсы:**

- Только сигнатуры методов (название, параметры, возвращаемый тип)
- Каждый класс должен предоставить свою реализацию
- Нет возможности наследования реализации

### 2. **Множественное "наследование"**

**С интерфейсами - МОЖНО:**

```typescript
interface Greeting {
  greeting(): void;
}

interface User {
  name: string;
  email: string;
}

// Класс реализует ДВА интерфейса
class RegisteredUser implements User, Greeting {
  constructor(
    public name: string,
    public email: string,
    public phone: number
  ) {}

  public greeting(): void {
    console.log(`Hello ${this.name}`);
  }
}
```

**С абстрактными классами - НЕЛЬЗЯ:**

```typescript
abstract class A { ... }
abstract class B { ... }

// НЕВОЗМОЖНО в TypeScript:
class C extends A, B { ... } // ОШИБКА!
```

### 3. **Статические методы**

**Абстрактные классы поддерживают статические методы:**

```typescript
abstract class Person {
  static className(): string {
    return "Person";
  }

  abstract name: string;
  // ...
}

// Использование без создания экземпляра
console.log(Person.className()); // "Person"
```

**Интерфейсы НЕ поддерживают статические методы:**

```typescript
interface User {
  // НЕЛЬЗЯ объявить статический метод в интерфейсе
  static className(): string; // ОШИБКА!
}
```

## Практические последствия

### Преимущества интерфейсов для множественной реализации

**Гибкая композиция возможностей:**

```typescript
interface Authenticatable {
  login(): boolean;
  logout(): void;
}

interface Profilable {
  updateProfile(data: any): void;
  getProfile(): any;
}

interface Adminable {
  manageUsers(): void;
}

// Класс может комбинировать разные возможности
class AdminUser implements Authenticatable, Profilable, Adminable {
  // Должен реализовать все методы всех интерфейсов
  login(): boolean { ... }
  logout(): void { ... }
  updateProfile(data: any): void { ... }
  getProfile(): any { ... }
  manageUsers(): void { ... }
}
```

### Преимущества абстрактных классов для общей логики

**Повторное использование кода:**

```typescript
abstract class Repository<T> {
  // Общая логика для всех репозиториев
  protected items: T[] = [];

  public getAll(): T[] {
    return this.items;
  }

  public getById(id: number): T | undefined {
    return this.items.find((item) => (item as any).id === id);
  }

  // Абстрактные методы - должны быть реализованы
  abstract save(item: T): void;
  abstract delete(id: number): boolean;
}

// Конкретные реализации наследуют общую логику
class UserRepository extends Repository<User> {
  save(user: User): void {
    this.items.push(user);
  }

  delete(id: number): boolean {
    const index = this.items.findIndex((user) => user.id === id);
    if (index > -1) {
      this.items.splice(index, 1);
      return true;
    }
    return false;
  }
}
```

## Сравнительная таблица

| Характеристика                 | Абстрактные классы            | Интерфейсы                |
| ------------------------------ | ----------------------------- | ------------------------- |
| **Реализация методов**         | ✅ Может содержать            | ❌ Только сигнатуры       |
| **Наследование реализации**    | ✅ Через `extends`            | ❌                        |
| **Множественное наследование** | ❌ Только один класс          | ✅ Через `implements`     |
| **Статические методы**         | ✅ Поддерживаются             | ❌ Не поддерживаются      |
| **Конструкторы**               | ✅ Могут быть                 | ❌ Не могут быть          |
| **Модификаторы доступа**       | ✅ public, protected, private | ❌ Только public          |
| **Слияние объявлений**         | ❌                            | ✅ Автоматическое слияние |
| **Состояние (поля)**           | ✅ Может содержать            | ❌ Только сигнатуры       |

## Архитектурные последствия

### Когда выбирать интерфейсы:

**1. Для определения контрактов:**

```typescript
// Разные команды могут работать с одним контрактом
interface PaymentProcessor {
  process(amount: number): Promise<boolean>;
}

// Разные реализации одного контракта
class StripeProcessor implements PaymentProcessor { ... }
class PayPalProcessor implements PaymentProcessor { ... }
```

**2. Для полиморфизма без привязки к иерархии:**

```typescript
interface Loggable {
  log(message: string): void;
}

// ЛЮБОЙ класс может быть Loggable, независимо от его положения в иерархии
class User implements Loggable { ... }
class Product implements Loggable { ... }
class Order implements Loggable { ... }
```

### Когда выбирать абстрактные классы:

**1. Для шаблонного метода (Template Method):**

```typescript
abstract class DataExporter {
  // Общий алгоритм
  public export(): void {
    const data = this.extractData();
    const transformed = this.transformData(data);
    this.save(transformed);
  }

  // Шаги, которые должны быть реализованы
  protected abstract extractData(): any[];
  protected abstract transformData(data: any[]): any;
  protected abstract save(data: any): void;
}
```

**2. Для общего состояния и поведения:**

```typescript
abstract class Animal {
  protected energy: number = 100;

  // Общее поведение
  public sleep(hours: number): void {
    this.energy += hours * 10;
  }

  // Должно быть реализовано
  abstract makeSound(): void;
}
```

## Подготовка к следующему уроку

Автор упоминает, что в следующем видео будет рассмотрено:

> "where to use abstract classes and where to use interfaces"

**Что это значит:**

- Практические рекомендации по выбору
- Примеры из реальных проектов
- Комбинирование обоих подходов
- Best practices и anti-patterns

## Ключевые выводы этой части

### 1. **Интерфейсы для гибкости:**

- Множественная реализация
- Чистые контракты
- Независимость от иерархии классов

### 2. **Абстрактные классы для повторного использования:**

- Общая логика и состояние
- Наследование реализации
- Шаблонные методы

### 3. **Статические методы - прерогатива классов:**

Только классы (включая абстрактные) могут содержать статические методы.

### 4. **Комплементарные подходы:**

Часто лучшие решения используют и интерфейсы, и абстрактные классы вместе:

```typescript
// Интерфейс для контракта
interface Repository<T> {
  getById(id: number): T | undefined;
  save(item: T): void;
}

// Абстрактный класс для общей логики
abstract class BaseRepository<T> implements Repository<T> {
  protected items: T[] = [];

  getById(id: number): T | undefined {
    return this.items.find((item) => (item as any).id === id);
  }

  // save должен быть реализован в дочерних классах
  abstract save(item: T): void;
}
```

Этот детальный анализ показывает, что хотя абстрактные классы и интерфейсы имеют сходства, они предназначены для решения разных задач и должны использоваться соответственно их сильным сторонам!
