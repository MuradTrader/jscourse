## Концепция слияния объявлений

### Что такое Declaration Merging?

**Слияние объявлений** — это особенность TypeScript, которая позволяет объединять несколько объявлений с одинаковым именем в одно.

В данном случае автор показывает, как это работает с интерфейсами.

## Практический пример

### Первое объявление интерфейса

```typescript
interface IUser {
  id: number;
  name: string;
}
```

**На этом этапе интерфейс содержит:**

- `id: number` - идентификатор пользователя
- `name: string` - имя пользователя

### Класс, реализующий интерфейс

```typescript
class UserClass implements IUser {
  constructor(public id: number, public name: string) {}
}
```

**Состояние на данный момент:**

- Класс полностью соответствует интерфейсу
- TypeScript не показывает ошибок
- Все обязательные свойства реализованы

## Слияние объявлений в действии

### Второе объявление того же интерфейса

```typescript
interface IUser {
  passwordHash: string;
}
```

**Что происходит после второго объявления:**

**БЫЛО:**

```typescript
interface IUser {
  id: number;
  name: string;
}
```

**СТАЛО:**

```typescript
interface IUser {
  id: number;
  name: string;
  passwordHash: string; // Добавилось из второго объявления
}
```

## Последствия слияния

### Ошибка в классе

После слияния объявлений класс `UserClass` начинает показывать ошибку:

> "Property 'passwordHash' is missing in type 'UserClass' but required in type 'IUser'"

**Почему это происходит:**

- TypeScript автоматически объединил оба объявления `IUser`
- Теперь интерфейс требует три свойства вместо двух
- Класс реализует только два из трех требуемых свойств

### Исправление класса

```typescript
class UserClass implements IUser {
  constructor(
    public id: number,
    public name: string,
    public passwordHash: string // Добавляем недостающее свойство
  ) {}
}
```

## Механика слияния объявлений

### Как TypeScript обрабатывает множественные объявления

**Процесс слияния:**

1. TypeScript находит все объявления с именем `IUser`
2. Объединяет все свойства в один интерфейс
3. Создает единый "контракт" из всех объявлений

**Визуализация:**

```
Объявление 1: IUser { id, name }
Объявление 2: IUser { passwordHash }
                ↓
Результат: IUser { id, name, passwordHash }
```

### Правила слияния

**1. Не конфликтующие свойства:**

```typescript
interface A {
  x: number;
}
interface A {
  y: string;
}
// Результат: { x: number; y: string; }
```

**2. Конфликтующие свойства (должны быть совместимы):**

```typescript
interface A {
  x: number;
}
interface A {
  x: number;
} // OK - одинаковые типы

interface B {
  x: number;
}
interface B {
  x: string;
} // ОШИБКА - несовместимые типы
```

## Практическое применение

### Сценарий 1: Постепенное расширение интерфейса

**В одном файле (базовые свойства):**

```typescript
interface IUser {
  id: number;
  name: string;
}
```

**В другом файле (расширенные свойства):**

```typescript
interface IUser {
  email: string;
  createdAt: Date;
}
```

**Итоговый интерфейс доступен везде:**

```typescript
// Во всей codebase IUser теперь имеет:
// id, name, email, createdAt
```

### Сценарий 2: Разделение ответственности

**Команда Auth создает:**

```typescript
// auth/types.ts
interface IUser {
  id: number;
  passwordHash: string;
  lastLogin: Date;
}
```

**Команда Profile создает:**

```typescript
// profile/types.ts
interface IUser {
  name: string;
  avatar?: string;
  bio?: string;
}
```

**Результат:** Единый интерфейс IUser со всеми свойствами

## Особенности и ограничения

### Где работает слияние объявлений

**Работает с:**

- Интерфейсами (interfaces)
- Пространствами имен (namespaces)
- Перечислениями (enums)

**Не работает с:**

- Типами (type aliases)
- Классами (classes)
- Переменными (variables)

### Пример с типами (НЕ работает)

```typescript
type User = { id: number };
type User = { name: string }; // ОШИБКА: Duplicate identifier 'User'
```

## Преимущества слияния объявлений

### 1. **Модульность**

Можно разбивать большие интерфейсы на логические части:

```typescript
// user-basic.ts
interface IUser {
  id: number;
  name: string;
}

// user-auth.ts
interface IUser {
  passwordHash: string;
  isActive: boolean;
}

// user-profile.ts
interface IUser {
  avatar?: string;
  preferences: UserPreferences;
}
```

### 2. **Расширяемость**

Легко добавлять новые свойства без изменения существующего кода:

```typescript
// Старая версия
interface IUser {
  id: number;
  name: string;
}

// Новая версия (в другом месте)
interface IUser {
  email: string;
  phone?: string;
}
```

### 3. **Интеграция с сторонними библиотеками**

Часто используется для расширения типов из библиотек:

```typescript
// Расширяем интерфейс из библиотеки
interface SomeLibraryInterface {
  newProperty: string;
}
```

## Потенциальные проблемы

### 1. **Неожиданное поведение**

Если не знать о слиянии, можно столкнуться с непонятными ошибками:

```typescript
// В файле A
interface Config {
  url: string;
}

// В файле B (разработчик не знает о файле A)
interface Config {
  timeout: number;
}

// В файле C - неожиданная ошибка!
class MyConfig implements Config {
  url: string; // ОШИБКА: timeout is missing!
}
```

### 2. **Конфликт имен**

Случайное использование одинаковых имен в разных контекстах:

```typescript
// Модуль отчетности
interface IUser {
  reportCount: number;
}

// Модуль аутентификации
interface IUser {
  loginAttempts: number;
}

// Непреднамеренное объединение!
```

## Best Practices

### 1. **Осознанное использование**

Используйте слияние объявлений целенаправленно, а не случайно.

### 2. **Документирование**

Если используете слияние, документируйте это:

```typescript
/**
 * Этот интерфейс объединяется с IUser из модуля auth
 * @merged-with auth/types.IUser
 */
interface IUser {
  profileData: Profile;
}
```

### 3. **Пространства имен**

Для избежания конфликтов используйте namespaces:

```typescript
namespace Auth {
  export interface IUser { ... }
}

namespace Reporting {
  export interface IUser { ... }
}
```

## Ключевые выводы

### 1. **Автоматическое объединение**

TypeScript автоматически объединяет интерфейсы с одинаковыми именами.

### 2. **Все свойства становятся обязательными**

После слияния классы должны реализовывать ВСЕ свойства из всех объявлений.

### 3. **Мощный инструмент для архитектуры**

Позволяет создавать модульные и расширяемые системы типов.

### 4. **Требует осторожности**

Может привести к неожиданным ошибкам, если не знать о этой возможности.

### 5. **Уникальность интерфейсов**

В отличие от типов (type), интерфейсы можно объявлять многократно.

Эта возможность делает TypeScript особенно мощным для больших проектов, где разные команды могут работать над расширением одних и тех же интерфейсов в разных модулях приложения!
