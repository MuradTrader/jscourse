### Общий контекст (О чем это все?)

Автор продолжает тему **абстрактных классов**. Ранее вы уже работали с абстрактными свойствами (например, `abstract holidays`). Теперь автор вводит понятие **абстрактных методов**. Проблема, которую он решает — это дублирование кода и отсутствие строгого контроля за тем, чтобы все дочерние классы реализовывали определенный метод.

---

### Подробное объяснение по пунктам

**1. Констатация проблемы:**

> "In our previous video, we worked on overriding the print holidays method in our child classes, but in the whole process, we ended up repeating a lot of code."

- **Что это значит:** В предыдущем уроке вы переопределяли метод `printHolidays` в дочерних классах (например, `ITDepartment`, `AccountingDepartment`). Это привело к тому, что один и тот же код (логика вывода праздников) был написан несколько раз, хоть и с небольшими изменениями. Это нарушает принцип DRY (Don't Repeat Yourself — "Не повторяйся") и усложняет поддержку.

**2. Проблема с родительским классом:**

> "Our department class has an implementation of Print Holidays method, which is not used by any of the child classes. Because now child classes are overriding this print holidays method that exists in our department class."

- **Что это значит:** Исходная, "базовая" реализация метода `printHolidays` в родительском классе `Department` стала бесполезной. Ее никто не использует, так как каждый дочерний класс предоставил свою собственную версию. Это верный признак того, что эту методологию нужно улучшить.

**3. Введение абстрактных методов:**

> "Just like abstract properties, abstract classes can also have abstract methods."

- **Что это значит:** Ранее вы уже использовали `abstract` для свойств (переменных). Теперь автор говорит, что тот же подход применим и к _методам_ (функциям). Абстрактный метод — это как договор или чертеж. Он говорит: _"Любой класс, который будет наследоваться от меня, ОБЯЗАН иметь такой метод, но как именно он будет работать — решайте сами"_.

**4. Превращение конкретного метода в абстрактный:**

> "So just like we have abstract property called holidays in our department class, we can also have abstract methods within our department class. An abstract method is just the signature of the method that every child class will have to implement."

- **Процесс преобразования:**
  1.  **Было (Конкретный метод):**
      ```typescript
      class Department {
        // ... другие свойства и методы ...
        printHolidays(): void {
          // Какая-то реализация здесь (тело метода)
          console.log("Holidays: ", this.holidays);
        }
      }
      ```
  2.  **Стало (Абстрактный метод):**
      ```typescript
      abstract class Department {
        // ... другие свойства и методы ...
        abstract printHolidays(): void; // Только сигнатура, без тела {}
      }
      ```
  - **Ключевые изменения:**
    - Добавляется ключевое слово `abstract`.
    - Убирается _тело метода_ (все, что было внутри фигурных скобок `{}`).
    - Остается только _сигнатура_: имя метода, параметры (в данном случае их нет) и тип возвращаемого значения (`void`).

**5. Зачем это нужно в данном примере?**

> "The print holidays method over here is a good contender for being an abstract method in the parent class, because each of the child class is implementing it with a different heading."

- **Что это значит:** Автор признает, что в реальном мире для такой простой задачи (разный заголовок) есть и другие решения. Но этот пример идеально подходит для демонстрации концепции. Все дочерние классы _де-факто_ уже реализуют этот метод по-разному, так почему бы не обязать их делать это _де-юре_? Это делает архитектуру более строгой и предсказуемой.

**6. Сигнатура метода и параметры:**

> "If this method was taking in any parameters as well, you would have defined them here. So for example, it could take a message that could be a type of string. So if we would have had message as one of the parameters... our child classes would have to follow the same method signature..."

- **Что это значит:** Абстрактный метод задает жесткий "контракт". Если бы в родительском классе метод был объявлен как `abstract printHolidays(message: string): void;`, то каждая дочерняя реализация _обязана_ была бы принимать один аргумент типа `string`.
  - **Правильно:**
    ```typescript
    class ITDepartment extends Department {
      printHolidays(customMessage: string): void {
        // Имя переменной может быть другим, но тип - string - обязателен!
        console.log(customMessage, this.holidays);
      }
    }
    ```
  - **Неправильно (вызовет ошибку):**
    ```typescript
    class ITDepartment extends Department {
      printHolidays(): void {
        // Ошибка! Не хватает параметра.
        console.log("IT Holidays: ", this.holidays);
      }
    }
    ```

**7. Практическая демонстрация принуждения:**

> "Let's try to remove the implementation of Print Holidays method from our IT department and see what happens... Non-abstract class IT department does not implement inherit abstract member print holidays from the class department."

- **Что это значит:** Это самая сильная сторона абстрактных методов. **TypeScript компилятор теперь следит за соблюдением "контракта"**. Если дочерний класс забудит реализовать `printHolidays`, компилятор немедленно укажет на ошибку. Это предотвращает множество runtime-ошибок, которые могли бы возникнуть, если бы вы просто забыли переопределить метод. Это защита на этапе разработки.

**8. Резюме и связь с будущими темами:**

> "This gives you a fair idea of how you can force the implementation of certain properties and methods inside child classes, using abstract classes. We will come back to abstract classes once again to understand this concept of enforcing a set of contract on child classes once we have had a deep dive on interfaces."

- **Что это значит:** Автор подводит итог: основная цель абстрактных классов и методов — **принудительно задать контракт** для всех наследников. Далее он плавно подводит к теме **интерфейсов (interfaces)**, которые являются еще одним, часто более легковесным, способом задания контрактов в TypeScript. Понимание абстрактных классов поможет вам легче освоить интерфейсы, и наоборот.

### Ключевые выводы

1.  **Абстрактный метод** — это метод без реализации, только сигнатура.
2.  Он существует только внутри **абстрактного класса**.
3.  Его цель — **заставить** все неабстрактные дочерние классы предоставить свою собственную реализацию этого метода.
4.  **Сигнатура метода (имя, типы параметров, возвращаемый тип) должна соблюдаться неукоснительно.**
5.  Это мощный инструмент для создания продуманной и надежной иерархии классов, где вы можете быть уверены, что у всех наследников есть необходимый функционал.
