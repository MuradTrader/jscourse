## Уникальные возможности типов (type)

### 1. Объединения (Union Types)

**Что такое Union Type:**

```typescript
type User = {
  name: string;
};

type AdminUser = {
  isAdmin: boolean;
};

// Union type - может быть ЛИБО User, ЛИБО AdminUser, ЛИБО оба
type UserOrAdmin = User | AdminUser;
```

**Примеры использования:**

```typescript
const user1: UserOrAdmin = { name: "John" }; // Только User
const user2: UserOrAdmin = { isAdmin: true }; // Только AdminUser
const user3: UserOrAdmin = { name: "John", isAdmin: true }; // Оба
```

**Практическое применение:**

- Функции, которые принимают разные типы данных
- Состояния, которые могут быть в разных формах
- Обработка различных вариантов входных данных

### 2. Пересечения (Intersection Types)

**Что такое Intersection Type:**

```typescript
type UserAndAdmin = User & AdminUser;

// Должен содержать ВСЕ свойства обоих типов
const userAndAdmin: UserAndAdmin = {
  name: "John", // из User
  isAdmin: true, // из AdminUser
};
```

**Практическое применение:**

- Комбинирование нескольких типов в один
- Миксины и композиция
- Расширение функциональности

### 3. Кортежи (Tuples)

**Кортежи через type:**

```typescript
type ResponseTuple = [string, number]; // Фиксированная структура массива

const response: ResponseTuple = ["OK", 200];
// response[0] - всегда string
// response[1] - всегда number
// response[2] - ошибка, только 2 элемента
```

**Практическое применение:**

- Возврат нескольких значений из функции
- Фиксированные структуры данных (как координаты [x, y])
- React useState: [state, setState]

## Уникальные возможности интерфейсов (interface)

### 1. Слияние объявлений (Declaration Merging)

**Как работает:**

```typescript
// Первое объявление
interface Person {
  name: string;
}

// Второе объявление (в другом файле или месте)
interface Person {
  lastName: string;
}

// TypeScript автоматически объединяет их:
// interface Person {
//   name: string;
//   lastName: string;
// }

const person: Person = {
  name: "John",
  lastName: "Doe", // ОБА свойства обязательны!
};
```

**Практическое применение:**

- Расширение типов из сторонних библиотек
- Постепенное определение интерфейсов в больших проектах
- Работа разных команд над одним интерфейсом

### 2. Наследование интерфейсов (Extends)

**Наследование интерфейсов:**

```typescript
interface Name {
  name: string;
}

interface LastName {
  lastName: string;
}

// Интерфейс наследует от нескольких других
interface Person extends Name, LastName {
  // Автоматически получает name и lastName
}

const person: Person = {
  name: "John",
  lastName: "Doe",
};
```

### 3. Реализация в классах (implements)

**Интерфейсы с классами:**

```typescript
interface Name {
  name: string;
}

interface LastName {
  lastName: string;
}

class Person implements Name, LastName {
  constructor(public name: string, public lastName: string) {}
}
```

**Ключевое преимущество:** Класс может реализовывать несколько интерфейсов, но наследовать только от одного класса.

## Сравнительная таблица

| Возможность                    | Типы (type)                               | Интерфейсы (interface)           |
| ------------------------------ | ----------------------------------------- | -------------------------------- |
| **Объединения (Union)**        | ✅ `TypeA \| TypeB`                       | ❌                               |
| **Пересечения (Intersection)** | ✅ `TypeA & TypeB`                        | ❌ (но интерфейсы могут extends) |
| **Кортежи (Tuples)**           | ✅ `[string, number]`                     | ❌                               |
| **Слияние объявлений**         | ❌                                        | ✅                               |
| **Наследование**               | ❌                                        | ✅ `interface A extends B, C`    |
| **Реализация в классах**       | ❌                                        | ✅ `class A implements B, C`     |
| **Примитивные типы**           | ✅ `type ID = string \| number`           | ❌                               |
| **Шаблонные литералы**         | ✅ `type Status = "active" \| "inactive"` | ❌                               |

## Практические рекомендации

### Когда использовать type:

**1. Для объединений:**

```typescript
type Status = "pending" | "success" | "error";
type ID = string | number;
```

**2. Для сложных преобразований:**

```typescript
type PartialUser = Partial<User>;
type ReadonlyConfig = Readonly<Config>;
```

**3. Для кортежей:**

```typescript
type Point = [number, number];
type UseState = [T, (value: T) => void];
```

### Когда использовать interface:

**1. Для объектов и классов:**

```typescript
interface User {
  id: number;
  name: string;
}

class Admin implements User {
  // ...
}
```

**2. Для расширяемости:**

```typescript
// Библиотека определяет:
interface Request {
  url: string;
}

// Вы можете расширить:
interface Request {
  timeout: number;
}
```

**3. Для публичных API:**

```typescript
// Лучше для документирования и автодополнения
export interface ApiResponse<T> {
  data: T;
  status: number;
}
```

## Ограничения типов (type)

### Нельзя переобъявлять:

```typescript
type User = { name: string };
type User = { age: number }; // ОШИБКА: Duplicate identifier
```

### Нельзя наследовать:

```typescript
type A = { x: number };
type B = A & { y: string }; // Это пересечение, не наследование
```

## Ограничения интерфейсов (interface)

### Нельзя создавать объединения:

```typescript
interface A {
  x: number;
}
interface B {
  y: string;
}
type C = A | B; // Только через type
```

### Нельзя создавать примитивные алиасы:

```typescript
interface StringArray = string[]; // Не работает
type StringArray = string[];      // Работает
```

## Гибридный подход

### Сочетание сильных сторон:

```typescript
// Интерфейс для основной структуры
interface User {
  id: number;
  name: string;
}

// Типы для производных структур
type PartialUser = Partial<User>;
type UserStatus = User & { status: "active" | "inactive" };
type UserResponse = User | { error: string };
```

## Исторический контекст

### Эволюция в TypeScript:

- **Интерфейсы** были с самого начала (влияние Java/C#)
- **Типы** добавили позже для большей гибкости
- Сначала были значительные различия
- Сейчас много общего, но ключевые различия остаются

## Ключевые выводы

### 1. **Интерфейсы для ООП:**

- Наследование
- Полиморфизм
- Реализация в классах
- Расширяемость через слияние

### 2. **Типы для функционального программирования:**

- Алгебраические типы данных
- Композиция через объединения/пересечения
- Сложные преобразования типов

### 3. **Совместное использование:**

В современных проектах часто используют оба подхода, выбирая подходящий инструмент для конкретной задачи.

### 4. **Производительность:**

В большинстве случаев разницы нет, но для очень сложных типов компилятор может работать немного быстрее с интерфейсами.

### 5. **Соглашения в команде:**

Самое важное — договориться о едином подходе в проекте и придерживаться его согласованно.

Это сравнение показывает, что TypeScript предоставляет богатый набор инструментов для работы с типами, позволяя выбирать оптимальный подход в зависимости от конкретных требований архитектуры и стиля программирования!
