### Общий смысл видео

Автор объясняет, как работать с функциями, которые принимают неограниченное количество параметров, используя **Rest параметры**, а также как строго типизировать фиксированное количество параметров с помощью **кортежей (tuples)**.

---

### Подробное объяснение по пунктам

#### 1. Проблема: функции с неограниченным количеством параметров

**Что говорит автор:**

> "What if you wanted to write a function which could have unlimited parameters, but you want that all these parameters are strictly typed?"

**Что это значит, подробно:**

- Бывают ситуации, когда функция должна принимать переменное количество аргументов.
- Например: функция сложения чисел, которая может складывать 2, 3, 5 или любое количество чисел.
- Проблема: мы не можем заранее объявить все возможные параметры: `function add(a: number, b: number, c: number, d: number, ...)`

#### 2. Решение: Rest параметры

**Что говорит автор:**

> "To solve this problem we use something known as Rest parameters. Rest parameters can be declared like this. So we use three dots which is the rest operator in JavaScript."

**Что это значит, подробно:**

- **Rest параметры** позволяют собрать все оставшиеся аргументы в один массив.
- **Синтаксис:** `...parameterName: Type[]`
- Rest параметр всегда должен быть последним в списке параметров.
- Тип Rest параметра всегда массив (`Type[]`), потому что он собирает несколько значений.

```typescript
// Функция принимает первый обязательный параметр `by`,
// а все остальные числа собирает в массив `numbers`
function multiplyBy(by: number, ...numbers: number[]): number[] {
  return numbers.map((number) => number * by);
}
```

#### 3. Как работают Rest параметры

**Что говорит автор:**

> "Whenever you use a Rest parameter like this, you always get an array of values."

**Что это значит, подробно:**

- Rest параметр преобразует отдельные аргументы в массив.
- Внутри функции вы работаете с обычным массивом и можете использовать любые методы массивов (`map`, `filter`, `forEach` и т.д.).

```typescript
function multiplyBy(by: number, ...numbers: number[]): number[] {
  // numbers - это массив number[]
  return numbers.map((number) => number * by);
}

// Вызов функции
multiplyBy(2, 3, 4, 5);
// by = 2, numbers = [3, 4, 5]
// Результат: [6, 8, 10]
```

#### 4. TypeScript проверяет типы Rest параметров

**Что говорит автор:**

> "TypeScript over here understands that after two all these numbers have to be numbers and that's it. If I try to pass a string then TypeScript will certainly complain."

**Что это значит, подробно:**

- TypeScript обеспечивает типобезопасность для Rest параметров.
- Все аргументы, переданные в Rest параметр, должны соответствовать указанному типу.

```typescript
multiplyBy(2, 3, 4, 5); // ✅ Правильно
multiplyBy(2, 3, "4", 5); // ❌ Ошибка: "4" не number
```

#### 5. Ограничение: когда нужно фиксированное количество параметров

**Что говорит автор:**

> "But what if we wanted to have a limited length of numbers? For example, there could be functions where we just require two numbers and not any more."

**Что это значит, подробно:**

- Некоторые функции требуют точное количество аргументов.
- Например, `Math.atan2(y, x)` принимает ровно 2 числа.
- Обычный массив `number[]` не подходит, потому что он может содержать любое количество элементов.

#### 6. Решение: кортежи (Tuples)

**Что говорит автор:**

> "This is how we can solve this problem by declaring a tuple."

**Что это значит, подробно:**

- **Кортеж (Tuple)** - это массив фиксированной длины с известными типами элементов в каждой позиции.
- **Синтаксис:** `[Type1, Type2, Type3]`
- TypeScript проверяет не только типы элементов, но и длину кортежа.

**Способы создания кортежей:**

**Способ 1: Утверждение `as const`**

```typescript
const args = [1, 2] as const;
// Тип: readonly [1, 2] - кортеж только для чтения с фиксированными значениями
```

**Способ 2: Явная типовая аннотация**

```typescript
const args: [number, number] = [1, 2];
// Тип: [number, number] - кортеж из двух чисел
```

#### 7. Практическое применение кортежей

**Что говорит автор:**

> "If I try to pass these two arguments to this function, TypeScript is going to throw an error... But we need to have a strict type over here where this particular array only needs to have two arguments."

**Что это значит, подробно:**

```typescript
// ❌ ПРОБЛЕМА: обычный массив
const numbersArray: number[] = [1, 2];
Math.atan2(...numbersArray); // Ошибка: массив может иметь любое количество элементов

// ✅ РЕШЕНИЕ: кортеж
const argsTuple: [number, number] = [1, 2];
Math.atan2(...argsTuple); // Правильно: кортеж гарантирует ровно 2 числа

// Или с as const:
const argsConst = [1, 2] as const;
Math.atan2(...argsConst); // Правильно
```

#### 8. Разница между подходами

```typescript
// Обычный массив - любое количество чисел
const array: number[] = [1, 2, 3, 4, 5]; // OK

// Кортеж с явной типизацией - фиксированная длина
const tuple1: [number, number] = [1, 2]; // OK
const tuple2: [number, number] = [1, 2, 3]; // Ошибка: лишний элемент

// Кортеж с as const - фиксированные значения
const constTuple = [1, 2] as const; // Тип: readonly [1, 2]
constTuple[0] = 3; // Ошибка: нельзя изменить readonly кортеж
```

---

### Ключевые выводы из урока

1.  **Rest параметры** (`...param: Type[]`) используются для функций с переменным количеством аргументов.
2.  **Rest параметр всегда массив** - собирает все оставшиеся аргументы в массив указанного типа.
3.  **Rest параметр должен быть последним** в списке параметров функции.
4.  **Кортежи (Tuples)** используются для массивов фиксированной длины: `[Type1, Type2]`.
5.  **Создание кортежей:**
    - Явная аннотация: `const tuple: [number, number] = [1, 2];`
    - Утверждение `as const`: `const tuple = [1, 2] as const;`
6.  **Кортежи с `as const`** являются `readonly` и имеют фиксированные значения.
7.  **Применение:** Кортежи полезны когда нужно передать в функцию точное количество аргументов.

Этот подход дает вам гибкость работы с функциями, принимающими разное количество параметров, сохраняя при этом полную типобезопасность TypeScript. Вы можете создавать как очень гибкие функции с Rest параметрами, так и строго типизированные с кортежами.
