## Общее введение

Автор переходит к новому разделу курса — **функциям в TypeScript**. В этом видео рассматриваются основы строгой типизации функций с использованием трех различных способов объявления функций в JavaScript/TypeScript.

---

## 1. Объявление функции (Function Declaration)

### Исходная JavaScript функция:

```typescript
function intro(name, age) {
  // Параметры не типизированы - TypeScript показывает ошибку
}
```

### Строгая типизация параметров:

```typescript
function intro(name: string, age: number) {
  // Теперь параметры строго типизированы
}
```

### Типизация возвращаемого значения:

```typescript
function intro(name: string, age: number): string {
  return `My name is ${name} and I am ${age} years old.`;
}
```

**Синтаксис типизации возвращаемого значения:**

- После списка параметров ставится `: Type`
- TypeScript проверяет, что функция действительно возвращает указанный тип

---

## 2. Функциональное выражение (Function Expression)

### Базовое функциональное выражение:

```typescript
const intro2 = function (name, age) {
  return `My name is ${name} and I am ${age} years old.`;
};
```

### Строгая типизация:

```typescript
const intro2 = function (name: string, age: number): string {
  return `My name is ${name} and I am ${age} years old.`;
};
```

**Особенности функционального выражения:**

- Функция присваивается переменной
- Типизация параметров и возвращаемого значения аналогична объявлению функции

---

## 3. Стрелочные функции (Arrow Functions)

### Базовая стрелочная функция:

```typescript
const intro3 = (name, age) => {
  return `My name is ${name} and I am ${age} years old.`;
};
```

### Строгая типизация:

```typescript
const intro3 = (name: string, age: number): string => {
  return `My name is ${name} and I am ${age} years old.`;
};
```

**Синтаксис стрелочных функций:**

- Более краткий синтаксис
- Типизация работает одинаково для всех видов функций

---

## 4. Проверка типов возвращаемых значений

### TypeScript проверяет соответствие:

```typescript
// ✅ КОРРЕКТНО - возвращает string
function correctFunction(): string {
  return "Hello";
}

// ❌ ОШИБКА - возвращает number вместо string
function wrongFunction(): string {
  return 42; // Ошибка: Type 'number' is not assignable to type 'string'
}
```

### Union types для возвращаемых значений:

```typescript
// Функция может возвращать разные типы
function flexibleFunction(flag: boolean): string | number {
  if (flag) {
    return "string result";
  } else {
    return 42;
  }
}
```

---

## 5. Сравнение трех подходов

### Function Declaration:

```typescript
function intro(name: string, age: number): string {
  return `My name is ${name} and I am ${age} years old.`;
}
```

### Function Expression:

```typescript
const intro2 = function (name: string, age: number): string {
  return `My name is ${name} and I am ${age} years old.`;
};
```

### Arrow Function:

```typescript
const intro3 = (name: string, age: number): string => {
  return `My name is ${name} and I am ${age} years old.`;
};
```

**Функциональные отличия:**

- **Hoisting** - объявления функций поднимаются, выражения - нет
- **this binding** - стрелочные функции не имеют собственного this
- **Синтаксис** - стрелочные функции более лаконичны

---

## 6. Практические примеры с различными типами

### Функция, возвращающая число:

```typescript
function multiply(a: number, b: number): number {
  return a * b;
}
```

### Функция, возвращающая boolean:

```typescript
function isAdult(age: number): boolean {
  return age >= 18;
}
```

### Функция, возвращающая массив:

```typescript
function createArray(length: number): number[] {
  return Array(length).fill(0);
}
```

### Функция без возвращаемого значения (void):

```typescript
function logMessage(message: string): void {
  console.log(message);
  // Не возвращает значение явно
}
```

---

## 7. Обработка ошибок TypeScript

### Типичные ошибки и их решения:

**Ошибка: Параметр имеет неявный тип 'any'**

```typescript
// ❌ ПРОБЛЕМА
function problem(name) { ... }

// ✅ РЕШЕНИЕ
function solution(name: string) { ... }
```

**Ошибка: Несоответствие возвращаемого типа**

```typescript
// ❌ ПРОБЛЕМА
function problem(): string {
  return 42; // Ошибка
}

// ✅ РЕШЕНИЕ
function solution(): number {
  return 42; // Корректно
}
```

---

## 8. Преимущества строгой типизации функций

### A. Безопасность типов:

```typescript
// TypeScript предотвращает эти ошибки:
intro(123, "25"); // ❌ Неверные типы параметров
let result: number = intro("John", 30); // ❌ Неверный тип результата
```

### B. Автодополнение в IDE:

```typescript
// IDE знает типы параметров и подсказывает:
intro("John", 30); // При наведении показывает: (name: string, age: number) => string
```

### C. Рефакторинг:

```typescript
// При изменении сигнатуры функции TypeScript найдет все места использования
function calculateTotal(price: number, quantity: number): number {
  return price * quantity;
}

// TypeScript проверит, что везде передаются правильные параметры
```

---

## Итог от автора

Автор подчеркивает:

1. **Три способа объявления функций** в TypeScript с одинаковой типизацией
2. **Обязательная типизация параметров** - предотвращает неявные `any`
3. **Типизация возвращаемых значений** - делает функции предсказуемыми
4. **TypeScript проверяет соответствие** типов на этапе компиляции
5. **Union types** позволяют функциям возвращать разные типы

### Мой итог как разработчика

Вы изучили фундаментальные основы работы с функциями в TypeScript:

1. **Единообразие типизации:** Все три способа объявления функций используют одинаковый синтаксис типизации.

2. **Практические рекомендации:**

   ```typescript
   // ✅ ХОРОШО - полная типизация
   function calculateTotal(price: number, quantity: number): number {
     return price * quantity;
   }

   // ❌ ПЛОХО - неполная типизация
   function calculateTotal(price, quantity) {
     return price * quantity;
   }
   ```

3. **Безопасность и надежность:** Строгая типизация функций предотвращает целый класс runtime-ошибок, связанных с неверными типами данных.

4. **Подготовка к продвинутым темам:** Эта основа необходима для понимания:

   - **Опциональные параметры** и параметры по умолчанию
   - **Перегрузки функций** (function overloading)
   - **Generic функции**
   - **Типы функций** и callback-и

5. **Производительность:** Вся проверка типов происходит на этапе компиляции, не влияя на runtime-производительность.

**Резюме:** Правильная типизация функций — это первый шаг к созданию надежных TypeScript-приложений. Она обеспечивает предсказуемость поведения функций, улучшает автодополнение в IDE и предотвращает множество распространенных ошибок. Все три способа объявления функций равноправны с точки зрения типизации — выбор между ними зависит от стиля кода и конкретных требований.
