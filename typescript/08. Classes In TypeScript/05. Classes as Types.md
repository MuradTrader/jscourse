## Классы как типы в TypeScript

### 1. Основная концепция

Автор объясняет, что классы в TypeScript выполняют двойную роль:

- **Шаблон для создания объектов** (как мы уже знаем)
- **Тип данных** (новая важная концепция)

```typescript
class User {
  name: string;
  email: string;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }

  greet() {
    return `Hello ${this.name}`;
  }
}

// TypeScript автоматически понимает, что user имеет тип User
const user = new User("John", "john@email.com");
```

### 2. Автоматический вывод типов (Type Inference)

Когда вы создаете объект через `new User()`, TypeScript **автоматически** определяет его тип как `User`:

```typescript
const user = new User("John", "john@email.com");
// TypeScript понимает: const user: User
```

Вам не нужно явно указывать тип - TypeScript делает это за вас через **вывод типов**.

### 3. Явная аннотация типа

Хотя TypeScript автоматически выводит тип, вы можете явно указать его:

```typescript
const user: User = new User("John", "john@email.com");
const user2: User = new User("Mark", "mark@email.com");
```

**Почему это работает?** Потому что класс `User` одновременно является и **типом** `User`.

### 4. Строгая проверка структуры объектов

TypeScript гарантирует, что объекты типа `User` строго соответствуют определению класса:

#### ❌ Нельзя добавить несуществующие свойства:

```typescript
const user = new User("John", "john@email.com");
user.lastName = "Doe"; // ОШИБКА!
// Property 'lastName' does not exist on type 'User'
```

#### ❌ Нельзя изменить типы свойств:

```typescript
user.name = 123; // ОШИБКА!
// Type 'number' is not assignable to type 'string'
```

#### ❌ Нельзя создать объект с неполной структурой:

```typescript
const incompleteUser: User = {
  name: "John",
  // ОШИБКА: Property 'email' is missing
};
```

### 5. Почему это важно?

Автор подчеркивает, что это **ключевая особенность** TypeScript:

1. **Безопасность типов** - предотвращает случайные ошибки
2. **Автодополнение в редакторах** - IDE покажет только существующие свойства и методы
3. **Предсказуемость кода** - всегда знаете, с какой структурой работаете
4. **Облегчение рефакторинга** - если изменить класс, TypeScript покажет все места, где нужно обновить код

### 6. Сравнение с другими подходами

**Без класса как типа:**

```typescript
// Пришлось бы создавать отдельный тип
type User = {
  name: string;
  email: string;
  greet: () => string;
};

// И отдельный класс
class UserClass {
  // ...та же реализация
}
```

**С классом как типом:**

```typescript
// Один класс решает обе задачи
class User {
  // ...реализация
}
// Используется и для создания объектов, и как тип
```

### 7. Практическое применение

```typescript
// Класс как тип в функциях
function printUser(user: User) {
  console.log(user.name);
  console.log(user.email);
  console.log(user.greet());
}

// Класс как тип в массивах
const users: User[] = [
  new User("John", "john@email.com"),
  new User("Mark", "mark@email.com"),
];

// Класс как тип для возвращаемого значения
function createUser(name: string, email: string): User {
  return new User(name, email);
}
```

### Ключевые выводы:

1. **Класс = Тип** - каждый класс автоматически становится типом в TypeScript
2. **Автовывод** - TypeScript сам определяет тип при создании объектов через `new`
3. **Строгая проверка** - объекты должны точно соответствовать структуре класса
4. **TypeScript следит за типами** - не позволяет добавлять лишние свойства или менять типы
5. **Это фундаментальная особенность** - будет использоваться постоянно в TypeScript

Эта концепция очень важна для понимания TypeScript! Она показывает, как TypeScript объединяет объектно-ориентированное программирование и статическую типизацию в единую мощную систему.
