## Optional и Readonly свойства в классах TypeScript

### 1. Optional (необязательные) свойства

#### Проблема

Ранее при попытке добавить несуществующее свойство TypeScript выдавал ошибку:

```typescript
user.lastName = "Doe"; // Ошибка: Property 'lastName' does not exist
```

#### Решение - необязательные свойства

Добавляем свойство с символом `?`:

```typescript
class User {
  name: string;
  email: string;
  lastName?: string; // Необязательное свойство

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
    // lastName не инициализируем - это нормально для optional
  }
}
```

#### Что это дает:

- **TypeScript понимает**, что `lastName` может быть `string` или `undefined`
- **Не требует инициализации** в конструкторе
- **Позволяет присваивать** значение после создания объекта:

```typescript
const user = new User("John", "john@email.com");
user.lastName = "Doe"; // Теперь работает!
```

### 2. Optional параметры в конструкторе

Можно сделать параметр конструктора необязательным:

```typescript
class User {
  name: string;
  email: string;
  lastName?: string;

  constructor(name: string, email: string, lastName?: string) {
    this.name = name;
    this.email = email;
    this.lastName = lastName; // Присваиваем, если передано
  }
}
```

#### Использование:

```typescript
// Без lastName
const user1 = new User("John", "john@email.com");

// С lastName
const user2 = new User("Alice", "alice@email.com", "Doe");
```

### 3. Readonly (только для чтения) свойства

#### Проблема

Иногда нужно запретить изменение свойства после создания объекта.

#### Решение - модификатор `readonly`

```typescript
class User {
  name: string;
  readonly email: string; // Только для чтения!
  lastName?: string;

  constructor(name: string, email: string, lastName?: string) {
    this.name = name;
    this.email = email;
    this.lastName = lastName;
  }
}
```

#### Что это дает:

- **Присвоение при создании** - работает в конструкторе
- **Запрет изменения** после создания:

```typescript
const user = new User("John", "john@email.com");
user.email = "new@email.com"; // ОШИБКА: Cannot assign to 'email' because it is a read-only property
```

### 4. Сравнение поведения

#### Без `readonly`:

```typescript
email: string;
// Можно менять: user.email = "new@email.com";
```

#### С `readonly`:

```typescript
readonly email: string;
// Нельзя менять после конструктора
```

### 5. Практический пример

```typescript
class User {
  name: string;
  readonly email: string; // Обязательное, нельзя менять
  lastName?: string; // Необязательное, можно менять
  readonly id: number = Date.now(); // Readonly с default значением

  constructor(name: string, email: string, lastName?: string) {
    this.name = name;
    this.email = email;
    this.lastName = lastName;
  }
}

// Использование:
const user1 = new User("John", "john@email.com");
const user2 = new User("Alice", "alice@email.com", "Doe");

user1.name = "Johnny"; // ✅ Можно менять
user1.lastName = "Smith"; // ✅ Можно устанавливать optional
// user1.email = "new@email.com"; // ❌ Ошибка - readonly
// user1.id = 123;               // ❌ Ошибка - readonly
```

### 6. TypeScript проверки

#### Для optional свойств:

- Не требуют инициализации в конструкторе
- Могут быть `undefined`
- Можно присваивать после создания

#### Для readonly свойств:

- Должны быть инициализированы в конструкторе (если нет default значения)
- Нельзя изменять после создания
- Обеспечивают иммутабельность

### 7. Комбинации модификаторов

Можно комбинировать с другими модификаторами (которые пройдем позже):

```typescript
class User {
  public name: string;
  private readonly id: number; // private + readonly
  protected readonly createdAt: Date; // protected + readonly
}
```

### Ключевые выводы:

1. **Optional свойства (`?`)** - могут отсутствовать, TypeScript не требует их инициализации
2. **Readonly свойства** - можно установить только при создании, затем только чтение
3. **TypeScript строго проверяет** эти модификаторы во время компиляции
4. **Повышают безопасность** - предотвращают случайные изменения важных данных
5. **Делают код понятнее** - явно показывают намерения разработчика

Эти модификаторы очень полезны для создания надежных и предсказуемых классов! Они помогают предотвратить множество ошибок на этапе разработки.
