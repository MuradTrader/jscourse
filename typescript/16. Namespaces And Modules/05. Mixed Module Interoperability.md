## Введение в совместимость модулей

### 1. Поддержка Node.js 16+

Автор объясняет, что TypeScript поддерживает совместимость между CommonJS и ES модулями, начиная с **Node.js 16**.

**Что это значит:**

- Node.js 16+ поддерживает оба формата модулей
- TypeScript тоже поддерживает эту совместимость
- Но только если вы указываете `node16` или `nodenext` в настройках

### 2. Конфигурация TypeScript

**Изменения в `tsconfig.json`:**

```json
{
  "compilerOptions": {
    "module": "node16" // или "nodenext"
  }
}
```

**Зачем это нужно:**

- Позволяет смешивать CommonJS и ES модули в одном проекте
- TypeScript правильно компилирует оба формата
- Соответствует поведению Node.js 16+

## Работа с CommonJS модулями

### 3. Создание CommonJS модуля

Автор создает файл `functions/strings.ts`:

```typescript
function printHello(): void {
  console.log("Hello world");
}
```

### 4. Проблема с экспортом CommonJS

**Попытка 1 (ошибка):**

```typescript
module.exports = printHello; // ОШИБКА!
```

**Проблема:** TypeScript не знает о `module.exports` без типов Node.js

### 5. Решение без установки типов

**Альтернативный синтаксис TypeScript:**

```typescript
export = printHello;
```

**Импорт в другом файле:**

```typescript
import printHello = require("./functions/strings");
```

**Объяснение:**

- `export =` - специальный синтаксис TypeScript для CommonJS
- `import ... = require()` - TypeScript-способ импорта CommonJS

### 6. Решение с установкой типов Node.js

**Установка типов:**

```bash
npm install --save-dev @types/node
```

**После установки работает обычный синтаксис:**

```typescript
// Экспорт
module.exports = printHello;

// Импорт
const printHello = require("./functions/strings");
```

**Почему это работает:**

- Пакет `@types/node` добавляет типы для глобальных объектов Node.js
- TypeScript теперь понимает `module`, `exports`, `require`

## Работа с ES модулями

### 7. Создание ES модуля

Файл `functions/math.ts`:

```typescript
export function add(a: number, b: number): number {
  return a + b;
}
```

**Импорт ES модуля:**

```typescript
import { add } from "./functions/math";
```

## Совместное использование обоих форматов

### 8. Пример смешанного использования в `app.ts`

```typescript
// CommonJS импорт
const printHello = require("./functions/strings");

// ES модуль импорт
import { add } from "./functions/math";

// Использование обоих
printHello();
console.log(add(5, 2));
```

### 9. Компиляция и запуск

**Результат компиляции:**

- TypeScript создает правильный CommonJS код для `strings.js`
- TypeScript создает правильный ES модуль код для `math.js`
- В `app.js` правильно смешиваются оба подхода

**Запуск в Node.js:**

```bash
node dist/app.js
# Вывод:
# Hello world
# 7
```

## Ключевые моменты из урока

### 10. Когда это важно

- **Важно:** Если вы работаете напрямую с Node.js и TypeScript
- **Не важно:** Если используете фреймворки (React, Angular, etc.) или сборщики (Webpack, Vite) - они уже настроены

### 11. Практические сценарии

1. **Legacy проекты** - постепенный переход с CommonJS на ES модули
2. **Сторонние библиотеки** - одни используют CommonJS, другие ES модули
3. **Миграция проектов** - поэтапное обновление кода

### 12. Альтернативные инструменты

Автор упоминает `ts-node` - инструмент для запуска TypeScript напрямую в Node.js без компиляции.

## Итоговые выводы

1. **Node.js 16+** поддерживает оба формата модулей
2. **TypeScript** требует настройки `module: "node16"` для совместимости
3. **Без `@types/node`** нужно использовать специальный синтаксис TypeScript
4. **С `@types/node`** работает привычный Node.js синтаксис
5. **Совместимость реальна** - можно смешивать оба формата в одном проекте

## Рекомендации автора

- Для новых проектов используйте **ES модули**
- Для существующих проектов можно постепенно мигрировать с CommonJS на ES модули
- TypeScript обеспечивает плавный переход между форматами

Этот урок очень практичен и показывает, как TypeScript решает реальные проблемы совместимости, с которыми сталкиваются разработчики при работе с разными системами модулей.
