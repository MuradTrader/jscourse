## Переход с Namespaces на ES модули

### 1. Изменения в конфигурации TypeScript

**Было (для namespaces):**

```json
{
  "compilerOptions": {
    "module": "AMD",
    "outFile": "./dist/app.js"
  }
}
```

**Стало (для ES модулей):**

```json
{
  "compilerOptions": {
    "module": "ESNext"
    // "outFile": "./dist/app.js" - ЗАКОММЕНТИРОВАНО
  }
}
```

**Объяснение изменений:**

- **`"module": "ESNext"`** - использует самые современные ES модули
- **Убрали `outFile`** - теперь каждый файл компилируется отдельно (как и должно быть с модулями)
- **Больше не нужен AMD** - переходим на стандартные ES модули

### 2. Изменения в HTML

```html
<!-- БЫЛО -->
<script src="dist/app.js"></script>

<!-- СТАЛО -->
<script type="module" src="dist/app.js"></script>
```

**Важность `type="module"`:**

- Сообщает браузеру, что это ES модуль
- Включает поддержку `import/export` в браузере
- Раньше для этого нужны были сборщики (Webpack), теперь браузеры поддерживают напрямую

## Преобразование Namespace в классы с ES модулями

### 3. Преобразование CommonUtils

**БЫЛО (namespace):**

```typescript
namespace CommonUtils {
  export function log(message: string): void {
    console.log(`Log: ${message}`);
  }
}
```

**СТАЛО (class с ES модулями):**

```typescript
export class CommonUtils {
  static log(message: string): void {
    console.log(`Log: ${message}`);
  }
}
```

**Ключевые изменения:**

- `namespace` → `class`
- `export function` → `static method`
- Добавлен `export` для класса

### 4. Преобразование MathUtils

**БЫЛО (namespace с reference):**

```typescript
/// <reference path="common-utils.ts" />

namespace MathUtils {
  export function add(a: number, b: number): number {
    CommonUtils.log(`Adding ${a} and ${b}`);
    return a + b;
  }
}
```

**СТАЛО (class с import):**

```typescript
import { CommonUtils } from "./common-utils.js"; // ОБРАТИТЕ ВНИМАНИЕ на .js

export class MathUtils {
  static add(a: number, b: number): number {
    CommonUtils.log(`Adding ${a} and ${b}`);
    return a + b;
  }
}
```

## Критически важный момент: расширения .js

### 5. Почему нужно указывать `.js` в импортах

```typescript
// НЕПРАВИЛЬНО - вызовет ошибку 404 в браузере
import { MathUtils } from "./utils/math-utils";

// ПРАВИЛЬНО - браузер найдет файл
import { MathUtils } from "./utils/math-utils.js";
```

**Объяснение:**

- Браузер ищет конкретные файлы по имени
- TypeScript компилируется в JavaScript (.ts → .js)
- Поэтому в импортах указываем `.js` файлы
- Это требование браузера, а не TypeScript

## Работа с типами и интерфейсами в модулях

### 6. Экспорт интерфейсов

Создаем файл `add-output.interface.ts`:

```typescript
export interface AddOutput {
  sum: number;
  class: string;
}
```

**Или как default export:**

```typescript
export default interface AddOutput {
  sum: number;
  class: string;
}
```

### 7. Использование интерфейсов в модулях

```typescript
import { CommonUtils } from "./common-utils.js";
import { AddOutput } from "./add-output.interface.js";

export class MathUtils {
  static add(a: number, b: number): AddOutput {
    CommonUtils.log(`Adding ${a} and ${b}`);
    return {
      sum: a + b,
      class: "MathUtils",
    };
  }
}
```

**Важно:** TypeScript удаляет типы при компиляции, поэтому импорт интерфейсов не влияет на итоговый JavaScript код.

## Итоговая структура после преобразования

### Файлы:

```
src/
├── utils/
│   ├── common-utils.ts
│   ├── math-utils.ts
│   ├── string-utils.ts
│   └── add-output.interface.ts
└── app.ts
```

### app.ts (финальная версия):

```typescript
import { MathUtils } from "./utils/math-utils.js";
import { StringUtils } from "./utils/string-utils.js";

let sum = MathUtils.add(2, 5);
let combined = StringUtils.add("hello", "world");

console.log(sum);
console.log(combined);
```

## Ключевые преимущества ES модулей над Namespaces

1. **Стандартизация** - ES модули это стандарт JavaScript
2. **Лучшая поддержка инструментов** - современные сборщики оптимизированы под ES модули
3. **Tree-shaking** - возможность удалять неиспользуемый код
4. **Ленивая загрузка** - динамические импорты
5. **Упрощенная конфигурация** - не нужны тройные ссылки и компиляция в один файл

## Главные выводы автора

1. **ES модули полностью поддерживают TypeScript** - можно импортировать/экспортировать классы, функции, интерфейсы, типы
2. **Важно указывать `.js` расширения** в импортах для работы в браузере
3. **Static методы** позволяют использовать функциональность без создания экземпляров классов
4. **Интерфейсы и типы** экспортируются так же, как и обычный код
5. **Браузеры современные** понимают ES модули без дополнительных инструментов сборки

Этот урок демонстрирует современный и рекомендуемый подход к организации кода в TypeScript проектах, который используется в реальной разработке.
