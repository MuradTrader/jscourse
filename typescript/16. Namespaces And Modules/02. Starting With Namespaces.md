## Создание функций и возникновение проблемы

### 1. Создание математических функций

Автор начинает с создания функций для работы с числами:

```typescript
// Функция для сложения чисел
function add(a: number, b: number): number {
  return a + b;
}

// Функция для вычитания чисел
function subtract(a: number, b: number): number {
  return a - b;
}
```

**Пояснение:**

- Обе функции работают с числами (тип `number`)
- Первая возвращает сумму, вторая - разность
- Пока все работает корректно

### 2. Попытка создания строковых функций с теми же именами

Далее автор пытается создать функции для работы со строками:

```typescript
// Функция для конкатенации строк
function add(a: string, b: string): string {
  return a + b;
}

// Функция для удаления подстроки
function subtract(a: string, b: string): string {
  return a.replace(b, "");
}
```

**Возникающая проблема:**

- TypeScript сразу выдает ошибку `Duplicate identifier` (дублирующийся идентификатор)
- Это происходит потому, что в **одной области видимости** нельзя иметь две функции с одинаковым именем
- TypeScript не может различить, какую из функций `add` вы хотите использовать

## Решение с помощью пространств имен

### 3. Создание пространства имен для математических функций

```typescript
namespace MathUtils {
  function add(a: number, b: number): number {
    return a + b;
  }

  function subtract(a: number, b: number): number {
    return a - b;
  }
}
```

**Что происходит:**

- Ключевое слово `namespace` создает новое пространство имен
- Функции `add` и `subtract` теперь принадлежат пространству имен `MathUtils`
- Ошибки дублирования исчезают, так как эти функции теперь изолированы

### 4. Создание пространства имен для строковых функций

```typescript
namespace StringUtils {
  function add(a: string, b: string): string {
    return a + b;
  }

  function subtract(a: string, b: string): string {
    return a.replace(b, "");
  }
}
```

**Результат:**

- Теперь у нас есть два отдельных "контейнера" для кода
- `MathUtils.add` и `StringUtils.add` - это разные функции
- Конфликт имен полностью устранен

## Ключевая концепция: Экспорт (export)

### 5. Проблема доступа к функциям извне

Автор показывает важнейший момент:

```typescript
let sum = MathUtils.add(2, 3); // ОШИБКА!
```

**Почему ошибка?**

- Функции внутри пространства имен по умолчанию **недоступны извне**
- Они являются "приватными" для своего пространства имен
- Это механизм инкапсуляции - скрытия внутренней реализации

### 6. Решение: Ключевое слово `export`

```typescript
namespace MathUtils {
  export function add(a: number, b: number): number {
    return a + b;
  }

  export function subtract(a: number, b: number): number {
    return a - b;
  }
}
```

**Что делает `export`:**

- Делает функцию публичной и доступной извне пространства имен
- Без `export` функция может использоваться только внутри своего `namespace`
- С `export` мы можем обращаться к функции как `MathUtils.add()`

### 7. Полный рабочий код

```typescript
// Пространство имен для математических функций
namespace MathUtils {
  export function add(a: number, b: number): number {
    return a + b;
  }

  export function subtract(a: number, b: number): number {
    return a - b;
  }
}

// Пространство имен для строковых функций
namespace StringUtils {
  export function add(a: string, b: string): string {
    return a + b;
  }

  export function subtract(a: string, b: string): string {
    return a.replace(b, "");
  }
}

// Использование функций
let sum = MathUtils.add(2, 5); // 7
let combined = StringUtils.add("hello", "world"); // "helloworld"

console.log(sum); // 7
console.log(combined); // "helloworld"
```

## Важные выводы из этого урока

1. **Синтаксис пространства имен**: `namespace Name { ... }`
2. **Инкапсуляция по умолчанию**: Функции внутри namespace недоступны извне без явного указания
3. **Ключевое слово `export`**: Делает элементы пространства имен публичными
4. **Обращение к функциям**: Через точечную нотацию `NamespaceName.functionName()`
5. **Решенная проблема**: Теперь мы можем иметь функции с одинаковыми именами в разных пространствах имен

## Что показывает пример со строковыми функциями

- `StringUtils.add` - конкатенация строк ("hello" + "world" = "helloworld")
- `StringUtils.subtract` - использует метод `replace()` для удаления подстроки
  - Например: `StringUtils.subtract("hello world", "world")` вернет "hello "

Этот урок прекрасно демонстрирует практическое применение пространств имен для организации кода и решения проблемы конфликта имен.
