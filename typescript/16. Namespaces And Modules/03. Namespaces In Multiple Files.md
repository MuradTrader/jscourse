## Разделение пространств имен по файлам

### 1. Реорганизация структуры проекта

Автор создает новую структуру файлов:

```
src/
├── utils/
│   ├── math-utils.ts
│   └── string-utils.ts
└── app.ts
```

**Что происходит:**

- Каждое пространство имен теперь находится в отдельном файле
- `MathUtils` перемещено в `math-utils.ts`
- `StringUtils` перемещено в `string-utils.ts`
- Это улучшает организацию кода

### 2. Проблема: TypeScript не видит пространства имен

После перемещения в `app.ts` появляются ошибки:

```typescript
let sum = MathUtils.add(2, 5); // ОШИБКА: Cannot find name 'MathUtils'
```

**Причина:** TypeScript не знает, где искать эти пространства имен, так как они теперь в других файлах.

## Решение: тройные ссылки (Triple-Slash References)

### 3. Синтаксис тройных ссылок

```typescript
/// <reference path="utils/math-utils.ts" />
/// <reference path="utils/string-utils.ts" />
```

**Объяснение синтаксиса:**

- `///` - три слеша (обязательно!)
- `<reference path="..." />` - указывает путь к файлу
- Это директива для компилятора TypeScript, а не JavaScript-код
- Аналогично `import`, но работает только для пространств имен

## Критически важные ограничения пространств имен

### 4. Первое условие: компиляция в один файл

**Проблема:** По умолчанию TypeScript компилирует каждый `.ts` файл в отдельный `.js` файл.

**Решение в `tsconfig.json`:**

```json
{
  "compilerOptions": {
    "outFile": "./dist/app.js",
    "module": "AMD"
  }
}
```

**Что это значит:**

- `outFile` - все TypeScript файлы компилируются в один JavaScript файл
- Без этого пространства имен не будут работать между файлами

### 5. Второе условие: поддержка модулей AMD

**Проблема:** Для компиляции в один файл поддерживаются только:

- **AMD** (Asynchronous Module Definition)
- **System** модули

**НЕ поддерживаются:**

- CommonJS (используется в Node.js)
- ES6 модули (современный стандарт)

## Ключевой вывод автора о практическом использовании

### 6. Когда использовать пространства имен?

Автор делает очень важное заявление:

> **"TypeScript namespaces are usually used with declaration files."**

**Что это значит:**

- Основное применение - **файлы объявлений (.d.ts)**
- Это нужно при создании библиотек на JavaScript, которые должны работать с TypeScript
- В обычной разработке лучше использовать **ES модули**

## Расширенная функциональность: зависимости между пространствами имен

### 7. Создание общего пространства имен

Автор создает `common-utils.ts`:

```typescript
namespace CommonUtils {
  export function log(message: string): void {
    console.log(`Log: ${message}`);
  }
}
```

### 8. Использование одного пространства имен в другом

В `math-utils.ts`:

```typescript
/// <reference path="common-utils.ts" />

namespace MathUtils {
  export function add(a: number, b: number): number {
    CommonUtils.log(`Adding ${a} and ${b}`); // Используем CommonUtils
    return a + b;
  }
}
```

**Как это работает:**

1. Ссылка `/// <reference path="common-utils.ts" />` делает `CommonUtils` доступным
2. Теперь `MathUtils` может использовать функции из `CommonUtils`
3. Это создает иерархию зависимостей между пространствами имен

## Практический пример использования

```typescript
// app.ts
/// <reference path="utils/math-utils.ts" />
/// <reference path="utils/string-utils.ts" />

let sum = MathUtils.add(5, 2); // Выведет в консоль: "Log: Adding 5 and 2"
let result = StringUtils.add("hello", "world");
```

## Итоговые выводы из этого урока

1. **Организация кода:** Пространства имен можно разделять по разным файлам
2. **Связывание файлов:** Используются тройные ссылки `/// <reference path="..." />`
3. **Критические ограничения:**
   - Требуется компиляция в один файл (`outFile`)
   - Поддерживаются только AMD/System модули
4. **Практическое применение:** В основном для declaration files в библиотеках
5. **Взаимодействие:** Пространства имен могут зависеть друг от друга через ссылки
6. **Рекомендация:** В современной разработке предпочтительнее использовать ES модули

Этот урок очень важен, так как показывает не только возможности, но и серьезные ограничения пространств имен, что поможет вам сделать осознанный выбор между пространствами имен и модулями в реальных проектах.
