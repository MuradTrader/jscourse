## 1. Создание базового класса

Сначала автор создаёт класс `Person` для демонстрации работы декораторов:

```typescript
class Person {
  constructor(public name: string) {}

  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}
```

**Объяснение:**

- Класс имеет **конструктор** с параметром `name`
- Используется **сокращённый синтаксис** `public name: string` - это автоматически создаёт и инициализирует свойство класса
- Метод `greet()` выводит приветствие в консоль
- Используются **шаблонные литералы** (обратные кавычки) для строки

## 2. Создание декоратора метода

Декоратор - это обычная функция, но с определённой структурой:

```typescript
function methodLogger(target: any, context: any) {
  console.log("Target:", target);
  console.log("Context:", context);
}
```

**Объяснение параметров декоратора:**

### Параметр `target`:

- Это **сам метод**, к которому применяется декоратор
- В случае метода `greet` - это будет сама функция `greet`

### Параметр `context`:

- Это **объект с метаданными** о декорируемом элементе
- Содержит информацию о том, **где** и **как** применяется декоратор

## 3. Применение декоратора к методу

```typescript
class Person {
  constructor(public name: string) {}

  @methodLogger
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}
```

**Синтаксис применения:**

- `@` - специальный символ для применения декоратора
- `methodLogger` - имя функции-декоратора
- Декоратор размещается **непосредственно перед** тем, что он декорирует

## 4. Анализ вывода в консоль

После применения декоратора в консоли появляется:

### Для `target`:

```javascript
// Это сама функция метода greet
ƒ greet() {
    console.log(`Hello, my name is ${this.name}`);
}
```

### Для `context`:

```javascript
{
    kind: "method",        // тип декорируемого элемента
    name: "greet",         // имя метода
    isPrivate: false,      // приватный ли метод
    isStatic: false,       // статический ли метод
    isStatic: false,
    addInitializer: ƒ(),   // метод для добавления инициализаторов
    access: { ... },       // информация о доступе
    metadata: undefined    // метаданные (пока не используется)
}
```

## 5. Ключевое наблюдение о времени выполнения декораторов

**Важнейший момент:** Декораторы выполняются **во время компиляции** TypeScript в JavaScript, а не во время выполнения программы.

**Доказательство:**

- Автор **не создаёт экземпляр** класса `Person`
- **Не вызывает** метод `greet()`
- Но вывод в консоль **всё равно появляется**

**Вывод:** Декораторы - это **компиляторная функция**, которая выполняется один раз при преобразовании TypeScript в JavaScript.

## 6. Создание декоратора класса

Аналогично создаётся декоратор для всего класса:

```typescript
function classDecorator(target: any, context: any) {
  console.log("Class target:", target);
  console.log("Class context:", context);
}

@classDecorator
class Person {
  // ... содержимое класса
}
```

**Разница в выводе:**

- `target` - теперь это **весь класс** (функция-конструктор)
- `context.kind` = `"class"` (вместо `"method"`)
- `context.name` = `"Person"` (имя класса)

## 7. Важные технические детали

### Имена параметров:

- `target` и `context` - это просто имена для удобства
- Можно назвать их как угодно: `originalMethod`, `metadata` и т.д.

### Типы параметров:

- Пока используется `any` для упрощения
- В реальных проектах нужно использовать правильные типы

## Основные выводы из этого урока:

1. **Декоратор = Функция**: Это обычная функция с определёнными параметрами
2. **Два основных параметра**: `target` (что декорируем) и `context` (метаданные)
3. **Время выполнения**: Декораторы работают при компиляции, не при запуске программы
4. **Богатая информация**: Через `context` доступны многочисленные метаданные
5. **Универсальность**: Один и тот же подход работает для методов, классов и других элементов

## Что будет дальше?

Автор намекает, что в следующих уроках будут рассмотрены:

- Строгая типизация параметров декораторов
- Практическое использование метода `addInitializer`
- Реальные кейсы применения декораторов
