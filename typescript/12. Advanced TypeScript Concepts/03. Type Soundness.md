## Общее понятие надёжности (Soundness)

**Надёжность системы типов** — это свойство, которое гарантирует, что **во время выполнения программы никогда не произойдет ошибка типов**.

Простыми словами:

- **Надёжная система**: Если код компилируется без ошибок типов, то при запуске никогда не возникнет ситуация, когда вы попытаетесь выполнить операцию с неверным типом (например, вызвать метод `toUpperCase()` у числа).
- **Ненадёжная система**: Код может успешно скомпилироваться, но при выполнении всё равно могут возникнуть ошибки, связанные с несоответствием типов.

Автор подчеркивает, что TypeScript **намеренно ненадёжен**, и это осознанный компромисс между тремя качествами:

1. **Простота** (simplicity)
2. **Удобство использования** (usability)
3. **Надёжность** (soundness)

TypeScript пожертвовал полной надёжностью ради совместимости с JavaScript и удобства для разработчиков.

---

## Детальный разбор примеров ненадёжности

### 1. Утверждения типов (Type Assertions)

```typescript
let value: unknown = "hello TypeScript";
let str: number = value as number; // Опасно!
```

**Что происходит:**

- Переменная `value` на самом деле содержит строку
- С помощью `as number` мы "приказываем" TypeScript считать её числом
- TypeScript доверяет программисту и не проверяет фактическое значение

**Почему это ненадёжно:** Во время выполнения `str` содержит строку, но TypeScript считает её числом. Если вы попробуете выполнить `str.toFixed(2)`, программа упадёт с ошибкой.

### 2. Присваивание объектов с дополнительными свойствами

```typescript
type User = { name: string; age: number };

const user = { name: "Alice", age: 30, isAdmin: true };
const newUser: User = user; // TypeScript разрешает это

// Но при передаче литерала возникает ошибка:
printUser({ name: "Alice", age: 30, isAdmin: true }); // Ошибка!
```

**Что происходит:**

- TypeScript использует **структурную типизацию** - ему важно, что объект имеет все обязательные свойства
- При присваивании через переменную лишние свойства игнорируются
- При передаче литерала напрямую срабатывает **Excess Property Checking**

**Почему это ненадёжно:** Объект может содержать недокументированные свойства, что может привести к неожиданному поведению, если код полагается на точную структуру типа.

### 3. Ковариантность параметров функций (Function Parameter Bivariance)

```typescript
type Animal = { name: string };
type Dog = Animal & { breed: string };

const handleAnimal = (animal: Animal) => {
  console.log(`Handling animal: ${animal.name}`);
};

const handleDog: (dog: Dog) => void = handleAnimal; // Разрешено!

handleDog({ name: "Buddy", breed: "Labrador" });
// Внутри handleAnimal не знает о breed, но это работает
```

**Что происходит:**

- Функция, принимающая супертип (`Animal`), может быть присвоена функции, ожидающей подтип (`Dog`)
- Это называется **ковариантностью параметров**

**Почему это ненадёжно:** Функция `handleAnimal` не ожидает свойство `breed`, но вызывающий код вынужден его передавать. Если бы `handleAnimal` попыталась использовать `breed`, возникла бы ошибка времени выполнения.

### 4. Необязательность rest-параметров

```typescript
const logNumbers = (...numbers: number[]) => {
  console.log(numbers);
};

logNumbers(); // TypeScript разрешает вызов без аргументов
```

**Что происходит:**

- Rest-параметры в TypeScript по умолчанию считаются необязательными
- Даже без модификатора `?` можно вызывать функцию без передачи аргументов

**Почему это ненадёжно:** Функция может быть спроектирована так, чтобы всегда получать хотя бы один аргумент, но TypeScript не может этого гарантировать.

### 5. Совместимость функций с возвращаемым типом void

```typescript
const runFunction = (fn: () => void) => {
  fn();
};

const getPi = () => 3.14;
runFunction(getPi); // TypeScript разрешает это
```

**Что происходит:**

- Функция `getPi` возвращает число, но передаётся в `runFunction`, которая ожидает функцию, возвращающую `void`
- TypeScript разрешает это, потому что возвращаемое значение просто игнорируется

**Почему это ненадёжно:** Нарушается контракт типов. Функция заявлена как возвращающая `void`, но на самом деле возвращает значение.

---

## Философское обоснование ненадёжности TypeScript

Автор объясняет, что все эти "слабости" — **осознанный выбор**, обусловленный:

1. **Совместимостью с JavaScript**: JavaScript динамичен по своей природе, и TypeScript должен работать с существующим JS-кодом
2. **Практичностью**: Полная надёжность сделала бы язык слишком строгим и неудобным для реальной разработки
3. **Постепенным внедрением**: TypeScript designed для постепенной миграции с JavaScript

**Ключевой вывод:** TypeScript предпочитает **false negatives** (пропуск некоторых ошибок) вместо **false positives** (ложных срабатываний), которые сделали бы язык непригодным для больших JavaScript-проектов.

---

## Связь с предыдущими темами

Этот урок напрямую связан с темой **подтипов и супертипов**, показывая, как отношения между типами влияют на практические аспекты системы типов. Ненадёжность часто возникает именно на границах между типами в иерархии.

Понимание этой концепции поможет вам:

- Осознанно использовать возможности TypeScript
- Понимать, где могут скрываться потенциальные ошибки
- Писать более безопасный код, зная ограничения системы типов

Это не делает TypeScript "плохим" — наоборот, понимая эти компромиссы, вы можете эффективнее использовать его сильные стороны и обходить слабые.
