### **1. Суть discriminated unions**

**Ключевое определение из видео:**

> _«Discriminated unions — это мощный паттерн TypeScript, который помогает достичь **totality** (полноты обработки всех случаев) через общий свойство-**дискриминант**»_.

#### **Что это на практике?**

- **Discriminant (дискриминант)** — общее свойство в нескольких типах, которое **однозначно идентифицирует** конкретный тип в union.
- **Union-тип** — тип, объединяющий несколько вариантов (например, `Circle | Square | Rectangle`).
- **Цель:** Гарантировать, что при работе с таким union **все возможные случаи обрабатываются явно**, и TypeScript будет предупреждать о пропущенных вариантах.

---

### **2. Демонстрация на примере: геометрические фигуры**

#### **Шаг 1: Создание типов с общим дискриминантом**

```typescript
type Circle = {
  kind: "circle"; // Дискриминант — литеральный тип
  radius: number;
};

type Square = {
  kind: "square"; // Дискриминант — литеральный тип
  side: number;
};

type Rectangle = {
  kind: "rectangle"; // Дискриминант — литеральный тип
  length: number;
  breadth: number;
};
```

**Почему `kind` критичен?**

- Все типы имеют **общее свойство `kind`** с уникальными литеральными значениями (`"circle"`, `"square"`, `"rectangle"`).
- TypeScript использует это свойство для **сужения типа** (type narrowing) внутри условий.
- Например, если `shape.kind === "circle"`, TypeScript автоматически понимает, что `shape` — это `Circle`, и предоставляет доступ к `radius`.

---

#### **Шаг 2: Базовый union-тип и функция `getArea`**

```typescript
type Shape = Circle | Square; // Изначально только два типа

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius * shape.radius;
    case "square":
      return shape.side * shape.side;
  }
}
```

**Как работает discriminated union здесь?**

- В `switch (shape.kind)` TypeScript анализирует значение `kind`.
- В `case "circle"`:
  - TypeScript **сужает тип** `shape` до `Circle`.
  - Автоматически разрешает доступ к `shape.radius` (ошибки при обращении к `side` или `length` не будет).
- В `case "square"`:
  - TypeScript сужает тип до `Square`.
  - Разрешает доступ к `shape.side`.

**Это достигает totality для `Shape = Circle | Square`:**

- Функция обрабатывает все возможные значения `kind` (`"circle"` и `"square"`).
- Для любого валидного `shape` функция вернёт `number` → нет риска runtime-ошибок.

---

### **3. Проблема при расширении union: добавление `Rectangle`**

#### **Шаг 3: Новый тип в union → нарушение totality**

```typescript
type Shape = Circle | Square | Rectangle; // Добавлен Rectangle
```

**Что происходит:**

- Функция `getArea` **не обрабатывает** случай `kind: "rectangle"`.
- TypeScript сразу выдаёт ошибку:
  ```typescript
  function getArea(shape: Shape): number {
    // ❌ Ошибка: "Function lacks ending return statement and return type does not include 'undefined'."
  }
  ```
  **Почему?**
- Контракт функции: _«Всегда возвращать `number`»_.
- Если передать `Rectangle`, код не попадёт ни в один `case`, функция вернёт `undefined` → нарушение контракта.
- **Это прямая связь с концепцией totality из предыдущего видео:** функция перестала быть тотальной.

---

### **4. Решение: Exhaustive Checking (проверка на полноту)**

#### **Шаг 4: Добавление `default` case с типом `never`**

```typescript
function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius * shape.radius;
    case "square":
      return shape.side * shape.side;
    default:
      const _exhaustiveCheck: never = shape; // Ключевая строка!
      throw new Error(`Unhandled shape type: ${shape.kind}`);
  }
}
```

**Как это работает:**

1. **`default` case:**
   - Срабатывает, если ни один `case` не подошёл (например, для `Rectangle`).
2. **`const _exhaustiveCheck: never = shape;`**
   - `never` — тип, означающий _«эта переменная никогда не должна получить значение»_.
   - Присваивание `shape` к `never` заставляет TypeScript **проверить, все ли случаи обработаны**.
   - Если остались необработанные типы (как `Rectangle`), TypeScript выдаст ошибку:
     ```typescript
     Type 'Rectangle' is not assignable to type 'never'.
     ```
3. **`throw new Error(...)`**
   - Гарантирует, что функция **никогда не вернёт `undefined`** (сохраняя totality).
   - Ошибка будет выброшена только во время выполнения при передаче необработанного типа, но на этапе компиляции TypeScript уже предупредит о проблеме.

**Зачем `_` в `_exhaustiveCheck`?**

- Соглашение: префикс `_` означает, что переменная **намеренно не используется** (здесь она нужна только для проверки типов).
- Это помогает избежать предупреждений линтера о «неиспользуемой переменной».

---

#### **Шаг 5: Исправление ошибки — обработка `Rectangle`**

```typescript
function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius * shape.radius;
    case "square":
      return shape.side * shape.side;
    case "rectangle": // Добавлен недостающий case
      return shape.length * shape.breadth;
    default:
      const _exhaustiveCheck: never = shape;
      throw new Error(`Unhandled shape type: ${shape.kind}`);
  }
}
```

**Результат:**

- Ошибка `Type 'Rectangle' is not assignable to type 'never'` исчезает.
- TypeScript подтверждает: все возможные значения `kind` обработаны → функция снова тотальна.
- Если позже добавить новый тип (например, `Triangle`), TypeScript **сразу предупредит** об этом через ошибку в `_exhaustiveCheck`.

---

### **5. Почему это важно для разработки?**

#### **Ключевые преимущества discriminated unions:**

1. **Гарантия полноты обработки (totality):**
   - TypeScript математически доказывает, что все случаи union обработаны.
   - Нет «слепых зон» для новых типов — компилятор заставит вас обновить логику.
2. **Типобезопасное сужение (type narrowing):**
   - Внутри `case "circle"` TypeScript точно знает, что `shape` — это `Circle`, и предоставляет автодополнение для `radius`.
   - Нет необходимости в ручных проверках вроде `if ('radius' in shape)`.
3. **Документирование кода через типы:**
   - Свойство `kind` явно описывает все возможные варианты данных.
   - Новые разработчики сразу видят, какие типы поддерживаются.

#### **Реальные сценарии использования (из практики):**

- **Обработка API-ответов:**
  ```typescript
  type APIResponse =
    | { kind: "success"; data: any }
    | { kind: "error"; message: string };
  ```
- **Состояния загрузки:**
  ```typescript
  type LoadingState =
    | { kind: "idle" }
    | { kind: "loading" }
    | { kind: "success"; data: Data }
    | { kind: "error"; error: Error };
  ```
- **FSM (конечные автоматы):**
  ```typescript
  type OrderState =
    | { kind: "created" }
    | { kind: "paid"; paymentId: string }
    | { kind: "shipped"; trackingNumber: string };
  ```

---

### **6. Нюансы, на которые автор обращает внимание**

#### **Почему `throw new Error` в `default` case?**

- Это **не костыль**, а осознанная практика:
  - При компиляции TypeScript проверит полноту через `_exhaustiveCheck`.
  - Во время выполнения `throw` гарантирует, что функция никогда не вернёт `undefined` (сохраняя контракт возврата `number`).
- Если бы не было `throw`, функция могла бы вернуть `undefined` для необработанных типов → нарушение totality.

#### **Почему именно `never`?**

- `never` — «дно» системы типов TypeScript. В него можно присвоить только другие `never` или **ничего**.
- Когда вы пишете `const x: never = someValue`, TypeScript проверяет:
  - Если `someValue` может быть чем-то кроме `never` → ошибка компиляции.
  - Это идеальный механизм для exhaustive checking.

#### **Что если убрать `default` case?**

- TypeScript **не сможет проверить полноту** для union с более чем двумя вариантами.
- Пример опасности:

  ```typescript
  type Shape = Circle | Square | Rectangle;

  function getArea(shape: Shape): number {
    if (shape.kind === "circle") return ...;
    if (shape.kind === "square") return ...;
    // Нет обработки для Rectangle → ошибка компиляции!
  }
  ```

  Без `default` case и `_exhaustiveCheck` TypeScript может не заметить пропущенный тип.

---

### **7. Связь с предыдущими темами курса**

Автор специально подчёркивает связь с **totality** из прошлого видео:

> _«Discriminated unions помогают достичь totality»_.

**Как это работает вместе:**

- В прошлом видео:
  - Функция `getLength(value: string | number)` не была тотальной, пока не обработали все варианты.
- В этом видео:
  - Функция `getArea(shape: Shape)` изначально тотальна для `Circle | Square`.
  - При добавлении `Rectangle` totality нарушается → TypeScript требует обработать новый случай.
  - Exhaustive checking через `never` гарантирует, что totality восстановлена.

**Это эволюция подхода:**

1. Сначала мы учились делать функции тотальными вручную.
2. Теперь — автоматизируем этот процесс через discriminated unions + exhaustive checking.

---

### **Ключевые выводы от автора (дословно по видео)**

1. **Discriminated union = общий дискриминант + union-типы:**
   > _«Все типы в union имеют общее свойство (kind), и на его основе вы определяете, с каким типом работаете»_.
2. **Exhaustive checking — ваш защитник от ошибок:**
   > _«Когда вы добавляете новый тип в union, exhaustive check через `never` сразу покажет, где не хватает обработки»_.
3. **TypeScript защищает от человеческого фактора:**
   > _«Вы не можете забыть обработать новый тип — компилятор заставит вас это сделать»_.

---

### **Почему это профессиональный паттерн?**

- **Масштабируемость:** Добавление нового типа (например, `Triangle`) требует всего двух шагов:
  1. Расширить union `Shape`.
  2. Добавить `case "triangle"` в `switch`.  
     TypeScript сам укажет, где нужно внести изменения.
- **Надёжность:** Нет риска «незамеченных» необработанных случаев в продакшене.
- **Читаемость:** Код явно декларирует все возможные состояния через `kind`, что упрощает понимание логики.

Это не просто «типизация для галочки». Это **инструмент проектирования**, который заставляет вас продумывать все сценарии на этапе компиляции, а не когда ошибка упадёт у пользователя. Как профессиональный разработчик, я использую discriminated unions в 90% случаев работы с вариативными данными — это стандарт де-факто в production-коде на TypeScript.
