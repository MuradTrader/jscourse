### **1. Две системы типов: номинальная vs структурная**

**Ключевая мысль автора:**  
TypeScript использует **структурную систему типов** (structural typing), в отличие от номинальной (nominal typing), которая применяется в языках вроде Java/C#.

#### **Что такое номинальная типизация?**

- **Суть:** Типы считаются совместимыми **только если их имена совпадают или есть явное наследование**.
- **Пример из видео:**

  ```java
  // Java (номинальная типизация)
  class Employee { String name; int age; }
  class User { String name; int age; }

  Employee emp = new User(); // ОШИБКА КОМПИЛЯЦИИ!
  ```

  Несмотря на идентичную структуру, компилятор отвергает присваивание, так как `Employee` и `User` — разные типы по имени.

#### **Что такое структурная типизация?**

- **Суть:** Типы считаются совместимыми, **если их структуры (наборы свойств и методов) совпадают**. Имя типа не важно.
- **Пример из видео:**

  ```typescript
  interface Ball {
    diameter: number;
  }
  interface Sphere {
    diameter: number;
  }

  let ball: Ball = { diameter: 10 };
  let sphere: Sphere = { diameter: 20 };

  let myBall: Ball = sphere; // ✅ Работает! Структуры идентичны.
  let mySphere: Sphere = ball; // ✅ Также работает.
  ```

  TypeScript проверяет **только форму объекта**, а не его «имя».

---

### **2. Демонстрация структурной типизации в коде**

#### **Сценарий 1: Полная совместимость**

```typescript
interface Ball {
  diameter: number;
}
interface Sphere {
  diameter: number;
}

let ball: Ball = { diameter: 10 };
let sphere: Sphere = { diameter: 20 };

// Взаимозаменяемость:
ball = sphere; // ✅ OK
sphere = ball; // ✅ OK
```

**Почему это работает?**  
TypeScript видит, что оба типа имеют одинаковое свойство `diameter: number`, поэтому считает их совместимыми. Это называется **утиная типизация** («если ходит как утка и крякает как утка — это утка»).

---

#### **Сценарий 2: Нарушение структурной совместимости**

```typescript
interface Ball {
  diameter: number;
  color: string; // Добавили новое свойство
}
interface Sphere {
  diameter: number;
}

let ball: Ball = { diameter: 10, color: "red" };
let sphere: Sphere = { diameter: 20 };

ball = sphere; // ❌ Ошибка!
// Тип "Sphere" не может быть назначен типу "Ball".
// Свойство "color" отсутствует в типе "Sphere".
```

**Важный нюанс:**  
TypeScript проверяет **надмножество свойств**. Если целевой тип (`Ball`) требует больше свойств, чем есть в источнике (`Sphere`), присваивание запрещено.

---

#### **Сценарий 3: Частичная совместимость (избыточные свойства)**

```typescript
interface Ball {
  diameter: number;
}
interface Tube {
  diameter: number;
  length: number; // Дополнительное свойство
}

let tube: Tube = { diameter: 12, length: 3 };
let ball: Ball = tube; // ✅ OK!

// Но обратное не сработает:
let anotherTube: Tube = ball; // ❌ Ошибка!
// Свойство "length" отсутствует в типе "Ball".
```

**Почему так происходит?**

- **`tube` → `ball` работает**, потому что `tube` содержит все свойства, требуемые `Ball` (`diameter`). Избыточное свойство `length` игнорируется — это безопасно.
- **`ball` → `tube` не работает**, потому что `ball` не содержит обязательного свойства `length`.

**Это поведение называется:**  
**Soundness** (корректность) типовой системы. TypeScript гарантирует, что при чтении свойства `length` из `Tube` мы никогда не получим `undefined`.

---

### **3. Эмуляция номинальной типизации в TypeScript**

**Проблема, которую решает автор:**  
Структурная типизация иногда слишком гибкая. Например, нам нужно гарантировать, что строка прошла валидацию перед использованием.

#### **Шаг 1: Базовый сценарий с проблемой**

```typescript
let validateUserInput = (input: string): string => input.trim();
let printName = (name: string) => console.log(name);

// Проблема: можно пропустить валидацию!
printName("Mark"); // ❌ Нет проверки! Опасно для безопасности.
printName(validateUserInput("John")); // ✅ Хорошо, но нет гарантий.
```

TypeScript не может отличить «обычную» строку от «валидированной».

#### **Шаг 2: Создание «бренда» для номинальной типизации**

```typescript
type ValidatedInputString = string & { __brand: "validated-input" };
```

**Что здесь происходит:**

- `string & { __brand: 'validated-input' }` — это **intersection type** (пересечение типов).
- Значение должно быть:
  1. Строкой (`string`).
  2. Иметь свойство `__brand` с литеральным типом `'validated-input'`.
- **Важно:** Это чисто типизационный трюк. На этапе выполнения объект не будет содержать `__brand` — TypeScript уберёт его после компиляции.

#### **Шаг 3: Применение «бренда»**

```typescript
let validateUserInput = (input: string): ValidatedInputString => {
  let validated = input.trim();
  return validated as ValidatedInputString; // Type assertion
};

let printName = (name: ValidatedInputString) => console.log(name);

// Теперь:
printName(validateUserInput("John")); // ✅ OK
printName("Mark"); // ❌ Ошибка!
// Аргумент типа "string" нельзя назначить параметру типа "ValidatedInputString".
```

**Как это работает на уровне типов:**

- Обычная строка `"Mark"` не имеет «бренда» `__brand: 'validated-input'`, поэтому TypeScript блокирует вызов.
- Результат `validateUserInput` помечен как `ValidatedInputString` через **type assertion** (`as ValidatedInputString`), что даёт гарантию компилятору.

---

### **4. Почему это важно на практике?**

- **Безопасность:** Такой подход предотвращает ошибки, когда данные используются без валидации/санитизации (например, в SQL-запросах или рендере HTML).
- **Документирование:** Тип `ValidatedInputString` явно описывает контракт: «Эта строка прошла проверку».
- **Гибкость TypeScript:** Несмотря на структурную типизацию «из коробки», язык позволяет эмулировать номинальную типизацию там, где это критично.

---

### **5. Ключевые выводы от автора**

1. **TypeScript по умолчанию использует структурную типизацию** — типы совместимы при совпадении структур.
2. **Но вы можете эмулировать номинальную типизацию** через:
   - Intersection types (`string & { __brand: ... }`).
   - Уникальные свойства-«метки» (например, `__brand`).
3. **Это не нарушает философию TypeScript:**  
   Система типов остаётся структурной, но даёт инструменты для строгих проверок, когда это необходимо для безопасности и надёжности кода.

---

### **Дополнительные детали из видео**

- **`__brand` — соглашение, а не правило:** Вы можете использовать любое имя свойства (например, `_validated`), но `__brand` — общепринятый паттерн.
- **Type assertion (`as`) — инструмент ответственности:** Вы берёте на себя гарантию, что данные соответствуют типу. Используйте его осознанно!
- **Этот паттерн называется «Branded Types»:** Он широко применяется в production-коде (например, в библиотеках для работы с денежными суммами, ID, email-адресами).
