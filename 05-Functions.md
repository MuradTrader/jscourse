## \*ПАРАМЕТРЫ ФУНКЦИИ ПО УМОЛЧАНИЮ

```javascript
const bookings = [];
```

Давайте создадим простую функцию:

```javascript
const createBooking = function (flightNum, numPassengers, price) {
  const booking = {
    flightNum,
    numPassengers,
    price,
  };
  console.log(booking);
  bookings.push(booking);
};
createBooking("LH123"); // result / >{flightNum: 'LH123', numPassengers: undefined, price: undefined}
```

Тут мы видим что не определили два параметра функции, мы присвоили аргумент 'LH123' только одному параметру flightNum.  
И видим что аргумент 'LH123' параметра flightNum, добавилось внутри объекта booking как вложенный объект flightNum.  
А остальные параметры не определены undefined, потому что мы не указали значения для этих параметр.

И теперь мы можем использовать короткое замыкания в своих интересах:  
Мы сделаем это старым способом:  
Мы переназначим параметр numPassengers равным единицы 1, с помощью оператора ||.  
Точно также и параметр price будем переназначать.

```javascript
const createBooking = function (flightNum, numPassengers, price) {
  numPassengers = numPassengers || 1;
  price = price || 199;
  const booking = {
    flightNum,
    numPassengers,
    price,
  };
  console.log(booking);
  bookings.push(booking);
};
```

Данный способ, старый способ который используется в ES5.

Давайте напишем тоже самое, более современным способ ES6:

```javascript
const createBooking = function (flightNum, numPassengers = 1, price = 199) {
  const booking = {
    flightNum,
    numPassengers,
    price,
  };
  console.log(booking);
  bookings.push(booking);
};
createBooking("LH123"); // result / >{flightNum: 'LH123', numPassengers: 1, price: 199}
```

Конечно мы можем задавать аргументы для всех параметров при вызове функии:  
Таким образом:

```javascript
createBooking("LH123", 1, 199);
```

Мы присвоили аргуметы для всех параметров по умолчанию.

Но самое интересное в значениях по умолчанию, это то, что они могут содержать любое выражения которые возвращают значения.  
Например:

```javascript
function(flightNum = 1 * 10, numPassengers = 10 / 2, price = 199 * 1.2)
```

Еще более интересное в значения по умолчанию, это то, что мы можем использовать значения других параметров, которые были заданы ранее.  
Пример:

```javascript
function(flightNum, numPassengers, price = 199 * numPassengers) <<<
console.log('LH123', 2); // result / >{flightNum: 'LH123', numPassengers: 2, price: 398}
```

Мы присвоили значения параметра numPassengers для параметра price.

Если мы хотим к примеру оставить значения параметра по умолчанию пропустив этот параметр, и указать значения для следующего параметра.  
Пишем вот так:

```javascript
function(flightNum, numPassengers = 1, price = 199 * numPassengers) <<<
console.log('LH123', undefined, 1000); // result / >{flightNum: 'LH123', numPassengers: 1, price: 1000}
```

Мы видим что параметр price был переназначен на 1000, а значения параметра numPassengers осталось по умолчанию.  
Потому что присваивания значения undefined, это тоже самое что вообще его не присваивать.  
Мы знаем что если для какого то параметра не присваивать значения при вызове функции, этот параметр будет принимать значения по умолчанию, который мы задали ему.  
Таким образом присваивания undefined в нашем примере точно такое же.  
Вот так мы пропускаем параметр у которого есть значения по умолчанию, который мы хотим чтобы был не изменным.  
И присвоить значения для следующего параметра.

// ------------------------------------------------------------------------------------ //

## \*ПЕРЕДАЧА АРГУМЕНТОВ В ФУНКЦИИ

Мы будем разбирать как работают примитивные типы данных и объекты в контексте функции:  
Давайте посмотрим на простой пример:

```javascript
const flight = 'LH234';
const jonas = {
  name: Jonas Schmedtmann,
  passport: 23455676774
};
const checkIn = function(flightNum, passenger) {
  flightNum = 'LH999';
  passenger.name = 'Mr. ' + passenger.name;

  if (passenger.passport === 23455676774) {
    alert('Check in')
  } else {
    alert('Wrong passport!')
  }
};
checkIn(flight, jonas);
console.log(flight); // result / LH234
console.log(jonas); // result / >{name: "Mr. Jonas Schmedtmann", passport: 23455676774}
```

Здесь мы видим что переменная flight у которого имеет примитивынй тип строка 'LH234',  
не изменилось, то есть осталось как есть, хотя мы его присвоили для параметра как аргумент в функцию.  
Но здесь нужно понять что мы не переназначили переменную flight, мы просто присвоили значения этой переменной,  
для параметра flightNum, и когда мы переназначаем параметр flightNum, то это не касается для переменной flight.  
Так как параметр тоже как отдельная переменная то есть новая переменная со своим значением,  
то есть переназначение идет у параметра flightNum, а переменная flight остается как есть.  
Это тоже самое что и таким образом:

```javascript
const flight = "LH234";
const flightNum = flight;
console.log(flight); // result / 'LH234'
```

Что касается объекта jonas, после присваивания как аргумент в функцию,  
то программа указывает на одну и ту же ссылку для обоих объектов,  
то есть для объекта которая находится внутри переменной jonas,  
и для объекта которая находится внутри параметра passenger функции.  
И по этому, если мы меняем что то из объекта passenger внутри области видимости функции,  
то оно поменяется и в объекте которая находится внутри переменной jonas.  
Это тоже самое что и вот таким образом:

```javascript
const jonas = {
  name: Jonas Schmedtmann,
  passport: 23455676774
};
const passenger = jonas;
```

Эти обе переменные jonas и passenger, указывают на одну и ту же ссылку на объект в памяти.  
По этому если мы изменим что то из копии passenger, то оно изменится и в оригинале объекта jonas.

Давайте напишем еще одну функцию:

```javascript
const newPassport = function (person) {
  person.passport = Math.trun(Math.random() * 10000000000);
};
newPassport(jonas);
checkIn(flight, jonas);
```

Здесь мы изменили объект jonas который присвоили для параметров person и passenger.  
Но мы указали внутри функции checkIn метод alert(), и написали что  
если passport строго равно числу 23455676774, то укажи нам во всплывающем окне 'Check in'.  
В первом функции checkIn passport строго равно числу 23455676774, это (true),  
Вызывается первая функция checkIn и появляется всплывающее окно с указанием 'Check in'.  
А внутри второй функции newPassport мы изменили passport на рондомное число, и эти изминении  
происходят в оригинальном объекте jonas.  
И таким образом внутри функции checkIn passport === 23455676774 это будет (false),  
и появляется всплывающее окно с указанием 'Wrong passport!'.  
То есть код прочитывается сверху вниз:  
При первом вызыве функции checkIn passport === 23455676774 это будет (true),  
и появляется всплывающее окно с указанием 'Check in'.  
Потом прочитывается вторая функция newPassport, после внутри функции  
checkIn passport === 23455676774 это будет (false)  
и появляется всплывающее окно с указанием 'Wrong passport!'.  
Два раза появляется всплывающее окно с разными указаниями,  
когда (true) - 'Check in'  
когда (false) - 'Wrong passport!'  
И таким образом когда взаимодействуют разные функции с одним и тем же объектом,  
у нас может возникать такая проблема.

В программировании есть 2 термина, которые постоянно используются при работе с функциями:  
1 - Передача по значению  
2 - Передача по ссылке

### 1. Что такое передача по значению?

Когда передается примитивный тип данных (число, строка, boolean, null, undefined, symbol, bigint),  
JavaScript копирует значение и передает его в функцию.  
Любые изменения внутри функции не затрагивают исходную переменную, потому что изменяется только копия.  
Пример:

```javascript
let a = 5;

function changeValue(x) {
  x = 10; // Меняем значение копии
}
changeValue(a);
console.log(a); // Выведет 5
```

Что происходит?  
Переменная a хранит значение 5.  
В функцию changeValue передается копия a, то есть тоже 5.  
Внутри функции меняется только копия. Оригинальное значение 'a' остается неизменным.

### 2. Что такое передача ссылки на объект?

Когда мы передаем объект (включая массивы и функции), на самом деле  
передается ссылка на место в памяти, где хранится объект.  
Однако важно понимать, что эта ссылка сама по себе — это тоже значение.  
Мы не передаем сам объект, а только его адрес в памяти.  
Пример:

```javascript
let obj = { key: "value" };

function changeObject(o) {
  o.key = "new value"; // Изменяем объект, на который указывает ссылка
}
changeObject(obj);
console.log(obj.key); // Выведет "new value"
```

Что происходит?  
Переменная obj хранит ссылку на объект { key: "value" }.  
В функцию передается копия этой ссылки (адреса памяти).  
Функция использует эту ссылку, чтобы изменить содержимое объекта в памяти.  
Исходный объект меняется.

### 3. Почему это не передача по ссылке?

В C++ или других языках передачи по ссылке можно менять и сами ссылки,  
например, перенаправить указатель на другой объект или переменную.  
Но в JavaScript этого нельзя сделать.  
В JavaScript ссылка передается по значению, то есть создается копия ссылки.  
Изменение этой копии не изменяет оригинальную ссылку.  
Пример:

```javascript
let obj = { key: "value" }; // Оригинальная ссылка

function reassignObject(o) {
    o = { newKey: "new value" }; // Присваиваем o новый объект,
                                  то есть хотим изменить оригинальную ссылку,
                                  с помощью копии ссылки.
                                  Но оригинальная ссылка не меняется.
}
reassignObject(obj); // копия ссылки
console.log(obj); // Выведет { key: "value" }
```

Что произошло?  
В функцию передана копия ссылки на объект.  
Внутри функции переменной 'o' присвоен новый объект { newKey: "new value" }.  
Это не влияет на оригинальную переменную obj, так как копия ссылки изменена, а не сам объект.

В JavaScript нельзя перенаправить ссылку внутри функции.  
Вы можете только изменить содержимое объекта,  
на который указывает ссылка, но не перенаправить ссылку.  
Пример:

```javascript
function reassignReference(objRef) {
  objRef = { newKey: "new value" }; // Пытаемся перенаправить ссылку
}

let obj = { key: "value" };
reassignReference(obj);

console.log(obj); // { key: "value" }
```

Почему так?  
В функцию reassignReference передается копия ссылки на объект.  
Внутри функции переменной objRef присваивается новый объект, но это изменение не затрагивает оригинальную ссылку obj.  
Оригинальный объект остается неизменным, потому что саму ссылку изменить нельзя.

### 4. Итоги для новичка

Примитивы: передаются как копии (по значению). Изменения внутри функции не влияют на исходное значение.  
Объекты: передается копия ссылки на объект, но не сам объект. Вы можете изменять содержимое объекта, но не саму ссылку.  
Это выглядит как "передача по ссылке", но на самом деле это передача копии ссылки по значению.

Если это все еще сложно, можно представить:  
Примитивы — как бумажные копии (каждая работает отдельно).  
Объекты — как адрес дома. Если вы передали адрес другу,  
он может изменить интерьер дома (данные объекта),  
но если он перепишет адрес на другой дом,  
это не изменит оригинальный адрес у вас.

Коротко:  
Мы не можем присвоить для оригинального переменного, не можем присвоить другой объект.  
То есть указывая на оригинальную переменную получить другой новый объект.  
Вот так нельзя в JS:

```javascript
let war = { key: "All" }; // оригинал
let war2 = war; // копия
war2 = { key: "Op" };
console.log(war); // result / >{key: 'All'}
```

Мы видим что не поменялось оригинал war, хотя присвоили его для war2.

Вот так можем:

```javascript
let obj = { key: "All" };
let obj2 = obj;
obj2.key = "Op";
console.log(obj); // result / >{key: 'Op'}
```

Здесь мы изменили через копию ссылки само значения оригинал объект obj.

// ------------------------------------------------------------------------------------ //

## \*ФУНКЦИИ ПЕРВОГО КЛАССА И ВЫСШЕГО ПОРЯДКА

Функции первого класса:  
Эти функции просто рассматриваются как значения.  
Функции в JS это просто еще один тип объектов,  
а раз объекты являются значениями то и функции тоже,  
а раз функции являются значениями то с ними можно делать много интересных вещей.  
Например:  
Хранить их в переменных:

```javascript
const add = (a, d) => a + b;
```

Хранить их в свойствах объектов:

```javascript
const counter = {
  value: 23,
  inc: function () {
    this.value++;
  },
};
```

Мы также можем передовать функции в качестве аргументом к другим функциям:

```javascript
const greet = () => console.log('Hey Jonas');
btn.Close.addEventListener('click', greet) <<<
```

Помните в JS являются объектами, и многие типы объектов в JS имеют методы.  
Например методы массивов push() pop() и тд.  
На самом деле у функции тоже есть методы, то есть мы можем вызывать методы функции.

```javascript
counter.inc.bind(someOtherObject);
```

Функции высшего порядка:  
Это функции которые принимают другие функции в качестве аргументов,  
или возвращают новые функции.  
1 - Когда функция принимает другую функцию, принимающая функция является высшего порядка.  
Потому что она принимает другую функцию в качестве аргумента.

```javascript
const greet = () => console.log('Hey Jonas');
btn.Close.addEventListener<<<('click', greet);
```

Обычно мы называем такую функцию которая передается в качестве аргумента,  
называем функция обратного вызова.  
Потому что функция обратного вызова будет вызвана позже,  
функцией высшего порядка.  
В данном случае функция addEventListener() вызывет функцию greet() позже,  
когда произойдет события 'click'.

2 - Функции которые возвращают другие функции:

```javascript
function count() {
  let counter = 0;
  return function () {
    counter++;
  };
}
```

Весь блок кода, вся область видимости function count() является функцией высшего порядка.

// ------------------------------------------------------------------------------------ //

## \*ФУНКИИ ВЫСШЕГО ПОРЯДКА, КОТОРЫЕ ПРИНИМАЮТ ДРУГИЕ ФУНКЦИИ В КАЧЕСТВЕ АРГУМЕНТОВ

Давайте напишем простые функции для преобразования строк:

```javascript
const oneWord = function (str) {
  return str.replace(/ /g, "").toLowerCase();
};
```

Это функция будет работать в любом месте нашего кода с любой строкой.  
И она принимает одну строку и возвращает новую строку без пробелов.

Давайте создадим еще одну функцию:

```javascript
const upperFirstWord = function (str) {
  const [first, ...other] = str.split(" ");
  return [first.toUpperCase(), ...other].join(" ");
};
```

Теперь мы можем создать функцию более высокого порядка:  
Она принимает строку в качестве второго аргумента, а также принимает функцию.

```javascript
const transformer = function (str, fn) {
  console.log(`Original string: ${str}`); // result / JavaScript is the best!
  console.log(`Transformed string: ${fn(str)}`); // result / JAVASCRIPT in the best!
};
transformer("JavaScript is the best!, upperFirstWord");
```

Мы помним что у функции есть методы, точно также у функции есть свойствы:  
Пример:

```javascript
const transformer = function (str, fn) {
  console.log(`Original string: ${str}`); // result / JavaScript is the best!
  console.log(`Transformed string: ${fn(str)}`); // result / JAVASCRIPT in the best! <<<
  console.log(`Transformed by: ${fn.name}`); // result / upperFirstWord <<<
};
transformer("JavaScript is the best!, upperFirstWord");
```

Мы тут видим свойство name для функции fn, а функция fn - это переданная функция upperFirstWord.  
То есть свойство name - это просто имя функции upperFirstWord.

Давайте попробуем сделать тоже и с другой функцией oneWord:

```javascript
const transformer = function (str, fn) {
  console.log(`Original string: ${str}`); // result / JavaScript is the best!
  console.log(`Transformed string: ${fn(str)}`); // result / javascriptinthebest! <<<
  console.log(`Transformed by: ${fn.name}`); // result / oneWord <<<
};
transformer("JavaScript is the best!, oneWord");
```

В данном случае функция transformer() является высшего порядка.  
А функции upperFirstWord и oneWord являются первого класса,  
и эти функции в наших примерах являются функциями обратного вызова.

Функции обратного вызова используются постоянно в JS:  
Большое преимущество в функциях обратного вызова в том, что это позволяет  
легко разбивать код на более удобные взаимосвязанные части.  
Второе большое преимущество в функциях обратного вызова,  
это то что функции обратного вызова, позволяют нам создавать абстракцию.  
Что такое абстракция ?  
Абстракция означает что мы скрываем детали реализации кода,  
потому что нам не важны эти детали.  
Это позволяет нам думать о проблемах на более высоком абстрактном уровне.

Например функция высшего порядка transformer, не заботится о том  
как именно функции первого класса upperFirstWord и oneWord преобразуют строка.  
Функции высшего порядка transformer не важно как это происходит.  
То есть мы могли бы написать код для преобразовании строки который находится  
внутри функциях первого класса upperFirstWord и oneWord,  
написать этот код внутри функции высшего порядка transformer,  
и это сработало бы точно также.  
Но вместо этого мы разбили этот код преобразования строки на другие функции.  
То есть мы создали новый уровень абстракции.

// ------------------------------------------------------------------------------------ //

## \*ФУНКЦИЯ ВЫСШЕГО ПОРЯДКА КОТОРАЯ ВОЗВРАЩАЕТ НОВУЮ ФУНКЦИЮ

Давайте создадим функцию:

```javascript
const greet = function (greeting) {
  return function (name) {
    console.log(`${greeting} ${name}`);
  };
};
const greeterHey = greet("Hey");
greeterHey("Jonas"); // result / Hey Jonas
greeterHey("Steven"); // result / Hey Steven
```

Что здесь происходит ?  
Мы объявили функцию greet(greeting) и внутри этой функции  
мы возвращаем новую функцию function(name) с помощью return.  
Потом мы вызываем функцию greet(greeting) передавая значения 'Hey' для параметра (greeting).  
Результат вызова этой функции greet('Hey') это возвращаемая значения с помощью return и это новая функция.  
И этот результат мы присвоили для переменной greeterHey, то есть присвоили ему новую функцию function(name).  
Потом мы вызываем новую функцию с помощью переменной greeterHey('Jonas')  
передавая значения 'Jonas' для параметра новой функции function(name).  
Вызывая функцию greeterHey('Jonas') у нас вызываются две функции, первая это greet(greeting) со значением 'Hey',  
и данная функция greet(greeting) возвращает новую функцию function(name) со значением 'Jonas'.  
И внутри новой функции function(name) выполняется данный код console.log(`${greeting} ${name}`)  
Результат в консоле: Hey Jonas  
То есть значения 'Hey' ${greeting} исходит от функции greet(greeting),  
а значения 'Jonas' ${name} исходит от функции function(name).  
Это все работает из за механизма замыкания.

То есть когда мы вызываем возвращаемую функцию function(name) с помощью переменной greeterHey(),  
так как внутри переменной greeterHey содержится возвращаемая функция function(name).  
У нас сперва вызывается функция высшего порядка это - greet(greeting) со своим значением 'Hey',  
потом данная функция возвращает вложенную функцию это - function(name) со своим значением 'Jonas'.

Что происходит технически?  
Когда вы вызываете greet('Hey'), внутри этой функции создается новая вложенная функция function(name).  
При этом greeting равен 'Hey'.  
Замыкание возникает, потому что возвращаемая функция function(name)  
"запоминает" переменную greeting из своей родительской функции greet.  
Переменная greeterHey получает эту вложенную функцию function(name),  
в которой уже закреплено значение 'Hey' для greeting.

Когда вы вызываете greeterHey('Jonas'):  
Функция function(name) срабатывает и использует замкнутое значение greeting из своего окружения ('Hey').  
name получает значение 'Jonas', переданное при вызове.

Конечно мы можем сделать простым способом:  
Пример:

```javascript
greet("Hey")("Jonas"); // result / Hey Jonas
```

Вызвали функцию greet(greeting) передавая значения 'Hey'.  
И рядом вызываем новую функцию function(name) передавая значения 'Jonas'.  
Потому что функция greet(greeting) возвращает новую функцию function(name).  
Вызывая новую функцию function(name) рядом с greet(greeting),  
у нас сразу появляется результат в консоле Hey Jonas.

Пример для стрелочной функции:

```javascript
const greetArr = (greeting) => (name) => console.log(`${greeting} ${name}`);
greetArr("Hey")("Jonas"); // result / Hey Jonas
```

// ------------------------------------------------------------------------------------ //

## \*КЛЮЧОВОЕ СЛОВО THIS В РУЧНУЮ

Пример авиакомпания Lufthansa:

```javascript
const lufthansa = {
  airline: 'Lufthansa',
  iataCode: 'LH',
  bookings: [],
  book(flightNum, name) {
    console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`);

    this.bookings.push({flight: `${this.iataCode}${flightNum}`, name });
     // result / >{airline: 'Lufthansa', iataCode: 'LH', bookings: Array(2)}
                   >bookings: Array(2)
                    >0: {flight: 'LH239', name: 'Jonas Schmedtmann'}
                    >1: {flight: 'LH635', name: 'John Smith'}
  };
};
lufthansa.book(239, 'Jonas Schmedtmann');
// result / Jonas Schmedtmann booked a seat on Lufthansa flight LH239
lufthansa.book(635, 'John Smith');
// result / John Smith booked a seat on Lufthansa flight LH635
```

Предположим что несколько лет группа Lufthansa создала новую авиакомпанию:

```javascript
const eurowings = {
  name: "Eurowings",
  iataCode: "EW",
  bookings: [],
};

const book = lufthansa.book;
book(23, "Sarah Williams"); // result / TypeError: Cannot read property 'airline' of undefined
```

Мы знаем что обычная функция которая не привязана к какому либо объекту,  
при использовании ключевое слово this внутри него, программа выдает ошибку undefined для this.  
Так как наша функция внутри объекта lufthansa присвоили переменной const book,  
при вызове функции book() здесь программа выдает значения undefined.  
То есть ключевое this здесь, не указывает на объекта lufthansa.

И как же нам решить эту проблему?  
Если мы хотим обратится к объекту lufthansa, то ключевое слово this  
должно указывать на объект lufthansa.  
Если мы хотим обратится к объекту eurowings, то ключевое слово this  
должно указывать на объект eurowings.

Для этого есть методы для функции call() и apply():  
Помните что функции это объекты, по этому у функции тоже могут быть методы.

### 1 - Метод call():

Первый аргумет - это именно то, на что мы хотим чтобы указывало ключевое слово this.  
Остальные аргументы это то, что мы хотим передать в функции объекта.

```javascript
book.call(eurowings, 23, 'Sarah Williams');
console.log(eurowings); // result / >{name: 'Eurowings', iataCode: 'EW', bookings: Array(1)}
                                       >bookings: Array(1)
                                        >0: {flight: 'EW23', name: 'Sarah Williams'}

                        //result / Sarah Williams booked a seat on undefined<<< flight EW23
                        Здесь значения undefined потому что внутри объекта ewrowings нет свойство airline.
```

Здесь мы видим что ключевое слово this указывает на объекта ewrowings,  
и таким образом для функции book мы передали значения '23' для параметра flightNum,  
а значения 'Sarah Williams' для параметра name.  
И у нас добавилось объект внутри массива bookings для объекта ewrowings.  
Вот по этому коду внутри функции book объекта lufthansa:

```javascript
this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name });
```

Хотя этот код написано внутри функции book объекта lufthansa, но с помощью метода call() для функции book,  
мы сделали так чтобы ключевое слово this указывало для объекта ewrowings.

Также для функции book названия свойств у разных объектов должны совпадать,  
так как внутри функции book названия свойств указывают на исходный объект lufthansa,  
по этому у других объектов тоже должны быть такие же названия свойств.  
Если мы хотим чтобы функция book работало и для объектов с помощью call().  
На примере выше мы видим что здесь ключевое слово this.airline указывает на объекта eurowings,  
так как данное свойство airline не существует в объекте eurowings, программа выдает значения undefined.

Таким образом мы можем в ручную указывать ключевое слово this для разных объектов с помощью метода call().  
И присваивать разные значения для параметров функции для разных объектов.

### 2 - Метод apply():

Он делает в основном тоже самое что и метод call().  
Отличие в том, что метод apply() не получает список аргументов, а вместо этого  
принимает элементы массива в качестве агрументов.  
И затем метод apply() берет элементы массива и передает их в функцию в качестве аргументов.  
Первый агрумент - это ключевое this, то есть названия объекта для которого хотим чтобы ключевое this указывало.  
Второй аргумент - это массив у которого хотим чтобы элементы присвоились в качестве агрументов для функции.  
Пример:

```javascript
const swiss = {
  airline: 'Swiss Air Lines',
  iataCode: 'LX',
  bookings: [],
};

const flightData = [583, 'George Cooper'];
book.apply(swiss, flightData);
console.log(swiss); // result / George Cooper booked a seat on Swiss Air Lines flight LX583
                    // result / >{airline: 'Swiss Air Lines', iataCode: 'LX', bookings: Array(1)}
                                  >bookings: Array(1)
                                    >0: {flight: 'LX583', name: 'George Cooper'}
```

На самом деле этот метод apply() больше не используется в современном JS:  
Более удобный способ сделать тоже самое, с помощью оператора расширения:

```javascript
book.call(swiss, ...flightData);
```

Таким образом мы присвоили для параметров flightNum и для name,  
каждый элемент по отдельности с помощью оператора расширения.

// ------------------------------------------------------------------------------------ //

## \*МЕТОД BIND ДЛЯ ФУНКЦИИ

Метод bind():  
Как и метод call(), метод bind() позволяет в ручную задать ключевое слово this для любого вызова функции.  
Разница в том что метод bind() не вызывает функцию сразу, а возвращает новую функцию,  
в которой ключевое слово this привязано к нужному значению.  
То есть мы задаем значения, который хотим использовать в методе bind().

Пример авиакомпания Lufthansa:

```javascript
const lufthansa = {
  airline: 'Lufthansa',
  iataCode: 'LH',
  bookings: [],
  book(flightNum, name) {
    console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`);

    this.bookings.push({flight: `${this.iataCode}${flightNum}`, name });
     // result / >{airline: 'Lufthansa', iataCode: 'LH', bookings: Array(2)}
                   >bookings: Array(2)
                    >0: {flight: 'LH239', name: 'Jonas Schmedtmann'}
                    >1: {flight: 'LH635', name: 'John Smith'}
  };
};
lufthansa.book(239, 'Jonas Schmedtmann');
// result / Jonas Schmedtmann booked a seat on Lufthansa flight LH239
lufthansa.book(635, 'John Smith');
// result / John Smith booked a seat on Lufthansa flight LH635
```

Другая авиакомпания eurowings:

```javascript
const eurowings = {
  airline: "Eurowings",
  iataCode: "EW",
  bookings: [],
};
```

Теперь мы можем использовать метод bind():

```javascript
book.bind(eurowings);
```

Это функция не будет вызывать функцию book(), а вернет новую функцию  
в которой ключевое слово this всегда будет равно объекту eurowings.

Давайте создадим новую функцию:

```javascript
const bookEW = book.bind(eurowings);
bookEW(23, 'Steven Williams'); // result / Steven Williams booked a seat on Eurowings flight EW23
console.log(eurowings); // result / >{airline: 'Eurowings', iataCode: 'EW', bookings: Array(1)}
                                       >bookings: Array(1)
                                        >0: {flight: 'EW23', name: 'Steven Williams'}
```

И данная функция bookEW всегда будет указывать ключевое слово this на объект eurowings.  
Здесь нам больше не нужно указывать ключевое слово this.  
В чем различие метода bind() от методов call() и aplly()?  
Это то, что при вызовае метода bind() нам нужно один раз указать  
названия объета который мы хотим чтобы ключевое слово this указывало на него.  
И потом присвоить этот метод bind() для переменной и с помощью переменной  
вызывать его кажрый раз когда мы хотим что то передать в функцию в виде аргументов.  
И потом при вызыве этой переменной, ключевое слово this всегда будет указывать на объект  
который мы переместили внутри метода bind().

Примеры для всех функции с методом bind():

```javascript
const bookLH = book.bind(lufthansa);
bookLH(239, "Jonas Schmedtmann");
const bookEW = book.bind(eurowings);
bookEW(23, "Steven Williams");
const bookLX = book.bind(swiss);
bookLX(583, "George Cooper");
```

Функция book которая мы создали внутри объекта lufthansa, и ключевое слово this  
всегда будет указывать на каждые из этих объетов и передавать разные аргументы.

Но если мы хотим передать аргумент для перематра кроме самого объекта внутри метода bind().  
Мы можем сделать это:  
Но первый аргумент это наш объект который мы указали чтобы наша слово this  
указывало на этот объект внутри метода bind().  
Второй аргумент внутри метода bind() будет, для второго параметра 'name' нашей функции book.  
Пример:

```javascript
const bookEW = book.bind(eurowings, 23);
```

При вызове функции с помощью переменной bookEW(), мы можем указать аргумент  
для первого параметра 'flightNum' нашей функции book.  
Пример:

```javascript
bookEW("Steven Williams");
```

Если пойти дальше:  
И тогда мы бы могли задать аргумент имя пассажира, внутри метода bind().  
Пример:

```javascript
const bookEW = book.bind(eurowings, 23, "Steven Williams");
```

Но это пожалуй уже слишком.

Есть еще другие ситуации в которых мы можем использовать метод bind():  
Например - когда мы используем объекты вместе с обработчиками событий:  
Давайте зададим новое свойство и новый метод для объекта lufthansa:

```javascript
lufthansa.planes = 300;
lufthansa.buyPlane = function () {
  console.log(this); // result / button class='buy'
  this.planes++;
  console.log(this.planes);
};
```

Теперь давайте прикрепим обработчик событий для элемента button class='buy':

```javascript
document.querySelector(".buy").addEventListener("click", lufthansa.buyPlane);
```

При нажатии кнопки button:  
// result / button class='buy', NaN  
И мы видим что в консоле результат, не допустимое число.  
То есть свойство planes, теперь не число.  
Причина ошибки NaN в том, что ключевое слово this указывает на элемент button class='buy'.  
Знаете почему ?  
Потому что в функции lufthansa.buyPlane для обработчики событий, ключевое слово this всегда указывает на элемент  
к которому прикреплена обработчик.

Здесь у нас еще одно докозательство того, что ключевое слово this действительно устанавливается динамически:  
Потому что если бы мы просто вызвали функцию lufthansa.buyPlane(),  
то ключевое слово this указывало бы на объект lufthansa,  
потому что именно этот объект вызывает функцию.  
Пример:

```javascript
lufthansa.planes = 300;
lufthansa.buyPlane = function() {
  console.log(this); // result / lufthansa
  this.planes++
  console.log(this.planes);
};
lufthansa.buyPlane(); // result / >{
                                     airline: 'lufthansa',
                                     iataCode: 'LH',
                                     bookings: Array(1),
                                     planes: 300,
                                     book: function,
                                     buyPlane: function,
                                   }
                                   301
```

И таким образом мы видим что ключевое слово this указывает на объект lufthansa.  
И число 300 у свойствы planes увеличилось на единицу то есть 301, как мы и хотели.

Давайте вернемся к нашему обработчику событий:  
Теперь нам нужно указать чтобы ключевое слово this ссылалось на объект lufthansa, внутри обработчика событий.  
Нам нужно в ручную указать ключевое слово this прямо внутри обработчика событий.  
Для этого используем метод call() или bind():  
Нам нужно передать функцию buyPlane а не вызывать его.  
Мы знаем что метод call() вызывает функцию, нам это не нужно.  
По этому мы используем метод bind(), потому что знаем что он вернет новую функцию.  
Пример:

```javascript
lufthansa.planes = 300;
lufthansa.buyPlane = function () {
  console.log(this);
  this.planes++;
  console.log(this.planes);
};
document
  .querySelector(".buy")
  .addEventListener("click", lufthansa.buyPlane.bind(lufthansa));
```

Теперь когда мы нажимаем на кнопку button class='buy',  
объект lufthansa должен быть ключевым словом this:  
// result / >{
airline: 'lufthansa',
iataCode: 'LH',
bookings: Array(1),
planes: 300,
book: function,
buyPlane: function,
}
301
Теперь каждый раз когда мы нажимаем на кнопку, ключевое слово this  
будет указывать на объект lufthansa, и число 300 будет увеличиваться на единицу.

Давайте рассмотрим еще один пример для метода bind(), частично передавая аргумент в функцию:  
Это означает что мы можем задать аргумент для параметра заранее, то есть внутри метода bind().  
Давайте создадим функцию для вычета налогов 10%:

```javascript
const addTax = (rate, value) => value + value * rate;
console.log(addTax(0.1, 200)); // result / 220
```

Здесь мы хотим узнать 10% от суммы 200 и к этому сложить 200.  
Для этого мы умножаем 200 на 0.1 и плюсуем 200 = 220

Давайте создадим другую функцию где налог составляет 23%:  
Теперь мы можем использовать метод bind(), и привяжем функцию addTax для расчета налогов:  
И в данном случае нам вообще не нужен ключевое слово this внутри метода bind(),  
по этот мы просто пишем null внутри метода bind(), мы можем написать любое другое значения  
внутри метода bind(), потому что с ним ничего не произойдет  
так как его не сущетсвует в функции addTax().  
Но принято использовать null:

```javascript
const addVAT = addTax.bind(null);
```

После этого, мы задаем агрумент для параметра rate функции addTax:

```javascript
const addVAT = addTax.bind(null, 0.23);
```

Теперь задаем аргумент для параметра value функции addTax, вызывая функцию с помощью переменной addVAT:

```javascript
console.log(addVAT(100)); // result / 123 (100 * 0.23 + 100)
```

Помните когда мы задаем аргументы для параметров в функию addTax, порядок аргументов важен!  
Когда мы хотим задать дробное число к примеру 0.23 внутри метода bind(),  
оно должно быть аргуметом для первого параметра rate функции addTax.  
Когда мы хотим задать целое число к примеру 100 при вызове функции с помощью перемнной addVAT,  
оно должно быть аргументом для второго параметра value функции addTax.  
Иначе это не сработает!

Точно такой же пример что и выше, но используя тактику  
функция которая возвращает другую функцию:

```javascript
const addTax = function (rate) {
  return function (value) {
    return value + value * rate;
  };
};
const addVAT = addTax(0.23);
console.log(addVAT(100)); // result / 123
```

// ------------------------------------------------------------------------------------ //

## \*ПРАКТИКА

Посмотри урок 010 Coding Challenge #1  
Я понял логику задачи.

// ------------------------------------------------------------------------------------ //

## \*НЕМЕДЛЕННО ВЫЗЫВАЕМЫЕ ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ

Иногда нам нужно в JS функция, которая вызывается один раз и больше никогда не используется.  
То есть функция исчезает после того как его вызвали один раз.  
Как это сделать?  
Можно просто создать функцию и вызвать ее один раз:

```javascript
const runOnce = function () {
  console.log("This will never run again");
};
runOnce();
```

Это функцию мы можем вызвать еще раз в другом месте кода, если захотим верно ?  
Но не то что нам нужно.

Нам нужно чтобы функция вызывалось немедленно и нам даже не нужно чтобы он сохранялось где то.  
Для этого пишем вот таким образом:

```javascript
function() {
  console.log('This will never run again');
};
```

Это у нас объявления функции, нам нужно чтобы он превратилось в выражения:  
Для этого переместим его в круглые скобки:

```javascript
(function () {
  console.log("This will never run again");
});
```

Но мы пока еще не вызвали, давайте вызовем его:

```javascript
(function () {
  console.log("This will never run again");
})(); // result / This will never run again
```

И таким образом это просто значения функции, это выражения функции с немедленным вызовом.

То же самое мы можем сделать и со стрелочной функции:

```javascript
(() => console.log("This will never run again"))();
```

Выражения функции с немедленным вызовом были созданы,  
для того чтобы хранить наши переменные внутри области видимости.  
Мы знаем что функции создают области видимости, верно ?  
И когда мы объявляем переменную внутри области видимости функции,  
мы не можем получить доступ к нему в глобальной области видимости.  
Только наоборот, объявленные переменные в глобальной области видимости,  
мы можем получить доступ к ним в локальных областях видимости.  
По этот были создани выражения функции с немедленным вызовом.  
Вызвов их один раз и больше нигде их не использовать.

Мы также можем создать блочную область видимости, для защиты данных,  
то есть для защиты наших объявленных переменных.  
Вот таким образом:

```javascript
{
  const isPrivate = 23;
}
console.log(isPrivate); // result / Ошибка
```

// ------------------------------------------------------------------------------------ //

## \*МИСТИЧЕСКИЕ ОСОБЕННОСТИ В ФУНКЦИЯХ JS

Мы говорим о замыканиях функции, используя Closures (Закрытия):  
Закрытия - это не та функция которую мы используем явно.  
По этот мы не создаем замыкания в ручную, как мы создаем новый массив или новую функцию.  
Так что в определенных ситуациях замыкания происходит просто автоматически.  
Нам просто нужно распозновать эти ситуации.  
Именно это и мы собираемся сделать в этом примере:  
Давайте создадим функцию, и именно это функция обеспечит закрытия:

```javascript
const secureBooking = function () {
  let passengerCount = 0;

  return function () {
    passengerCount++;
    console.log(`${passengerCount} passengers`);
  };
};
const booker = secureBooking();
booker(); // result / 1 passengers
booker(); // result / 2 passengers
booker(); // result / 3 passengers
```

Мы переместили возвращаемая функция внутри переменной booker,  
и таким образом переменная booker стала возвращаемой функцией.  
И вызвов возвращаемую функцию с помощью переменной booker() три раза,  
она увеличивает переменную passengerCount с 0 до 3.

Как это вообще возможно ?  
Как функция booker() может обновить переменную passengerCount?  
И так функция secureBooking() уже завершил свое выполнения,  
так что контекст ее выполения больше не находится в стеке.  
Но все же при вызове возвращаемую функцию с помощью переменной booker(),  
данная функция booker() получает доступ к переменной passengerCount,  
которая находится внутри функции secureBooking() которая уже завершилось.  
Таким образом мы можем говорить что 'закрытия' заставляет запоминать все переменные  
которые по сути существовали на момент рождения функции, верно ?  
Таким образом мы можем представить функцию secureBooking(), как место рождения этой функции.  
Также по сути и возвращаемая функция внутри переменной booker(), таким образом  
это функция запоминает все что было на момент ее создания.

Секрет замыкания в том что любая функция всегда имеет доступ к переменной  
окружения контекста выполнения в котором она была создана.  
В случае с функцией booker(), она была создана в контексте выполнения функции secureBooking().  
Таким образом функция booker() получит доступ к переменной passengerCount  
которая была объявлено внутри функции secureBooking.  
Потому что переменная passengerCount была объявлено в той области видимости  
в которой была создана возвращаемая функция booker().

Благодаря замыканию функции не теряют связь с переменными  
которые существовали в момент создания этих функции.

Давайте посмотрим логику выполнения функции booker():  
И так, функция booker() пытается увеличить переменную passengerCount на единицу,  
но данная переменная passengerCount нет в текущей области видимости возвращаемой функции,  
по этот JS сразу же проверяет есть ли она в замыкании, и JS делает это еще до того,  
как проверяет цепочку областей видимости.  
Например, если бы переменная passengerCount была объявлено  
в глобальной области видимости и было присвоино ему число 10,  
то JS все равно использовало бы ту, что в замыкании, то есть passengerCount = 0.  
То есть замыкании имеет приоритет над цепочкой областей видимости.  
По этот после выполнении возвращаемой функции booker(), переменная passengerCount становится равен числу 1.  
Затем при втором вызове функции booker(), мы получаем новый контекст выполнения а замыкания все еще остается,  
то есть все еще привязано к функциям и значения переменной passengerCount остается равен числу 1,  
теперь это возвращаемая функция booker() выполняется второй раз и переменная passengerCount увеличивается на единицу,  
и данная переменная passengerCount становитя равен числу 2.

// ------------------------------------------------------------------------------------ //

## \*ЕЩЕ ДВЕ СИТУАЦИИ ДЛЯ ЗАМЫКАНИИ

Первый пример:

```javascript
let f;
const g = function () {
  const a = 23;
  f = function () {
    console.log(a * 2);
  };
};
g(); // функция g завершил свое выполнения
f(); // result / 46
```

Это доказывает что функция f() действительно использует переменная контекста выполнения в котором она была определено.  
Даже если сама переменная f технически не была определено в этой текущей области видимости функции g().  
То есть переменная f была объявлено определено вне области видимости функции g().  
Но затем когда мы присвоили для переменной f, функцию, внутри области видимости функции g(),  
данная переменная f все еще может обращаться к переменным среды функции g(),  
в данном случае переменная f обращается к переменной a,  
которая находится внутри области видимости функции g().  
По этот переменная f может обращаться к переменной a, даже после того как функция g() завершил свое выполнения.

Теперь перейдем на следующий уровень, и создадим новую функцию:

```javascript
let f;
const g = function () {
  const a = 23;
  f = function () {
    console.log(a * 2);
  };
};

const h = function () {
  const b = 777;
  f = function () {
    console.log(b * 2);
  };
};

g(); // функция g завершил свое выполнения
f(); // result / 46

h(); // функция h завершил свое выполнения
```

Когда мы вызывем функцию h() для переменной f будет присвоино новое значения  
и это будет вторая функция которая находится внутри функции h().  
Теперь вызывем функцию f(), так как она является новой функцией которая находится внутри функции h().

```javascript
f(); // result / 1554
```

Таким образом это доказывает что переменная f которая была переназначено внутри функции h() на новую функцию,  
и данная новая функция имеет доступ к переменным, среды функции h().  
в данном случае переменная f обращается к переменной b,  
которая находится внутри области видимости функции h().

Второй пример:  
И это будет таймер.  
Так что таймер, это еще один пример того, что нам не нужно возвращать функцию,  
чтобы увидеть closure (закрытия) в действии.

```javascript
const boardPassengers = function (n, wait) {
  const perGroup = n / 3;

  console.log(`Will start boarding in ${wait} seconds`);
};
```

Щас мы будем использовать таймер внутри нашей функции boardPassengers:  
Для этого пишем setTimeout():  
Для setTimeout() нужны два параметра.  
Первый параметр - это функция которая будет выполнено.  
Второй параметр - это время через которого функция будет выполнено.  
Пример:

```javascript
setTimeout(function () {
  console.log("TIMER");
}, 1000);
// result / через одну секунду появится строка TIMER
```

То есть после одну секунду программа выполняет код который находится внутри функции.

Давайте перейдем к нашему функцию boardPassengers:

```javascript
const boardPassengers = function(n, wait) {
  const perGroup = n / 3;

  setTimeout(function(){
    console.log(`We are now boarding all ${n} passengers`);
    console.log(`There are 3 groups, each with ${perGroup} passengers`);
  }, wait * 1000);

  console.log(`Will start boarding in ${wait} seconds`);
};
boardPassengers(180, 3); // result / Will start boarding in 3 seconds
                                     Через 3 секунды
                                     We are now boarding all 180 passengers
                                     There are 3 groups, each with 60 passengers
```

Логика выполнения данной функции boardPassengers:  
Функция boardPassengers принимает два параметра:  
 n: количество пассажиров.  
 wait: время задержки перед началом посадки, в секундах.  
Внутри функции определена локальная переменная:

```javascript
const perGroup = n / 3;
```

Эта переменная вычисляет, сколько пассажиров приходится на одну из трех групп.

Асинхронный таймер setTimeout:

```javascript
setTimeout(function () {
  console.log("We are now boarding all ${n} passengers");
  console.log("There are 3 groups, each with ${perGroup} passengers");
}, wait * 1000);
```

setTimeout устанавливает задержку перед выполнением вложенной функции.  
Вложенная функция выполнится через wait \* 1000 миллисекунд.  
В данном случае, wait равно 3, значит таймер сработает через 3000 миллисекунд (или 3 секунды).

Мгновенный вывод в консоль:

```javascript
console.log(`Will start boarding in ${wait} seconds`);
```

Этот код выполняется сразу же, как только вызвана boardPassengers.  
Он выводит сообщение: Will start boarding in 3 seconds.

Вложенная функция и замыкания:  
Вложенная функция внутри setTimeout:

```javascript
function() {
  console.log('We are now boarding all ${n} passengers');
  console.log('There are 3 groups, each with ${perGroup} passengers');
}
```

Эта функция имеет доступ к переменным n и perGroup,  
определенным в boardPassengers, благодаря замыканиям (closures).  
Замыкание позволяет вложенной функции "захватить" переменные  
из внешнего лексического окружения, даже после того,  
как внешняя функция завершила выполнение.

Результат выполнения  
Когда вы вызываете:

```javascript
boardPassengers(180, 3);
```

Сразу же выполняется строка:

```javascript
console.log(`Will start boarding in ${wait} seconds`);
```

Она выводит: Will start boarding in 3 seconds.

Через 3 секунды выполняется setTimeout, который выводит:

```javascript
console.log("We are now boarding all ${n} passengers");
console.log("There are 3 groups, each with ${perGroup} passengers");
```

Ожидаемый вывод должен быть:

```
We are now boarding all 180 passengers
There are 3 groups, each with 60 passengers
```

Как работают замыкания в данном коде?  
Когда boardPassengers вызывается, она создает локальное окружение с переменными n, wait, и perGroup.  
После выполнения основного тела функции, это окружение продолжает существовать,  
потому что вложенная функция (переданная в setTimeout) ссылается на эти переменные.  
Когда через 3 секунды выполняется функция setTimeout,  
она "видит" значения n и perGroup, так как они "захвачены" замыканием.

```

```
