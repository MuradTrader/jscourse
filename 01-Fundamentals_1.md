**1. ПЕРЕМЕННЫЕ:**

```text

Мы можем использовать значение чтобы хранить их в переменных.

Например:

let firstName = 'Jonas';

Это называется объявление переменной и присваивание.

Мы объявили переменную с именем firstName и присвоили ему значение 'Jonas'

```

- **Простое объяснение:** Переменная — это "контейнер" для данных. `let firstName = 'Jonas';` создает контейнер с именем `firstName` и помещает в него строку `'Jonas'`.

- **Под капотом (память, выполнение):**

- **Шаг 1: Объявление (`let firstName`):**

- Движок JS (V8) встречает ключевое слово `let`.

- Он **выделяет память** для переменной `firstName` в текущей области видимости (здесь — глобальной или области функции).

- На этом этапе переменной присваивается специальное значение `undefined` (даже если присваивание идет сразу). Это состояние "объявлена, но не инициализирована".

- **Где в памяти:** Имя переменной `firstName` и ее _начальное_ значение (`undefined`) помещаются в **Контекст Выполнения (Execution Context)** текущей области видимости. Контекст выполнения хранится в **Стеке Вызовов (Call Stack)**.

- **Шаг 2: Присваивание (`= 'Jonas'`):**

- Строковый литерал `'Jonas'` создается в памяти.

- **Где в памяти:** Сама строка `'Jonas'` как последовательность символов хранится в **Куче (Heap)**. Это неизменяемое (immutable) примитивное значение.

- **Ссылка:** В Контексте Выполнения (в стеке) значение переменной `firstName` обновляется. Теперь оно **содержит не саму строку, а ссылку (указатель) на место в куче, где хранится строка `'Jonas'`**.

- **Итог:** Переменная `firstName` в стеке теперь указывает на участок кучи, где лежат символы `'J','o','n','a','s'`.

**2. Использование переменной:**

```text

console.log(firstName); // result / 'Jonas'

```

- **Простое объяснение:** Выводит значение переменной `firstName` в консоль.

- **Под капотом (стек, куча, функции):**

1.  Движок видит вызов функции `console.log`.

2.  **Создается Контекст Выполнения для `console.log`** и помещается на вершину **Стека Вызовов (Call Stack)**.

3.  Движок ищет значение аргумента `firstName`:

- Он смотрит в текущий Контекст Выполнения (где выполняется код). Если `firstName` там не найден, он поднимается по **Цепочке Областей Видимости (Scope Chain)**.

- Здесь `firstName` находится в глобальном Контексте Выполнения (или в контексте функции, если это внутри функции).

4.  Движок находит запись для `firstName` в соответствующем Контексте.

5.  Он видит, что значение `firstName` — это **ссылка на строку в куче**.

6.  Движок идет по этой ссылке в **Кучу (Heap)**, читает строку `'Jonas'`.

7.  Функция `console.log` (реализованная в браузере или Node.js на C++) получает эту строку и выводит ее в консоль.

8.  **Контекст выполнения `console.log` завершается, удаляется из Стека Вызовов.** Управление возвращается в предыдущий контекст.

**3. Именование переменных:**

```text

Когда мы называем переменных, должно быть понятно что содержит данная переменная!

То есть имена переменных должны быть понятными.

```

- (Это соглашение, а не техническая деталь. Под капотом движку все равно, как названа переменная. Главное — чтобы _нам_ было понятно!)

---

**4. ТИПЫ ДАННЫХ (VALUE):**

```text

В языке программирования значение могут быть разных типов.

В зависимости оттого какие данные мы хотим хранить в этих значениях.

В JS каждое значение является либо объектом либо примитивным значением,

примитивным значением является только то что не является объектом.

```

- **Простое объяснение:** Данные бывают разных видов (числа, строки, объекты и т.д.). В JS типы делятся на **примитивы** (7 штук) и **объекты**.

- **Под капотом (представление в памяти):**

- **Примитивы:**

- Хранятся **непосредственно в Контексте Выполнения (в стеке)** или **копируются целиком** при передаче.

- **Исключение:** Строка (String) технически может храниться по-разному в современных движках (может быть "интернирована" или храниться в куче, но для программиста она ведет себя как примитив). **Ключевое поведение:** Примитивы **неизменяемы (immutable)**. Вы не можете изменить существующее примитивное значение. Операция типа `str = str + '!'` создает _новую_ строку в памяти.

- **Объекты (включая массивы, функции, даты и т.д.):**

- Хранятся **в Куче (Heap)**.

- В Контексте Выполнения (стеке) или в свойствах других объектов хранится **ссылка (указатель) на адрес в куче**, где лежит сам объект.

- Объекты **изменяемы (mutable)**. Изменяя свойство объекта, вы меняете данные по адресу в куче. Все переменные, ссылающиеся на этот адрес, "увидят" изменение.

**5. Список примитивов:**

```text

1 - Число (Number)

2 - Строка (String)

3 - Логическое значение (Boolean)

4 - (Undefined)

5 - (Null)

6 - (Symbol)

7 - Большое целое число (BigInt)

```

- **Под капотом (кратко):**

- **Number:** Представлен как 64-битное число с плавающей запятой (формат IEEE 754). Хранится в стеке (или как часть ссылки в куче для объектов типа Number, но движок старается оптимизировать примитивы).

- **String:** Последовательность 16-битных символов UTF-16. Обычно хранится в куче, но движок может применять оптимизации (интернирование для одинаковых литералов). Неизменяема.

- **Boolean:** `true` или `false`. Просто 1 бит информации (хотя в памяти занимает место как часть переменной). Хранится в стеке.

- **Undefined:** Специальное значение, означающее "переменная объявлена, но значение не присвоено". Это примитив. Хранится в стеке.

- **Null:** Специальное значение, означающее "намеренное отсутствие значения объекта". Это примитив. Хранится в стеке.

- **Symbol:** Уникальное и неизменяемое значение. Создается функцией `Symbol()`. Используется как ключ для свойств объектов. Хранится в куче, но его уникальность гарантируется движком. Ссылка на него хранится в стеке.

- **BigInt:** Предназначен для целых чисел произвольной длины. Хранится в куче в специальном представлении. Ссылка на него хранится в стеке.

**6. Динамическая типизация:**

```text

Динамическая типизация в JS - Это когда мы создаем новую переменную, нам не нужно вручную определять тип данных.

В JS тип имеет именно значение а не переменная.

Таким образом переменные просто хранят значения которые имеют тип.

```

- **Простое объяснение:** В переменной можно хранить число, потом строку, потом объект. Тип привязан к _значению_ в переменной, а не к самой переменной.

- **Под капотом (V8, оптимизации):**

- Переменная (ячейка в Контексте Выполнения) — это просто **ячейка памяти, способная хранить значение (или ссылку)**.

- Когда вы присваиваете переменной новое значение (например, `javascriptIsFun = 'YES!'`), происходит:

1.  Создание нового значения (строки `'YES!'`) в куче.

2.  **Ссылка** на это новое значение **записывается** в ячейку переменной `javascriptIsFun` (в Контексте Выполнения в стеке). Старое значение (`true`) больше не имеет ссылок на него (если больше никто на него не ссылается).

3.  **Сборщик Мусора (Garbage Collector)** в движке V8 позже обнаружит, что значение `true` (и старая строка, если она была) больше не достижимо (на него нет ссылок), и освободит занимаемую им память в куче.

- **Сложность для движка (Hidden Classes, Inline Caching):** Частая смена типа в переменной **мешает оптимизациям**. V8 использует "скрытые классы" (Hidden Classes) для объектов и отслеживает типы значений в переменных. Если тип переменной меняется часто, V8 может отказаться от оптимизации кода, использующего эту переменную, и перейти к более медленному, но универсальному пути выполнения.

**7. Пример с Boolean и сменой типа:**

```text

let javascriptIsFun = true;

console.log(javascriptIsFun, typeof javascriptIsFun); // result / true - Boolean

javascriptIsFun = 'YES!'

console.log(javascriptIsFun, typeof javascriptIsFun); // result / YES! ... - String

```

- **Под капотом (`typeof`):**

- `typeof` — это оператор, который **возвращает строку, указывающую тип значения**.

- Он смотрит **на значение, которое в данный момент хранится в переменной**.

- **Как работает:** Движок проверяет внутренний флаг (или структуру данных) значения.

- Для примитивов (кроме `null`) он знает тип сразу.

- Для `null` исторически возвращается `'object'` (ошибка проектирования JS, оставленная для совместимости).

- Для объектов (включая функции, массивы) обычно возвращает `'object'`, **кроме функций** — для них `typeof` возвращает `'function'`.

**8. Undefined:**

```text

let year;

console.log(year, typeof year); // result / Undefined (значения) - Undefined (тип)

Объявили переменную но ничего не присвоили ему.

```

- **Под капотом:**

- `let year;` — создает запись для `year` в Контексте Выполнения и **автоматически инициализирует ее значением `undefined`**.

- `undefined` — это специальное примитивное значение и отдельный тип.

- `typeof undefined` закономерно возвращает `'undefined'`.

**9. Ошибка `typeof null`:**

```text

console.log(typeof null); // result / object

null - не является объектом.

```

- **Простое объяснение:** Это известная **ошибка (баг)** в языке JavaScript, оставленная для совместимости со старым кодом. `null` — это примитив!

- **Историческая причина:** В первоначальной реализации JS значения представлялись как 32-битные слова. Младшие 3 бита использовались как **тег типа**:

- `000` — объект.

- `1` — целое число (31 бит).

- `010` — число с плавающей точкой.

- `100` — строка.

- `110` — булево.

- **Значение `null` представлялось как машинный NULL-указатель (обычно `0x00` на многих платформах).** Тег типа для указателя `0x00` (все биты 0) интерпретировался как `000` (объект). Отсюда результат `'object'`.

- **Современные движки (V8):** Хотя внутреннее представление сильно изменилось, поведение `typeof null === 'object'` **намеренно сохранено** стандартом ECMAScript для обратной совместимости. Исправление сломало бы огромное количество существующих веб-сайтов.

---

**Вопросы на собеседовании и ответы (основанные на "подкапотном" разборе):**

1.  **Q: Какие типы данных есть в JavaScript?**

- **A:** В JS типы делятся на **примитивы** (7 штук: Number, String, Boolean, Undefined, Null, Symbol, BigInt) и **объекты** (Object, Array, Function, Date, RegExp и др.). Ключевое отличие: примитивы неизменяемы и хранятся/копируются по значению (хотя строки технически могут быть в куче, но ведут себя как примитивы), а объекты изменяемы и передаются по ссылке.

2.  **Q: Что такое `undefined` и `null`? В чем разница?**

- **A:**

- `undefined` означает "объявлено, но значение не присвоено". Это значение по умолчанию для неинициализированных переменных и несуществующих свойств объектов. Тип — `'undefined'`.

- `null` означает "намеренное отсутствие значения" (особенно отсутствие объекта). Это значение, которое разработчик присваивает явно. Тип — `'object'` (из-за исторической ошибки в JS), но сам `null` — примитив.

- **Под капотом:** Оба хранятся как примитивы (скорее всего, в стеке как часть контекста выполнения). `undefined` присваивается автоматически движком, `null` — разработчиком.

3.  **Q: Почему `typeof null` возвращает `'object'`?**

- **A:** Это известная **историческая ошибка** в языке JavaScript. В первоначальной реализации (1995 г.) для представления значений использовались 32-битные слова с тегом типа в младших битах. Значение `null` представлялось как нулевой указатель (`0x00`), а тег типа нулевого указателя (`000`) совпадал с тегом типа объекта. Это поведение было зафиксировано в стандарте ECMAScript для сохранения совместимости со старым кодом и исправить его уже нельзя.

4.  **Q: Что такое динамическая типизация?**

- **A:** Это означает, что **тип данных привязан к _значению_, а не к _переменной_**. Одна и та же переменная может хранить значения разных типов в разное время (например, сначала число, потом строку). Движок JS определяет тип значения во время выполнения (`runtime`).

- **Под капотом / Последствия:** Переменная — это ячейка памяти, хранящая значение или ссылку. При присваивании нового значения старому, новое значение создается (или находится), а ссылка в переменной обновляется. Частая смена типа в переменной может мешать оптимизациям JIT-компилятора (V8) и снижать производительность.

5.  **Q: Где хранятся примитивы и объекты?**

- **A:**

- **Примитивы (кроме особых случаев со строками):** Хранятся **непосредственно в стеке вызовов** как часть Контекста Выполнения (Execution Context) переменной. При передаче в функцию копируются.

- **Объекты (и большие/сложные примитивы типа длинных строк):** Хранятся **в куче (Heap)**. В стеке (или в свойствах других объектов) хранится **ссылка (указатель)** на адрес этого объекта в куче. При передаче в функцию копируется эта ссылка, сам объект не копируется.

- **Сборка мусора:** За освобождением неиспользуемой памяти в куче следит Сборщик Мусора (Garbage Collector). Он находит объекты, на которые больше нет ссылок из стека или других активных объектов, и удаляет их.

6.  **Q: Что делает оператор `typeof`?**

- **A:** Возвращает строку, указывающую тип **значения** операнда. Возвращает `'undefined'` для `undefined`, `'boolean'` для `true/false`, `'string'` для строк, `'number'` для чисел, `'bigint'` для BigInt, `'symbol'` для Symbol, `'function'` для функций и `'object'` для объектов (и массивов, и `null` — последнее является ошибкой).

Мы разбираем тему объявления переменных в JavaScript с ключевыми словами `let`, `const`, `var` и без объявления. Я объясню каждую часть подробно, включая то, как это работает под капотом: в памяти, областях видимости и как движок JS обрабатывает эти объявления.

### 1. Объявление переменных с `let`

```javascript
let age = 30;

age = 31;
```

**Что происходит под капотом:**

- **Декларация (`let age`):**

- Движок JS создает переменную в текущей **лексической области видимости** (блок, функция или глобальная область).

- Переменная инициализируется со значением `undefined` (но не доступна до присваивания из-за Temporal Dead Zone — TDZ).

- **Присваивание (`= 30`):**

- Значение `30` (примитив) записывается в память, выделенную для `age`.

- При переназначении (`age = 31`):

- Старое значение (`30`) удаляется (помечается для GC, если не используется).

- Новое значение `31` записывается в ту же ячейку памяти.

**Память:**

Переменная `age` хранится в стеке (как примитив). При изменении значения — обновляется ячейка стека.

---

### 2. Объявление без присваивания (`let age;`)

```javascript
let age;

age = 30;
```

- **Декларация:**

Переменная `age` создается в текущей области видимости со значением `undefined`.

- **Присваивание позже:**

Значение `undefined` заменяется на `30` в стеке.

---

### 3. Объявление с `const`

```javascript
const birthYear = 1991;

birthYear = 1990; // Ошибка!
```

**Особенности `const`:**

- **Должна быть инициализирована при объявлении:**

```javascript

const job; // Ошибка: Missing initializer

```

Движок требует сразу присвоить значение, потому что переприсваивание запрещено.

- **Неизменяемая ссылка:**

- Если значение примитив (число, строка) — оно **не может быть изменено**.

- Если значение объект (массив, функция) — **можно менять внутренности объекта**, но нельзя переназначить переменную:

```javascript
const user = { name: "Jonas" };

user.name = "John"; // Разрешено!

user = { name: "John" }; // Ошибка: Assignment to constant
```

**Почему так?**

- `const` гарантирует, что **ссылка** (адрес в памяти) останется неизменной. Для примитивов значение хранится напрямую (в стеке), поэтому их нельзя изменить. Для объектов в стеке хранится ссылка на кучу — можно менять содержимое кучи, но не саму ссылку.

---

### 4. Объявление с `var`

```javascript
var job = "programmer";

job = "teacher";
```

**Особенности `var`:**

1. **Функциональная область видимости:**

Переменная `var` видна внутри функции, где объявлена, или глобально, если объявлена вне функции.

```javascript
if (true) {
  var x = 10;
}

console.log(x); // 10 (блочная область не работает!)
```

2. **Поднятие (Hoisting):**

- Переменные `var` "поднимаются" в начало своей области видимости и инициализируются как `undefined`.

- Код ниже работает, хотя `x` объявлена позже:

```javascript
console.log(x); // undefined (не ошибка!)

var x = 5;
```

**Почему `var` устарел?**

- Из-за отсутствия блочной области видимости и поднятия код становится менее предсказуемым. Это приводит к ошибкам, например:

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i)); // Выведет 3, 3, 3
}
```

С `let` такой проблемы нет (блочная область видимости).

---

### 5. Объявление без ключевого слова (неявная глобальная переменная)

```javascript
lastName = "Rabadanov";
```

**Что происходит под капотом:**

- Движок ищет переменную `lastName` в текущей и родительских областях видимости.

- Если не находит — создает **глобальную переменную** (добавляет свойство в глобальный объект `window` в браузере или `global` в Node.js).

- **Проблемы:**

1. Загрязнение глобальной области видимости (риск конфликтов имен).

2. Код становится неявным и сложным для отладки.

3. Строгий режим (`'use strict'`) запрещает такое поведение:

```javascript
"use strict";

lastName = "Rabadanov"; // ReferenceError
```

---

### Ключевые отличия: `let` vs `const` vs `var`

| **Характеристика** | `let` | `const` | `var` |

|--------------------------|-------------|-------------|----------------|

| **Область видимости** | Блочная | Блочная | Функциональная |

| **Поднятие** | ✅ (в TDZ) | ✅ (в TDZ) | ✅ (как `undefined`) |

| **Переприсваивание** | Разрешено | Запрещено | Разрешено |

| **Инициализация при объявлении** | Не обязательна | Обязательна | Не обязательна |

| **Глобальная переменная**| Не добавляет свойство в `window` | Не добавляет | Добавляет (`window.varName = value`) |

---

### Как движок JS обрабатывает объявления переменных?

1. **Этап компиляции:**

- Движок "сканирует" код и создает все переменные и функции в соответствующих областях видимости.

- `var`: инициализируется как `undefined`.

- `let`/`const`: помещаются в Temporal Dead Zone (TDZ) — существуют, но недоступны до объявления.

2. **Этап выполнения:**

- Присваивание значений переменным.

- При обращении к `let`/`const` до объявления — ошибка `ReferenceError`.

**Пример TDZ:**

```javascript
console.log(x); // ReferenceError (x в TDZ)

let x = 10;
```

### Вопросы на собеседовании

1. **В чем разница между `let`, `const` и `var`?**

- `let`/`const` имеют блочную область видимости, `var` — функциональную.

- `const` нельзя переприсвоить, `let` и `var` — можно.

- `var` поднимается с инициализацией `undefined`, `let`/`const` тоже поднимаются, но недоступны до объявления (TDZ).

2. **Что такое TDZ (Temporal Dead Zone)?**

- Период между входом в область видимости и объявлением переменной, где обращение к ней вызывает `ReferenceError`.

3. **Почему `var` считается устаревшим?**

- Из-за отсутствия блочной области видимости и поднятия, что ведет к ошибкам и неочевидному поведению.

4. **Что произойдет, если объявить переменную без `let`/`const`/`var`?**

- Она станет глобальной (свойство `window`), что запрещено в строгом режиме.

5. **Можно ли изменить объект, объявленный через `const`?**

- Да, можно менять свойства объекта. `const` защищает только ссылку на объект.

---

### **1. Математические операторы и переменные**

```javascript
const ageJonas = 2037 - 1991;
```

**Что происходит под капотом:**

1. **Оператор `-`**:

   - Движок JS парсит выражение и видит оператор вычитания.
   - Значения `2037` и `1991` хранятся как примитивы типа `number` в формате IEEE 754 (64-битные числа с плавающей точкой).
   - Арифметический блок процессора выполняет вычитание.
   - Результат `46` сохраняется в памяти для переменной `ageJonas`.

2. **Оптимизация с переменной `now`**:

```javascript
const now = 2037;
const ageJonas = now - 1991;
```

- Движок создает константу `now` в стеке со значением `2037`.
- При вычислении `now - 1991`:
  - Значение `now` читается из памяти
  - Выполняется вычитание
  - Результат сохраняется в `ageJonas`
- **Преимущество**: При изменении года нужно обновить только `now`.

---

### **2. Различные математические операторы**

```javascript
console.log(ageJonas * 2, ageJonas / 10, 2 ** 3);
```

**Механизм работы:**

1. `*` (умножение):

   - Процессор выполняет операцию умножения через АЛУ (арифметико-логическое устройство)
   - Для чисел: используется бинарная операция умножения

2. `/` (деление):

   - Самая ресурсоемкая операция из базовых арифметических
   - Выполняется алгоритмом деления с плавающей точкой

3. `**` (возведение в степень):
   - Преобразуется в вызов Math.pow() на низком уровне
   - Вычисляется через логарифмы и экспоненты для нецелых степеней

---

### **3. Конкатенация строк**

```javascript
console.log(firstName + " " + lastName);
```

**Под капотом:**

1. Строки хранятся в UTF-16 (2 байта на символ)
2. Оператор `+` для строк:
   - Определяет тип операндов (строка + любое значение = конкатенация)
   - Создает новый буфер в памяти кучи
   - Копирует:
     - Символы из `firstName`
     - Символ пробела
     - Символы из `lastName`
   - Возвращает ссылку на новую строку

**Важно**: Каждая конкатенация создает новую строку в памяти! Это влияет на производительность при частых операциях.

---

### **4. Операторы присваивания**

```javascript
let x = 10 + 5; // 15
x += 10; // x = x + 10 → 25
x *= 4; // x = x * 4 → 100
x++; // x = x + 1 → 101
x--; // x = x - 1 → 100
```

**Как работает в памяти:**

1. Для `x++` и `x--`:
   - Создается временная копия текущего значения
   - Значение увеличивается/уменьшается
   - Возвращается временная копия (постфиксная форма)
2. **Ассемблерный аналог**:
   ```
   LOAD x -> регистр A
   ADD 1 -> регистр A
   STORE регистр A -> x
   ```

---

### **5. Операторы сравнения**

```javascript
const isFullAge = ageSarah >= 18;
```

**Под капотом:**

1. Оператор `>=`:
   - Процессор выполняет сравнение через команду CMP
   - Результат (true/false) сохраняется в флагах процессора
2. В JS:
   - Числа сравниваются как double-precision float
   - Результат - boolean значение (1 байт в памяти)

---

### **6. Приоритет операторов**

```javascript
const ageComp = now - 1991 > now - 2018;
```

**Порядок выполнения:**

1. `now - 1991` → 46
2. `now - 2018` → 19
3. `46 > 19` → true

**Таблица приоритетов:**
| Приоритет | Операторы | Ассоциативность |
|-----------|-------------------------------|-----------------|
| 1 | () (группировка) | → |
| 2 | \*_ (степень) | ← |
| 3 | _ / % | → |
| 4 | + - | → |
| 5 | < <= > >= | → |
| 6 | === !== == != | → |
| 7 | && | → |
| 8 | \|\| | → |
| 9 | = += -= (присваивание) | ← |

---

### **7. Проблема дробных чисел**

```javascript
console.log(0.1 + 0.2); // 0.30000000000000004
```

**Причина:**

- Числа в JS - IEEE 754 double-precision floats
- Некоторые дроби нельзя точно представить в двоичной системе
- Аналогично как 1/3 = 0.333... в десятичной системе

**Решение - работа в целых числах:**

```javascript
// Вместо долларов - центы
const totalCents = 1000 + 799; // 1799 центов
const dollars = totalCents / 100; // 17.99
```

**Почему это работает:**

1. Целые числа точно представляются в двоичной системе
2. Деление выполняется в конце, минимизируя накопление ошибок

---

### **8. Функция Math.round()**

```javascript
Math.round((1000 + 799) * 0.1) / 100; // 18
```

**Как работает под капотом:**

1. `Math.round()` использует алгоритм округления до ближайшего целого:
   - Если дробная часть >= 0.5 → округление вверх
   - Иначе → округление вниз
2. В процессоре: используется инструкция FROUND или аналоги

---

### **9. Задача: Расчет BMI**

```javascript
const massMark = 78;
const heightMark = 1.69;
const BMIMark = massMark / heightMark ** 2;

const massJohn = 92;
const heightJohn = 1.95;
const BMIJohn = massJohn / (heightJohn * heightJohn);

const markHeigherBMI = BMIMark > BMIJohn;
```

**Шаги выполнения:**

1. Для Mark:
   - `heightMark ** 2` → 1.69² = 2.8561
   - `massMark / 2.8561` → 78 / 2.8561 ≈ 27.309
2. Для John:
   - `heightJohn * heightJohn` → 1.95 \* 1.95 = 3.8025
   - `massJohn / 3.8025` → 92 / 3.8025 ≈ 24.194
3. Сравнение: 27.309 > 24.194 → true

**Оптимизации движка:**

1. Константные значения → оптимизируются при компиляции
2. Повторные вычисления (height\*height) → кешируются
3. Арифметика → преобразуется в машинные инструкции

---

### **Вопросы на собеседовании**

1. **Почему 0.1 + 0.2 !== 0.3?**  
   Из-за особенностей представления дробных чисел в IEEE 754. Некоторые дроби не могут быть точно представлены в двоичной системе.

2. **Как работает оператор `**`?\*\*  
   Это оператор возведения в степень. Имеет более высокий приоритет, чем умножение и деление. Преобразуется в вызов Math.pow().

3. **Чем отличается `x++` от `++x`?**

   - `x++` (постфиксный): возвращает значение до увеличения
   - `++x` (префиксный): увеличивает значение перед возвратом

4. **Как избежать проблем с дробными числами?**  
   Работать в целых числах (центах вместо долларов), использовать библиотеки для точных вычислений (decimal.js), округлять результаты.

5. **Что происходит при сравнении разных типов?**  
   JS использует приведение типов:

   - `5 == '5'` → true (нестрогое сравнение)
   - `5 === '5'` → false (строгое сравнение)

6. **Как устроен Math.round()?**  
   Округляет до ближайшего целого:
   - Если дробная часть ≥ 0.5 → в большую сторону
   - Иначе → в меньшую сторону

---

### **Визуализация выполнения кода**

```javascript
const now = 2037;
const ageDiff = now - 1991 > now - 2018;
```

1. Парсинг → AST дерево
2. Компиляция в байт-код
3. Выполнение:
   - now = 2037 (в стеке)
   - Вычисление 2037 - 1991 → 46
   - Вычисление 2037 - 2018 → 19
   - Сравнение 46 > 19 → true
   - Сохранение true в ageDiff

---

### **1. Конкатенация строк (классический способ)**

```javascript
const jonas =
  "I'm " + firstName + ", a " + (year - birthYear) + " years old " + job + "!";
```

**Что происходит под капотом:**

1. **Создание промежуточных строк**:

   - Каждая операция `+` создает новую строку в памяти
   - Процесс:
     - `"I'm " + firstName` → новая строка `"I'm Jonas"`
     - `"I'm Jonas" + ", a "` → новая строка `"I'm Jonas, a "`
     - `"I'm Jonas, a " + (year - birthYear)` → число преобразуется в строку, создается `"I'm Jonas, a 46"`
     - и т.д.

2. **Преобразование типов**:

   - При операции `строка + число`:
     - Число преобразуется в строку через `Number.prototype.toString()`
     - Для `year - birthYear` (46) → '46'

3. **Проблемы производительности**:
   - Каждая конкатенация создает новый объект строки в куче
   - Для длинных цепочек это создает много временных объектов
   - Сборщик мусора должен постоянно очищать память

---

### **2. Шаблонные литералы (ES6)**

```javascript
const jonasNew = `I'm ${firstName}, a ${year - birthYear} years old ${job}!`;
```

**Что происходит под капотом:**

1. **Парсинг шаблона**:

   - Движок разбивает шаблон на части:
     - `["I'm ", ", a ", " years old ", "!"]`
     - Выражения: `firstName`, `year - birthYear`, `job`

2. **Вычисление выражений**:

   - Каждое выражение внутри `${}` вычисляется:
     - `firstName` → 'Jonas'
     - `year - birthYear` → 46
     - `job` → 'teacher'

3. **Преобразование в строки**:

   - Нестроковые значения преобразуются:
     - `toString()` для объектов
     - `String()` для примитивов

4. **Сборка финальной строки**:
   - Движок эффективно объединяет части без создания промежуточных строк
   - Оптимизация: V8 использует "cons strings" (concatenated strings) для эффективного хранения

**Преимущества:**

- Лучшая производительность
- Читабельность кода
- Поддержка многострочности
- Возможность использовать тегированные шаблоны

---

### **3. Многострочные строки**

**Классический способ:**

```javascript
console.log(
  "String with \n\
multiple \n\
lines"
);
```

**Что происходит:**

1. Символ `\` в конце строки - экранирование перевода строки
2. `\n` - управляющий символ новой строки (ASCII 10)
3. В памяти создается единая строка: `"String with \nmultiple \nlines"`

**Проблемы:**

- Неудобно читать и редактировать
- Легко допустить ошибку с пробелами

**Шаблонные литералы:**

```javascript
console.log(`String with
multiple
lines`);
```

**Как это работает:**

1. Все пробелы и переводы строк сохраняются как есть
2. В памяти строка хранится с символами новой строки:
   ```plaintext
   String with\nmultiple\nlines
   ```
3. При выводе в консоль символы `\n` интерпретируются как новые строки

---

### **4. Внутреннее представление строк**

1. **Кодировка**:

   - Строки в JS используют UTF-16
   - Каждый символ - 2 байта (кроме суррогатных пар)

2. **Хранение в памяти**:

   - Короткие строки хранятся в стеке
   - Длинные строки хранятся в куче
   - Строки неизменяемы (immutable):
     ```javascript
     let a = "hello";
     a += " world"; // Создается НОВАЯ строка в памяти
     ```

3. **Интернирование строк**:
   - Движок создает пул уникальных строк
   - Повторное использование одинаковых строк:
     ```javascript
     const a = "hello";
     const b = "hello";
     // Обе переменные ссылаются на одну строку в памяти
     ```

---

### **5. Производительность: конкатенация vs шаблоны**

**Тест производительности:**

```javascript
// Конкатенация
let result = "";
for (let i = 0; i < 10000; i++) {
  result += "text" + i;
}

// Шаблонные литералы
let result = "";
for (let i = 0; i < 10000; i++) {
  result = `${result}text${i}`;
}
```

**Что лучше?**

- В современных движках (V8) шаблонные литералы оптимизированы лучше
- Для сложных сценариев:
  - Массив + `join()` - самый эффективный способ
  ```javascript
  const parts = [];
  for (let i = 0; i < 10000; i++) {
    parts.push(`text${i}`);
  }
  const result = parts.join("");
  ```

---

### **Вопросы на собеседовании**

1. **Чем отличаются шаблонные литералы от обычных строк?**

   - Поддерживают интерполяцию выражений через `${}`
   - Сохраняют переносы строк и пробелы
   - Могут использоваться с тегами для кастомной обработки

2. **Почему строки называют "неизменяемыми"?**

   - Любая операция модификации создает новую строку
   - Исходная строка остается в памяти до сборки мусора

3. **Как работает конкатенация строк под капотом?**

   - Каждая операция `+` создает новый объект строки
   - Для длинных цепочек это создает много временных объектов

4. **Что такое UTF-16 и почему он используется?**

   - Кодировка переменной длины (2 или 4 байта на символ)
   - Позволяет работать с большим набором символов (эмодзи, иероглифы)
   - Исторический выбор в JavaScript

5. **Как оптимизировать работу со строками?**
   - Использовать шаблонные литералы вместо конкатенации
   - Для больших текстов - массивы и `join()`
   - Избегать вложенных шаблонов в циклах

---

### **Пример в памяти**

**Исходный код:**

```javascript
const name = "Jonas";
const age = 46;
const str = `Hello ${name}, you are ${age}!`;
```

**В памяти:**

```
Стек:
  name: ссылка на адрес 0x100 (куча)
  age: 46 (примитив)
  str: ссылка на адрес 0x200 (куча)

Куча:
  0x100: "Jonas" (UTF-16: J=0x004A, o=0x006F, ...)
  0x200: "Hello Jonas, you are 46!"
```

**Оптимизация:** Современные движки могут не создавать промежуточные строки, а сразу формировать результат.

#### Часть 1: Условные операторы (if/else)

**Текст автора:**

> \*УСЛОВНЫЕ ОПЕРАТОРЫ (IF ELSE)

>

> Давайте создадим пример для человека, который хочет узнать, сколько лет ему осталось чтобы получить права.

> Пример:

> Возраст:

> let age = 19;

> Если возраст будет больше или равно 18 лет, результат будет true:

> const isOldEnough = age >= 18;\*

**Разбор:**

1. **`let age = 19;`**

- 📚 _Теория:_ Объявляем переменную `age` с помощью `let` и присваиваем ей значение `19`.

- ⚙️ _Под капотом:_

- Движок JS (например, V8) во время **компиляции** заметит объявление переменной. В фазе выполнения:

- В **стеке** (быстрая память для примитивов и ссылок) создается запись для `age`.

- Значение `19` (примитив типа number) сохраняется в стеке.

- 💡 _Область видимости:_ Переменная `age` имеет блочную область видимости (блок, в котором она объявлена).

2. **`const isOldEnough = age >= 18;`**

- 📚 _Теория:_ Создаем константу `isOldEnough`, которая получает результат сравнения `age >= 18`. Так как `19 >= 18` это `true`.

- ⚙️ _Под капотом:_

- Движок вычисляет выражение `age >= 18`:

- Достает значение `age` из памяти (стек).

- Сравнивает: 19 >= 18 → `true`.

- Результат (`true`) сохраняется в константе `isOldEnough` (также в стеке, так как это примитив).

- ❗️ _Важно:_ `const` создает неизменяемую привязку. Мы не сможем присвоить `isOldEnough` новое значение.

---

**Текст автора:**

> С помощью условного оператора (if), проверим может ли человек получить водительские права.

> Пример:

> if (isOldEnough) {

> console.log('Sarah can start driving license')

> } // result / Sarah can start driving license

**Разбор:**

1. **`if (isOldEnough) { ... }`**

- 📚 _Теория:_ Условный оператор `if` выполняет блок кода (в фигурных скобках), если условие в круглых скобках истинно (`true`).

- ⚙️ _Под капотом:_

- Движок проверяет значение `isOldEnough` (оно уже в памяти — `true`).

- Поскольку условие истинно, выполняется блок кода внутри `{}`.

- Вызов `console.log` добавляется в **стек вызовов (call stack)**.

- Стек вызовов: структура данных, которая отслеживает текущие выполняемые функции. Когда вызывается `console.log`, он помещается на вершину стека, выполняется (печатает строку), затем удаляется из стека.

---

**Текст автора:**

> Давайте попробуем изменить значения возраст на 15:

> age = 15;

> const isOldEnough = age >= 18;

> if (isOldEnough) {

> console.log('Sarah can start driving license')

> } // result / Ничего не будет в консоле, потому что внутри круглых скобок (), значения false.

**Разбор:**

1. **`age = 15;`**

- 📚 _Теория:_ Переприсваиваем переменной `age` значение `15`.

- ⚙️ _Под капотом:_ Обновляется значение `age` в стеке.

2. **`const isOldEnough = age >= 18;`**

- Теперь `15 >= 18` → `false`. Константа `isOldEnough` получает `false`.

3. **`if (isOldEnough) { ... }`**

- Условие ложно, поэтому блок кода внутри `if` пропускается. Ничего не выводится.

---

**Текст автора:**

> Теперь мы можем добавить ( else ), для чего нужен else ?

> else будет выполнен, если условия окажутся ложными внутри круглых скобок if ()

> Сейчас Sarah меньше 18 лет, и это приведет к ложному значению false.

> let age = 15;

> if (age >= 18) {

> console.log('Sarah can start driving license')

> } else {

> const yearsLeft = 18 - age;

> console.log(`Sarah is too young. Wait another ${yearsLeft} years.`);

> } // result / Sarah is too young. Wait another 3 years.

**Разбор:**

1. **`let age = 15;`** — объявляем `age` как 15 (если это новый блок, то это новая переменная; если нет, то переприсваивание).

2. **`if (age >= 18) { ... } else { ... }`**

- Условие `15 >= 18` → `false`, поэтому выполняется блок `else`.

3. **`const yearsLeft = 18 - age;`**

- Вычисляется `18 - 15 = 3`. Создается константа `yearsLeft` (блочная область видимости, доступна только внутри блока `else`).

4. **`console.log(...);`**

- Строка с шаблонным литералом: `Sarah is too young. Wait another 3 years.` выводится в консоль.

---

**Текст автора:**

> У нас сработал код внутри фигурных скобок else, и посчитали сколько лет осталось Sarah, для получения водительских прав.

> Давайте создадим еще один пример:

> Мы хотим узнать родился ли человек в 20 веке.

> Пример:

> const birthYear = 1991;

> if (birthYear <= 2000) {

> let century = 20;

> } else {

> let century = 21;

> }

> Любая переменная которая была объявлено внутри кодового блока if {} else {}, не будет доступным за пределами этих фигурных скобок {} - это называется область видимости.

**Разбор:**

1. **`const birthYear = 1991;`** — константа `birthYear` (значение в стеке).

2. **`if (birthYear <= 2000) { ... } else { ... }`**

- `1991 <= 2000` → `true`, выполняется блок `if`.

- **`let century = 20;`** — объявляется переменная `century` внутри блока `if`. Она имеет **блочную область видимости** и существует только внутри этих `{}`.

3. После блока `if` переменная `century` недоступна. Попытка обратиться к ней вызовет `ReferenceError`.

---

**Текст автора:**

> По этому если мы хотим узнать значение переменной в консоле за пределами кодового блока, выйдет ошибка.

> Для этого мы создадим переменную вне области видимости, и переназначим его внутри кодового блока внутри фигурных скобок {}.

> Пример:

> const birthYear = 1991;

> let century; <<<

> if (birthYear <= 2000) {

> century = 20; <<<

> } else {

> century = 21; <<<

> }

> console.log(century); // result / 20 (человек родился в 20 веке)

**Разбор:**

1. **`let century;`**

- Объявляем `century` во внешней области видимости (например, глобальной или функции). Ей неявно присваивается `undefined`.

2. **`if (birthYear <= 2000) { century = 20; } else { century = 21; }`**

- Так как `birthYear` равно 1991, выполняется `century = 20;`.

- Обновляется значение `century` (теперь `20`).

3. **`console.log(century);`** — выводит `20`.

---

#### Часть 2: Задача (расчет BMI)

**Текст автора:**

> \*ЗАДАЧА

>

> const massMark = 95;

> const heightMark = 1.88;

> const massJohn = 85;

> const heightJohn = 1.76;

>

> const BMIMark = massMark / heightMark \*\* 2;

> const BMIJohn = massJohn / (heightJohn \* heightJohn);

> console.log(BMIMark, BMIJohn); // result / 26.87, 27.44

>

> if (BMIMark > BMIJohn) {

> console.log(`Mark's BMI (${BMIMark}) is higher than John's (${BMIJohn})!`);

> } else {

> console.log("John's BMI (${BMIJohn}) is higher than Mark's (${BMIMark})!");

> } // result / John's BMI (27.44) is higher than Mark's (26.87)! - ( BMIJohn (27.44) выше чем BMIMark (26.87) )\*

**Разбор:**

1. **Объявление переменных:**

- `massMark`, `heightMark`, `massJohn`, `heightJohn` — примитивы (числа) в стеке.

2. **Расчет BMI:**

- `const BMIMark = massMark / heightMark ** 2;`

- `**` — оператор возведения в степень. Вычисляется `heightMark ** 2` → `1.88 * 1.88` → `3.5344`.

- Затем `95 / 3.5344` → ≈ `26.87`.

- `const BMIJohn = massJohn / (heightJohn * heightJohn);`

- `heightJohn * heightJohn` → `1.76 * 1.76` → `3.0976`.

- `85 / 3.0976` → ≈ `27.44`.

3. **`console.log(BMIMark, BMIJohn);`**

- Вывод: `26.87, 27.44`.

4. **Условный оператор:**

- `if (BMIMark > BMIJohn)` → `26.87 > 27.44`? → `false`.

- Выполняется блок `else`:

- `console.log("John's BMI (${BMIJohn}) is higher than Mark's (${BMIMark})!");`

- Обратите внимание: в тексте ошибка — использованы двойные кавычки вместо обратных (шаблонные литералы требуют обратных кавычек `` ` ``). Правильно:

```javascript
console.log(`John's BMI (${BMIJohn}) is higher than Mark's (${BMIMark})!`);
```

- Результат: `John's BMI (27.44) is higher than Mark's (26.87)!`.

---

### Ключевые концепции для собеседования:

1. **Область видимости (Scope):**

- Блочная (`let`, `const` внутри `{}`), функциональная (`var`), глобальная.

- Пример: Почему переменная внутри `if` не доступна снаружи?

2. **Условные операторы:**

- Как работает `if`/`else`? Что такое "ложные" значения (falsy: `false`, `0`, `""`, `null`, `undefined`, `NaN`)?

- Чем отличается строгое сравнение (`===`) от нестрогого (`==`)?

3. **Типы данных и память:**

- Примитивы (хранятся в стеке): `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.

- Объекты (хранятся в куче, в стеке — ссылка): объекты, массивы, функции.

4. **Шаблонные литералы:**

- Используйте `` `Текст ${переменная}` `` для вставки значений.

5. **Ошибки:**

- `ReferenceError`: попытка доступа к необъявленной переменной или переменной вне области видимости.

- `TypeError`: попытка сделать что-то недопустимое с типом (например, вызвать не функцию).

---

#### 1. Преобразование типов (Type Conversion) — явное преобразование:

```javascript
const inputYear = "1991";

console.log(inputYear + 18); // "199118"
```

- **Почему так происходит?**

- Оператор `+` при наличии хотя бы одной строки выполняет конкатенацию (объединение строк).

- JavaScript видит строку `'1991'` и число `18`, поэтому число автоматически преобразуется в строку `'18'`, и затем две строки объединяются.

- **Явное преобразование строки в число:**

```javascript
const inputYear = Number("1991"); // преобразует строку в число

console.log(inputYear + 18); // 2009
```

- **Под капотом:**

- Функция `Number()` — это встроенный конструктор, который пытается преобразовать переданное значение в число.

- Если преобразование невозможно (как в случае `'Jonas'`), возвращается `NaN` (Not a Number).

- `NaN` — это специальное значение числового типа (о чем говорит `typeof NaN === 'number'`), обозначающее ошибку в операции преобразования.

- **Важно для собеседования:**

- `NaN` — это единственное значение в JavaScript, которое не равно самому себе (`NaN !== NaN`). Для проверки на `NaN` используйте `Number.isNaN(value)`.

#### 2. Преобразование в строку и булевые значения:

```javascript
console.log(String(23)); // "23" — число преобразуется в строку
```

- **Булевое преобразование:**

- `Boolean(value)` — преобразует значение в `true` или `false`.

- Ложные (falsy) значения: `false`, `0`, `''`, `null`, `undefined`, `NaN`. Все остальные — истинные (truthy).

#### 3. Приведение типов (Type Coercion) — неявное преобразование:

- **Примеры с операторами:**

- `+` (если есть строка, преобразует все в строки):

```javascript
console.log("I'm " + 23 + " years old"); // "I'm 23 years old"
```

- Здесь число `23` неявно преобразуется в строку.

- `-`, `*`, `/` (преобразуют в числа):

```javascript
console.log("23" - "10" - 3); // 10 (23 - 10 = 13; 13 - 3 = 10)

console.log("2" * "2"); // 4

console.log("10" / "2"); // 5
```

- **Под капотом:**

- JavaScript движок (например, V8) перед выполнением операции проверяет типы операндов.

- Если типы не совпадают, он использует внутренние процедуры (например, `ToNumber`, `ToString`), чтобы привести их к одному типу.

- Для `+` приоритет отдается строковому преобразованию. Для других арифметических операторов — числовому.

#### 4. Сложный пример:

```javascript
let n = "1" + 1; // "11" (строка)

n = n - 1; // 10 (число)

console.log(n); // 10
```

- **Шаги:**

1. `'1' + 1` → строка `'1'` и число `1`. Оператор `+` приводит число к строке → `'11'`.

2. `'11' - 1` → оператор `-` всегда преобразует операнды в числа. Строка `'11'` становится числом `11`, затем `11 - 1 = 10`.

### Глубокое погружение: как работает приведение типов в движке V8?

1. **Этап компиляции:**

- V8 компилирует JavaScript в байт-код (а затем в машинный код).

- Во время компиляции он анализирует типы операций и вставляет инструкции для преобразования типов, если это необходимо.

2. **Этап выполнения:**

- При встрече операции с разными типами, движок использует внутренние методы:

- `ToPrimitive(hint)`: преобразует объект к примитиву. "Hint" может быть `'string'` или `'number'`.

- `ToNumber`, `ToString`, `ToBoolean` — для примитивов.

- Пример для `'23' - 10`:

- Оба операнда проходят через `ToNumber` → `23 - 10 = 13`.

### Собеседование: ключевые вопросы

1. **Что такое явное и неявное преобразование типов?**

- Явное: программист сам вызывает функции преобразования (`Number()`, `String()`).

- Неявное: JavaScript автоматически преобразует типы при операциях.

2. **Какие значения в JS являются ложными (falsy)?**

- `false`, `0`, `''`, `null`, `undefined`, `NaN`.

3. **Что выведет `console.log([] + []`?**

- Пустые массивы преобразуются в пустые строки → `'' + '' = ''`.

4. **Как избежать неожиданного поведения при приведении типов?**

- Использовать строгое равенство (`===`), которое не выполняет приведение типов.

- Явно преобразовывать типы перед операциями.

### Ошибки новичков:

```javascript
// Сравнение с преобразованием:

console.log("5" == 5); // true (неявное преобразование)

console.log("5" === 5); // false (без преобразования)

// Неожиданное преобразование в булево значение:

if (0) {
  // 0 → false

  console.log("Это не выполнится");
}
```

### Закрепим:

```javascript
console.log(Boolean(0)); // false

console.log(Boolean("0")); // true (непустая строка)

console.log(0 == "0"); // true (строка преобразуется в число 0 → 0 == 0)

console.log(0 === "0"); // false
```

Отлично! Давайте глубоко разберем концепцию **истинных (truthy) и ложных (falsy) значений** в JavaScript, включая то, как это работает под капотом и как применять на практике. Этот материал критически важен для понимания логики работы условных операторов.

---

### 1. **Основная концепция: Truthy и Falsy**

```javascript
// 5 ложных (falsy) значений:
0, "", undefined, null, NaN;

// Все остальные значения - истинные (truthy)
```

**Что происходит под капотом:**

- Когда JavaScript ожидает логическое значение (в условиях, логических операторах), он автоматически преобразует значения в `true` или `false` через **приведение типов**.
- Движок JS (например, V8) использует внутреннюю функцию `ToBoolean()` для этого преобразования.

---

### 2. **Примеры преобразований**

```javascript
console.log(Boolean(0)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean("Jonas")); // true
console.log(Boolean({})); // true (даже пустой объект)
```

**Объяснение:**

- Пустой объект `{}` является truthy, потому что:
  - Объекты хранятся в **куче (heap)**
  - Любая ссылка на объект считается "существующей" (truthy)
  - Пустой объект ≠ `null` (который явно означает "отсутствие значения")

---

### 3. **Автоматическое приведение в условиях (if/else)**

```javascript
const money = 0;
if (money) {
  console.log("Не трать все!");
} else {
  console.log("Тебе нужно найти работу!"); // Выполнится этот блок
}
```

**Под капотом:**

1. Движок видит условие `if (money)`
2. Вызывает `ToBoolean(money)` → `ToBoolean(0)` → `false`
3. Переходит к блоку `else`

**Проблема:**

- `0` - валидное число, но интерпретируется как `false`
- Это приводит к логической ошибке в проверках

---

### 4. **Критическая ошибка с нулевыми значениями**

```javascript
let height = 0;
if (height) {
  console.log("УРА! Высота определена!");
} else {
  console.log("Высота не определена!"); // Ошибочное выполнение
}
```

**Почему это происходит:**

- `height = 0` → falsy значение → условие не выполняется
- Но в реальности `0` может быть корректным значением высоты!

---

### 5. **Решение: Как правильно проверять значения**

#### Вариант 1: Явная проверка на undefined/null

```javascript
if (height !== undefined && height !== null) {
  console.log("Высота определена!"); // Сработает для height = 0
}
```

#### Вариант 2: Проверка с учетом нуля

```javascript
if (height !== undefined && height !== null && height !== 0) {
  console.log("Положительная высота");
} else if (height === 0) {
  console.log("Высота равна нулю");
}
```

#### Вариант 3: Использование Number.isFinite()

```javascript
if (Number.isFinite(height)) {
  console.log("Корректная высота"); // Работает для любых чисел, включая 0
}
```

---

### 6. **Как работает приведение в логических операторах?**

JavaScript использует **ленивое вычисление** (short-circuit evaluation):

```javascript
// Оператор И (&&) - возвращает первое falsy значение или последнее truthy
console.log(0 && "Привет"); // 0 (falsy)
console.log(1 && "Привет"); // "Привет" (последнее truthy)

// Оператор ИЛИ (||) - возвращает первое truthy значение или последнее falsy
console.log(0 || "Привет"); // "Привет" (truthy)
console.log("" || null); // null (последнее falsy)
```

**Практическое применение:**

```javascript
// Установка значения по умолчанию
const input = "";
const value = input || "Значение по умолчанию"; // "Значение по умолчанию"

// Безопасный доступ к свойствам
const user = null;
const name = user && user.name; // null (не будет ошибки)
```

---

### 7. **Что происходит в памяти?**

1. **Стек (Stack):**

   - Хранит примитивы (числа, строки, булевы значения)
   - Для `let height = 0`: создается ячейка памяти со значением `0`

2. **Куча (Heap):**

   - Хранит объекты (включая строки больше определенного размера)
   - Для `console.log(Boolean({}))`: объект создается в куче

3. **Процесс приведения:**
   - Для условия `if(height)`:
     - Движок берет значение из стека
     - Применяет `ToBoolean()`
     - Решает, какой блок кода выполнять

---

### 8. **Ключевые вопросы на собеседовании**

1. **Какие значения в JS считаются falsy?**  
   → `0`, `''`, `undefined`, `null`, `NaN`

2. **Почему `{}` (пустой объект) - truthy?**  
   → Любой объект (даже пустой) - это экземпляр Object, что считается "существующим" значением.

3. **Как безопасно проверить, что переменная определена (включая 0)?**  
   → Использовать явную проверку:

   ```javascript
   if (typeof height !== 'undefined' && height !== null) {...}
   ```

4. **Что вернет `console.log(Boolean(' '))`?**  
   → `true` (пробел - не пустая строка).

5. **Как работает оператор `||` с falsy значениями?**  
   → Возвращает первое truthy значение или последний операнд, если все falsy.

---

### 9. **Как исправить пример с высотой?**

```javascript
let height = 0;

// Правильный подход:
if (typeof height === "number" && !isNaN(height)) {
  console.log(`Высота: ${height} единиц`);
} else {
  console.log("Высота не определена");
}
```

**Объяснение:**

- `typeof height === 'number'` - проверяет, что это число
- `!isNaN(height)` - исключает случай `NaN`
- Работает для любых чисел, включая 0 и отрицательные значения

---

### Важные выводы:

1. Всегда помните о **5 falsy значениях** при работе с условиями
2. Для числовых проверок **никогда не полагайтесь на неявное приведение** - явно проверяйте диапазоны
3. Используйте `Number.isFinite()` для проверки чисел, включая 0
4. Операторы `&&` и `||` используют **ленивое вычисление** и возвращают исходные значения

### **Операторы равенства:**

> \*"Для этого у нас есть разные операторы равенства. Пример:

> `const age = 18;`

> `if (age === 18) console.log('Ты только что стал совершеннолетним!');`"\*

**Что происходит под капотом:**

- **`const age = 18;`**

- Движок:

1. Выделяет память в **стеке** (для примитивов) под переменную `age`.

2. Записывает туда число `18`.

3. `age` теперь ссылается на эту ячейку памяти.

- **`age === 18`**

- **Строгое равенство (`===`)** проверяет:

1. **Типы данных** одинаковы? Если нет → сразу `false`.

2. **Значения** одинаковы? Если да → `true`.

- В этом примере: оба типа `number`, значения равны → `true`.

- **Стек вызовов (Call Stack):**

- Функция `console.log()` помещается в стек → выполняется → удаляется из стека.

---

### **Типы операторов равенства:**

> \*"1 - (===) Строгое равенство...

> 2 - (==) Не строгое равенство...

> 3 - (!==) Строгое неравенство...

> 4 - (!=) Не строгое неравенство..."\*

**Как работает приведение типов (coercion) в `==`:**

- Это ключевое отличие! Пример:

```javascript
"18" == 18; // true
```

- Движок JS:

1. Видит разные типы: `string` слева, `number` справа.

2. Приводит строку к числу: `Number('18') → 18`.

3. Сравнивает `18 == 18` → `true`.

**Правила приведения типов для `==` (собеседование!):**

- Если один операнд — `number`, другой — `string` → строка приводится к числу.

- Если есть `boolean` → он приводится к числу (`true → 1`, `false → 0`).

- `null` и `undefined` равны **только друг другу** при `==` (`null == undefined → true`).

- Объекты приводятся к примитивам (через `.valueOf()` или `.toString()`).

---

### **Примеры с `===` vs `==`:**

> \*"const age = '18';

> console.log(age === 18); // false (строка != число)

> console.log(age == 18); // true (приведение типов)"\*

**Под капотом для `age === 18`:**

1. Тип `age` — `string`, справа — `number` → типы разные → `false`.

**Для `age == 18`:**

1. Типы разные → движок приводит `'18'` к `number` → `18`.

2. Сравнивает `18 == 18` → `true`.

---

### **Пример с `prompt`:**

> \*"const favourite = prompt('Какое твое любимое число?');

> console.log(favourite); // string"\*

**Как работает `prompt`:**

- `prompt` всегда возвращает **строку** (даже если ввели число).

- Данные хранятся в **куче (Heap)**, если это объекты (но строка — примитив, хранится в стеке).

- `console.log()` выводит значение в консоль. Цвет (белый) не влияет на тип.

---

### **Логика с `if` и приведением типов:**

> _"if (favourite == 23) { ... } // Сработает для '23'"_

**Под капотом:**

1. `favourite` — строка (например, `'23'`).

2. `==` видит `string` и `number` → приводит строку к числу: `'23' → 23`.

3. `23 == 23` → `true` → выполняется блок `if`.

---

### **Явное преобразование типов с `Number()`:**

> \*"const favourite = Number(prompt(...));

> if (favourite === 23) { ... }"\*

**Что делает `Number(...)`:**

- Это **функция-конструктор**. Она явно преобразует значение в число.

- `Number('23') → 23` (успех).

- `Number('abc') → NaN` (ошибка, но тип — `number`!).

- Теперь `favourite` — число → `===` работает без приведения.

**Разница между `==` и `===` для собеседования:**

> **`==` (Loose Equality):**

> - Проверяет равенство с приведением типов.

> - Может давать неочевидные результаты: `0 == false` (true), `'' == 0` (true).

>

> **`===` (Strict Equality):**

> - Проверяет равенство **без** приведения типов.

> - Типы должны быть одинаковыми, иначе `false`.

> - Рекомендуется всегда использовать `===` (кроме случаев, где нужно явное приведение).

---

### **Условные операторы `else if` и `else`:**

> \*"if (favourite === 23) { ... }

> else if (favourite == 7) { ... }

> else { ... }"\*

**Как выполняется код:**

1. Движок проверяет условия **последовательно**:

- Сначала `if` → если `true` → выполняет блок и **выходит**.

- Если `false` → проверяет `else if` → если `true` → выполняет его блок.

- Если все условия `false` → выполняется `else`.

2. **Стек вызовов:**

- Каждый блок `if`/`else if`/`else` — это новая запись в стеке при вызове функций внутри.

---

### **Итог для собеседования:**

1. **Назови 4 оператора равенства:**

- `===`, `==`, `!==`, `!=`.

2. **Чем `==` отличается от `===`?**

- `==` выполняет приведение типов перед сравнением, `===` — нет.

3. **Что такое приведение типов?**

- Автоматическое преобразование одного типа данных к другому (например, строки в число).

4. **Какой оператор использовать?**

- Почти всегда `===` (избегает скрытых багов).

5. **Пример: `'5' == 5` vs `'5' === 5`?**

- `'5' == 5 → true` (приведение), `'5' === 5 → false` (разные типы).

---

**Проверь себя (задание):**

Что вернут эти выражения? Объясни почему:

1. `0 == false`

2. `'' === 0`

3. `null == undefined`

4. `'10' !== 10`

Отлично! Давай разберем каждый пример **максимально подробно**, с объяснением того, что происходит под капотом JavaScript. Погнали! 🚀

### 1. `null` и `undefined`

```javascript
console.log(null == undefined); // true
console.log(null === undefined); // false
```

**Под капотом:**

1. **Специальное правило ECMAScript:**  
   В спецификации JavaScript явно указано, что `null` и `undefined` равны **только друг другу** при нестрогом равенстве (`==`). Это исключение из общих правил приведения типов.

2. **Сравнение в движке:**
   - `null == undefined`:
     - Движок проверяет типы: `null` (тип "null") и `undefined` (тип "undefined")
     - Срабатывает специальное правило → `true`
   - `null === undefined`:
     - Сравнение без преобразований
     - Разные типы (`null` vs `undefined`) → `false`

**Для собеседования:**  
"`null` и `undefined` равны только при нестрогом сравнении (`==`) по специальному правилу языка. При строгом сравнении (`===`) они не равны, так как имеют разные типы."

---

### 2. `NaN` (Not-a-Number)

```javascript
console.log(NaN === NaN); // false
console.log(NaN == NaN); // false
```

**Под капотом:**

1. **Спецификация IEEE 754:**  
   `NaN` — единственное значение в JavaScript, которое **не равно самому себе** по дизайну. Это поведение унаследовано из стандарта чисел с плавающей запятой.

2. **Как движок обрабатывает NaN:**

   - Любая операция сравнения с `NaN` сразу возвращает `false`
   - Даже при нестрогом равенстве движок не пытается преобразовывать `NaN`, так как это специальное значение

3. **Проверка на NaN:**
   ```javascript
   isNaN(NaN); // true
   Number.isNaN(NaN); // true (более надежный способ)
   ```

**Для собеседования:**  
"`NaN` уникален тем, что он не равен самому себе ни при строгом, ни при нестрогом сравнении. Это поведение определено стандартом IEEE 754. Для проверки используйте `Number.isNaN()`."

---

### 3. Логические значения

```javascript
console.log(true == 1); // true
console.log(false == 0); // true
console.log(false === 0); // false
console.log(true == "1"); // true
```

**Под капотом:**

1. **Приведение типов для `boolean`:**

   - При нестрогом равенстве `boolean` всегда преобразуется в `number`:
     - `true` → `1`
     - `false` → `0`

2. **Пошаговый разбор:**
   - `true == 1`:  
     `true` → `1` → `1 == 1` → `true`
   - `false == 0`:  
     `false` → `0` → `0 == 0` → `true`
   - `false === 0`:  
     Без преобразований → разные типы (`boolean` vs `number`) → `false`
   - `true == '1'`:  
     `'1'` → `1` (строка в число) → `true` → `1` → `1 == 1` → `true`

**Для собеседования:**  
"При нестрогом равенстве логические значения преобразуются в числа: `true` становится `1`, `false` становится `0`. Поэтому `true == 1` и `false == 0` возвращают `true`."

---

### 4. Сравнение строк и чисел

```javascript
console.log("" == "0"); // false
console.log(0 == ""); // true
console.log(0 === ""); // false
```

**Под капотом:**

1. **Правила приведения для строк и чисел:**

   - Если один операнд `number`, другой `string` → строка преобразуется в число
   - Пустая строка `''` → `0`

2. **Пошаговый разбор:**
   - `'' == '0'`:  
     Оба операнда строки → сравниваются как строки → разные значения → `false`
   - `0 == ''`:  
     `''` → `0` → `0 == 0` → `true`
   - `0 === ''`:  
     Без преобразований → разные типы (`number` vs `string`) → `false`

**Для собеседования:**  
"Пустая строка `''` при преобразовании в число становится `0`. Поэтому `0 == ''` дает `true`, а `0 === ''` — `false`."

---

### 5. Загадочный пример: `[] == ![]`

```javascript
console.log([] == ![]); // true
```

**Под капотом (шаг за шагом):**

1. **Правая часть: `![]`**

   - `[]` — объект (truthy значение) → `true`
   - `!true` → `false`  
     → Правая часть теперь `false`

2. **Сравнение: `[] == false`**

   - По правилам: если есть `boolean` → преобразовать в число
   - `false` → `0`  
     → Теперь `[] == 0`

3. **Левая часть: `[]` → число**

   - Объекты преобразуются через `valueOf()` или `toString()`
   - `[].valueOf()` → `[]` (не примитив)
   - `[].toString()` → `""` (пустая строка)  
     → Левая часть теперь `""`

4. **Сравнение: `"" == 0`**
   - Строка vs число → строка в число
   - `""` → `0`  
     → `0 == 0` → `true`

**Полная цепочка преобразований:**  
`[] == ![]` →  
`[] == false` →  
`[] == 0` →  
`"" == 0` →  
`0 == 0` →  
`true`

**Для собеседования:**  
"Этот пример демонстрирует сложность приведения типов в JS. Массив преобразуется в пустую строку, затем в 0, а отрицание массива (`![]`) становится `false`, которое тоже преобразуется в 0. В итоге 0 == 0 → true."

---

### 📚 Ключевые концепции для собеседования

1. **Приведение типов (Type Coercion):**

   - Нестрогое равенство (`==`) следует сложным правилам преобразования
   - Основные преобразования:
     - `boolean` → `number` (`true:1`, `false:0`)
     - `string` → `number` (пустая строка → 0)
     - Объекты → строки (через `.toString()`)

2. **Строгое vs нестрогое равенство:**

   ```javascript
   // Всегда используйте === если не уверены:
   0 === ""; // false
   false === 0; // false
   null === undefined; // false
   ```

3. **Особые случаи:**
   - `NaN` не равен ничему (даже самому себе)
   - `null` и `undefined` равны только друг другу при `==`
   - Пустой массив `[]` → `""` → `0` при преобразовании

**Проверь себя:** Что вернут эти выражения?

```javascript
console.log("0" == false); // ???
console.log({} == !{}); // ???
console.log(null == false); // ???
```

Ответы:

1. `'0' == false` → `'0' == 0` → `0 == 0` → `true`
2. `{} == !{}` → `{} == false` → `{} == 0` → `"[object Object]" == 0` → `NaN == 0` → `false`
3. `null == false` → `null` не преобразуется в 0 → `false` (специальное правило)

Отлично, давай разберем пример `null == false` максимально подробно, с объяснением каждого шага работы движка JavaScript. Это отличный пример для понимания нюансов приведения типов!

### 🧠 Пошаговый разбор: `console.log(null == false);`

**Результат: `false`**

#### 🔄 Как движок JS обрабатывает это сравнение:

Поскольку используется **нестрогое равенство (`==`)**, движок применяет алгоритм приведения типов из спецификации ECMAScript:

1. **Проверка типов операндов:**

   - Левый операнд: `null` (тип `Null`)
   - Правый операнд: `false` (тип `Boolean`)

2. **Алгоритм приведения для `==` (согласно спецификации):**

   ```mermaid
   graph LR
   A[null == false] --> B{Есть boolean?}
   B -->|Да| C[Преобразуй boolean в number]
   C --> D[false → 0]
   D --> E[null == 0]
   E --> F{Сравнение null и number}
   F -->|Специальные правила| G[Всегда false]
   ```

3. **Ключевые правила:**

   - Если в сравнении участвует `boolean`, он **всегда преобразуется в число**:
     - `false` → `0`
     - `true` → `1`
   - После преобразования получаем: `null == 0`

4. **Сравнение `null` и числа:**
   - `null` **никогда не преобразуется в 0** при сравнении (в отличие от `false` или пустой строки)
   - По спецификации ECMAScript:
     - `null` равен **только** `undefined` при нестрогом сравнении
     - `null == 0` → всегда `false`

#### ⚙️ Что происходит в памяти:

1. **Стек вызовов (Call Stack):**
   ```javascript
   // Локальные переменные для операции сравнения
   temp1 = null; // Примитив, хранится в стеке
   temp2 = false; // Примитив, хранится в стеке
   ```
2. **Преобразование типов:**

   ```javascript
   // Движок создает временную переменную
   temp2_converted = Number(false); // 0
   ```

3. **Сравнение:**
   ```javascript
   // Псевдокод движка
   if (null === 0) {
     // Но это не строгое сравнение!
     // Для == применяются другие правила
   }
   ```

#### 💡 Почему не `true`? Разбор ошибок интуиции:

1. **Ложная аналогия:**  
   "Раз `false` → `0`, а `null` → `0` в арифметике"  
   → **Нет!** Приведение работает только для арифметических операций, не для сравнений:

   ```javascript
   console.log(null + 1); // 0 + 1 = 1 (арифметика)
   console.log(null == 0); // false (сравнение)
   ```

2. **Специальные правила для `null`:**
   ```javascript
   // null равен ТОЛЬКО undefined при ==
   console.log(null == undefined); // true
   console.log(null == 0); // false
   console.log(null == ""); // false
   console.log(null == false); // false
   ```

#### ✅ Как движок видит это сравнение:

| Шаг | Выражение       | Действие                            | Промежуточное значение  |
| --- | --------------- | ----------------------------------- | ----------------------- |
| 1   | `null == false` | Видит boolean → преобразует в число | `null == 0`             |
| 2   | `null == 0`     | Проверяет правила для null          | `false` (спец. правило) |

#### 🧪 Проверка смежных случаев:

```javascript
console.log(undefined == false); // false
console.log(undefined == 0); // false
console.log("" == false); // true ("" → 0, false → 0)
console.log(0 == false); // true
console.log(null == true); // false (true → 1, null != 1)
```

#### 💎 Для собеседования:

**Вопрос:** "Почему `null == false` возвращает `false`?"  
**Ответ:**  
"При нестрогом равенстве движок сначала преобразует boolean в число (`false` → `0`), получая выражение `null == 0`.  
По спецификации JavaScript, `null` равен только `undefined` при нестрогом сравнении.  
Для всех других значений (включая числа, строки, boolean) сравнение с `null` возвращает `false`."

**Важное дополнение:**  
"Это отличается от поведения `undefined`, который:

- Равен только `null` при `==`
- Не равен числам/строкам: `undefined == 0` → `false`"

#### 🔚 Итог:

- `null == false` → **`false`**
- Причина: Специальные правила сравнения для `null` в JS
- Главное правило: **`null` равен только `undefined` при `==`**

Попробуй предсказать:

```javascript
console.log(null == NaN); // ???
console.log(undefined == ""); // ???
```

Отлично! Давай разберём текст про логические операторы в JavaScript **максимально подробно**, с фокусом на то, как всё работает под капотом. Поехали! 🚀

---

### 🔍 **Глубокий разбор текста + Как это работает под капотом**

#### **1. Основы булевой логики:**

```text
"Булева логика - он использует значения true, false для решения логических задач."
```

- **Что под капотом?**
  - В компьютере все сводится к **бинарным значениям** (0 и 1).
  - `true` → `1` в бинарном представлении
  - `false` → `0` в бинарном представлении
  - Логические операторы работают на уровне **процессорных инструкций** (AND, OR, NOT).

#### **2. Логические операторы:**

```text
1 - && (И)
2 - || (или)
3 - !  (Не)
```

- **Как работают под капотом:**

  - **`&&` (И)**: Возвращает `true` ТОЛЬКО если оба операнда `true`

    ```javascript
    true && true   → 1 AND 1 = 1 (true)
    true && false  → 1 AND 0 = 0 (false)
    ```

    - Процессор выполняет операцию **битового AND**

  - **`||` (ИЛИ)**: Возвращает `true` если ХОТЯ БЫ один операнд `true`

    ```javascript
    true || false  → 1 OR 0 = 1 (true)
    false || false → 0 OR 0 = 0 (false)
    ```

    - Процессор выполняет операцию **битового OR**

  - **`!` (НЕ)**: Инвертирует значение
    ```javascript
    !true  → NOT 1 = 0 (false)
    !false → NOT 0 = 1 (true)
    ```
    - Процессор выполняет операцию **битового NOT**

---

### ⚙️ **Разбор примеров из текста:**

#### **Пример 1: `&&` (И)**

```javascript
const hasDriversLicense = true;
const hasGoodVision = true;
console.log(hasDriversLicense && hasGoodVision); // true
```

**Под капотом:**

1. Переменные хранятся в **стеке вызовов**:
   - `hasDriversLicense: true` (бинарное 1)
   - `hasGoodVision: true` (бинарное 1)
2. Движок JS (V8) компилирует операцию `&&` в машинную инструкцию `AND`
3. Процессор вычисляет: `1 AND 1 = 1`
4. Результат `true` возвращается в консоль

**Память:**

```
Call Stack:
  hasDriversLicense → true (1)
  hasGoodVision     → true (1)
```

---

#### **Пример 2: `||` (ИЛИ)**

```javascript
const hasDriversLicense = true;
const hasGoodVision = false;
console.log(hasDriversLicense || hasGoodVision); // true
```

**Под капотом:**

1. Значения в стеке:
   - `hasDriversLicense: true` (1)
   - `hasGoodVision: false` (0)
2. Операция компилируется в инструкцию `OR`
3. Процессор вычисляет: `1 OR 0 = 1`
4. Результат `true`

**Особенность JS (Short-circuit evaluation):**  
Если первый операнд `true`, второй даже не проверяется:

```javascript
true || любойКод(); // любойКод() не выполнится
```

---

#### **Пример 3: `!` (НЕ) с `&&`**

```javascript
const hasDriversLicense = true;
const hasGoodVision = false;
console.log(hasDriversLicense && !hasGoodVision); // true
```

**Пошагово под капотом:**

1. Вычисление `!hasGoodVision`:
   - `hasGoodVision = false` (0)
   - `!` → битовая инверсия: NOT 0 = 1 (true)
2. Теперь выражение: `true && true`
3. Результат: `1 AND 1 = 1 (true)`

**Память во время вычисления:**

```
Call Stack:
  temp1 = !hasGoodVision → true (после инверсии)
  temp2 = hasDriversLicense AND temp1 → true
```

---

### 🚗 **Разбор примера с Сарой:**

#### **Первая версия:**

```javascript
const hasDriversLicense = true;
const hasGoodVision = false;

if (hasDriversLicense && hasGoodVision) {
  console.log("Сара может водить машину!");
} else {
  console.log("Кто-то другой должен водить...");
}
```

**Под капотом:**

1. Проверка условия `if`:
   - Вычисление: `true && false`
   - Результат: `false` (0)
2. Условный оператор переходит в блок `else`
3. **Стек вызовов:**
   ```
   Condition: false
   Execute: else block
   ```

#### **Вторая версия (с `isTired`):**

```javascript
const hasDriversLicense = true;
const hasGoodVision = true;
const isTired = true;

if (hasDriversLicense && hasGoodVision && !isTired) {
  // ...
}
```

**Пошаговое вычисление:**

1. `!isTired` → `!true` → `false`
2. Выражение: `true && true && false`
3. Порядок вычислений:
   ```mermaid
   graph LR
   A[true && true] --> B[true]
   B[true] --> C[true && false]
   C --> D[false]
   ```
4. Результат: `false` → выполняется блок `else`

---

### 💡 **Ключевые концепции под капотом:**

#### **1. Стек вызовов (Call Stack):**

- **Что это:** Специальная структура данных для хранения:
  - Локальных переменных
  - Аргументов функций
  - Контекста выполнения
- **Как работает:**
  - При вызове функции/блока → новый фрейм добавляется на вершину стека
  - При завершении → фрейм удаляется
- **Пример для условия Сары:**
  ```
  Stack Frame (if condition):
    hasDriversLicense: true
    hasGoodVision: true
    isTired: true
    temp1: !isTired = false
    temp2: hasDriversLicense && hasGoodVision = true
    temp3: temp2 && temp1 = false
  ```

#### **2. Ленивые вычисления (Short-Circuit Evaluation):**

- **Оптимизация в JS:**
  - Для `&&`: Если первый операнд `false`, второй не вычисляется
  - Для `||`: Если первый операнд `true`, второй не вычисляется
- **Пример:**
  ```javascript
  false && console.log("Это никогда не выполнится");
  true || console.log("Это тоже не выполнится");
  ```

#### **3. Приведение типов в логических операциях:**

```javascript
const x = 5;
const y = "hello";
console.log(x && y); // "hello" (не boolean!)
```

- **Важно:** Логические операторы в JS возвращают **значение операнда**, а не boolean!
- Правила:
  - `&&`: Возвращает первый `falsy` или последний `truthy`
  - `||`: Возвращает первый `truthy` или последний `falsy`
  - `!`: Всегда возвращает boolean

---

### 🎯 **Как отвечать на собеседовании:**

**Вопрос 1:** "Как работают логические операторы в JS?"  
**Ответ:**  
"Логические операторы `&&`, `||`, `!` работают с булевыми значениями, но могут принимать любые типы.

- `&&` возвращает первый `falsy` операнд или последний `truthy`
- `||` возвращает первый `truthy` операнд или последний `falsy`
- `!` всегда возвращает boolean, инвертируя значение"

**Вопрос 2:** "Что такое short-circuit evaluation?"  
**Ответ:**  
"Это оптимизация, при которой второй операнд вычисляется только если это необходимо. Например, в `false && ...` правая часть игнорируется, так как результат уже известен."

**Вопрос 3:** "Что вернёт `console.log(0 || "hello" && null)`?"  
**Ответ:**  
"Разберём по шагам:

1. `"hello" && null` → `null` (последний операнд)
2. `0 || null` → `null` (первый truthy или последний falsy)  
   Результат: `null`"

---

### 💎 **Итог:**

1. **`&&` (И):** Требует истинности ВСЕХ условий
2. **`||` (ИЛИ):** Требует истинности ХОТЯ БЫ одного условия
3. **`!` (НЕ):** Инвертирует значение
4. **Память:** Переменные хранятся в **стеке**, вычисления происходят на уровне **процессорных инструкций**
5. **Оптимизация:** **Short-circuit evaluation** предотвращает лишние вычисления

**Проверь себя:** Что выведет этот код?

```javascript
console.log((true && "Hello") || false); // ?
console.log(!"" && !0); // ?
```

Ответы:

1. `"Hello"` (так как `true && "Hello"` → `"Hello"`, потом `"Hello" || false` → `"Hello"`)
2. `true` (так как `!""` → `true`, `!0` → `true`, `true && true` → `true`)

Отлично! Давайте разберём оператор `switch` в JavaScript максимально подробно, с объяснением того, как он работает под капотом. Это важная конструкция для управления потоком выполнения программы.

### 🧠 Глубокий разбор оператора `switch`

#### 1. Основная концепция:

```text
"Switch - Это альтернативный способ написания условных операторов (if, else) когда нам нужно сравнить одно значение с несколькими разными вариантами."
```

**Что под капотом:**

- `switch` использует **строгое сравнение** (`===`), как и оператор `===`
- Движок JS создает **скрытую переменную** для значения в скобках `switch(...)`
- Затем последовательно сравнивает эту переменную с каждым `case`

#### 2. Синтаксис и выполнение:

```javascript
const day = "monday";
switch (day) {
  case "monday":
    // код
    break;
  // другие case
}
```

**Шаги выполнения под капотом:**

1. Вычисляется выражение в скобках (`day`)
2. Результат сохраняется во временную переменную (назовем ее `_temp`)
3. Движок начинает последовательное сравнение `_temp` с каждым `case`
4. При совпадении (`_temp === case-значение`) выполнение переходит в этот блок
5. Код выполняется до ближайшего `break` или конца `switch`

#### 3. Ключевое слово `break`:

```text
"break; // (перерыв) без него код продолжает выполняться"
```

**Почему это важно:**

- Без `break` выполнение **"проваливается" (fall-through)** в следующий `case`
- Это особенность реализации в процессорных ассемблерах, унаследованная JS
- В стеке вызовов не создается новый контекст - выполнение продолжается линейно

**Пример проваливания:**

```javascript
case 'wednesday':
case 'thursday': // Без break после 'wednesday'
  console.log('Пишу код');
  break;
```

- Для 'wednesday' и 'thursday' выполняется одинаковый код
- Это полезная фича, но нужно использовать осторожно

#### 4. Блок `default`:

```text
"default: console.log('Если не сработает весь код выше, сработает этот код');"
```

**Особенности:**

- Выполняется, если ни один `case` не совпал
- Аналог `else` в цепочке if-else
- Может располагаться в любом месте, но традиционно ставится в конец

#### 5. Сравнение с if-else:

```javascript
// switch-версия
switch (day) {
  case "monday":
    /* код */ break;
}

// if-else версия
if (day === "monday") {
  /* код */
} else if (day === "tuesday") {
  /* код */
}
```

**Различия под капотом:**

1. **Оптимизация:**

   - `switch` часто оптимизируется в **таблицу переходов**
   - Особенно эффективно при >5 условий
   - `if-else` последовательно проверяет каждое условие

2. **Читаемость:**

   - `switch` чище при множестве сравнений одного значения
   - `if-else` гибче для сложных условий

3. **Производительность:**
   - Для маленьких наборов разница незаметна
   - Для больших наборов `switch` обычно быстрее

### ⚙️ Детальный разбор примера:

**Исходный код:**

```javascript
const day = "monday";
switch (day) {
  case "monday":
    console.log("План на структуру курса");
    console.log("Встреча по программированию");
    break;
  // ... другие case
}
```

**Что происходит в движке JS:**

1. В стеке создается переменная `day` со значением `'monday'`
2. Начинается выполнение `switch`:

   ```mermaid
   graph TD
   A[switch day] --> B["case 'monday'?"]
   B -->|Да| C[Выполнить код]
   C --> D[break]
   D --> E[Выход из switch]
   B -->|Нет| F[Следующий case]
   ```

3. При совпадении с `'monday'`:

   - В консоль выводится первое сообщение
   - Второе сообщение
   - `break` прерывает выполнение

4. **Без break:**
   - Выполнение пошло бы в `case 'tuesday'`
   - И так до ближайшего `break` или конца блока

### 💡 Продвинутые особенности:

#### 1. Выражения в case:

```javascript
const count = 2;
switch (true) {
  case count < 5:
    console.log("Мало");
    break;
  case count >= 5 && count < 10:
    console.log("Средне");
    break;
}
```

- Можно использовать выражения, но это менее читаемо

#### 2. Блочная область видимости:

```javascript
switch (day) {
  case "monday": {
    const message = "План!"; // Локальная переменная
    console.log(message);
    break;
  }
  case "tuesday":
  // message здесь недоступна!
}
```

- Фигурные скобки создают блочную область видимости

#### 3. Возврат значений:

```javascript
const task = switch (day) {
  // Так нельзя!
}
```

- `switch` не возвращает значение (в отличие от тернарного оператора)
- Для возврата значений нужно использовать внутри переменную

### 🎯 Как отвечать на собеседовании:

**Вопрос 1:** "Чем switch лучше if-else?"
**Ответ:**
"Switch предпочтительнее при сравнении одной переменной с множеством конкретных значений. Он лучше читается и часто оптимизируется в таблицу переходов, что дает преимущество в производительности при большом числе условий."

**Вопрос 2:** "Зачем нужен break в switch?"
**Ответ:**
"Break предотвращает 'проваливание' в следующий case. Без него выполнение продолжится со следующего case независимо от соответствия условию. Это особенность языка, унаследованная от низкоуровневых языков типа C."

**Вопрос 3:** "Можно ли использовать switch для нестроковых значений?"
**Ответ:**
"Да, switch использует строгое сравнение (===), поэтому работает с любыми типами: числами, булевыми значениями, даже объектами (хотя для объектов это обычно бессмысленно, так как сравниваются ссылки)."

### 💎 Итог:

1. `switch` - **альтернатива цепочке if-else** для множественных сравнений
2. Использует **строгое равенство** (`===`)
3. **`break`** обязателен (кроме случаев группировки case)
4. **`default`** обрабатывает все остальные случаи
5. Под капотом часто **оптимизируется** в таблицу переходов

**Проверь себя:** Что выведет этот код?

```javascript
const num = 10;
switch (num) {
  case 10:
    console.log("Десять");
  case 20:
    console.log("Двадцать");
    break;
  default:
    console.log("Другое");
}
```

Ответ:  
"Десять" и "Двадцать" (из-за отсутствия break после первого case)

**1. Утверждение о выражениях:**

> "Выражения - это фрагмент кода, которая возвращает значения."

✅ **Верно!**

- **Технически:** Выражение (expression) — это любой допустимый набор литералов, переменных, операторов и выражений, который вычисляется в **единственное значение**. Это значение может быть примитивом (число, строка, boolean, null, undefined, symbol) или объектом (включая массивы и функции).

- **Как работает под капотом:**

- Когда движок JavaScript (например, V8) встречает выражение, он:

1. **Парсит** его в Абстрактное Синтаксическое Дерево (AST).

2. **Компилирует** в байт-код или машинный код (благодаря JIT-компиляции).

3. **Выполняет** вычисления.

4. **Возвращает результат** в место вызова выражения.

**2. Примеры выражений:**

```javascript

3 + 4; // → 7 (число)

1991; // → 1991 (число)

'Привет Мир!'; // → "Привет Мир!" (строка)

console.log(...); // Хотя console.log выполняет действие, ВНУТРИ него есть выражение `age >= 18 ? 'Вино' : 'Вода'`, которое вычисляется в значение.

```

✅ **Верно для всех примеров.** Даже отдельный литерал (число, строка) — это выражение. При вычислении он возвращает себя.

**3. Тернарный оператор как выражение:**

> "тернарные оперторы являются выражениями"

✅ **Абсолютно верно!**

- Ключевое отличие тернарного оператора (`condition ? expr1 : expr2`) от `if/else` в том, что тернарный оператор **возвращает значение** (результат выполнения `expr1` или `expr2`), а `if/else` — нет.

- **Под капотом:**

- Движок вычисляет условие (`age >= 18`).

- В зависимости от результата, вычисляет ЛИБО `'Вино'`, ЛИБО `'Вода'`.

- Возвращает вычисленное значение в место вызова тернарного оператора.

**4. Утверждение об операторах (statements):**

> "Оператор - это более крупный фрагмент кода, который выполняется и не возвращает значения."

✅ **Верно!**

- **Технически:** Оператор (statement) — это инструкция, которая выполняет действие. Операторы не производят значений (в отличие от выражений). Они управляют потоком выполнения, объявляют переменные, управляют циклами и т.д.

- **Примеры операторов:**

- `if`, `else`, `for`, `while`, `switch`

- Объявление переменных: `let x = 10;`, `const y = 20;`

- Блоки кода: `{ ... }`

- **Под капотом:**

- Операторы не оставляют значения в стеке вызовов для использования в выражениях. Они выполняют "побочные эффекты" (изменение переменных, вывод в консоль и т.д.).

**5. Конкретные примеры операторов:**

```javascript
// Пример 1: if-else (условный оператор)

if (23 > 10) {
  const str = "Круто! 23 больше!";
}

// Пример 2: Объявление переменной

let age = 2024 - 1995; // Вся строка — оператор (хотя `2024 - 1995` внутри — выражение).

// Пример 3: Присваивание с тернарным оператором

const drink = age >= 18 ? "Вино" : "Вода"; // Вся строка — оператор (statement).
```

**Пояснение к примеру 3:**

- `const drink = ...` — это оператор объявления переменной.

- `age >= 18 ? 'Вино' : 'Вода'` — внутри оператора находится **выражение** (тернарный оператор), которое вычисляется в строку.

- Весь оператор (`const drink = ...`) не "возвращает" значение в контексте выполнения (в отличие от выражения). Он создает переменную `drink` и присваивает ей значение.

**6. Шаблонные строки (Template literals) и выражения:**

> "В шаблоне можно использовать только выражения но не оператор."

✅ **Верно!**

- Синтаксис шаблонных строк: `` `Текст ${выражение} текст` ``

- Внутри `${ }` можно ТОЛЬКО выражения. Нельзя операторы (`if`, `for`, объявление переменных).

**Примеры:**

```javascript

// Правильно (выражения внутри ${}):

`Мне ${2024 - 1995} лет!` // → "Мне 29 лет!"

`Я люблю выпить ${age >= 18 ? 'Вино' : 'Вода'}` // → "Я люблю выпить Вино" (если age >= 18)

// НЕПРАВИЛЬНО (операторы внутри ${}):

`${if (age >= 18) { 'Вино' } else { 'Вода' }}` // Синтаксическая ошибка!

```

---

**Ключевые выводы для собеседования:**

1. **Выражение vs Оператор:**

- Выражение **производит значение**. Примеры: `1 + 2`, `myFunction()`, `x > y ? 'a' : 'b'`, `'строка'`.

- Оператор **выполняет действие** и не производит значения (но может содержать внутри выражения). Примеры: `if`, `for`, `let x = 5;`, `return 10;`.

2. **Тернарный оператор (`? :`):**

- Это **выражение**, поэтому возвращает значение.

- Может использоваться везде, где ожидается выражение (в шаблонных строках, аргументах функций, присваиваниях).

- `if/else` — оператор, не возвращает значения.

3. **Шаблонные строки:**

- Внутри `${ }` принимаются только выражения.

- Тернарный оператор — выражение, поэтому разрешен.

- `if/else` — оператор, запрещен.

**Глубинные вопросы (на которые ты теперь можешь ответить):**

- **Почему `console.log(1 + 1);` работает?**

- `1 + 1` — выражение, вычисляется в `2`.

- `console.log(...)` — вызов функции, который сам по себе является выражением (он возвращает `undefined`, но это все равно значение!).

- Вся строка `console.log(2);` — это оператор (expression statement), потому что выражение `console.log(2)` используется как самостоятельная инструкция.

- **Чем `let x = 10;` отличается от `10 + 20;`?**

- `let x = 10;` — оператор объявления. Он создает переменную `x`. Не производит значения.

- `10 + 20;` — выражение (вычисляется в 30), использованное как оператор (expression statement). Значение `30` вычисляется, но нигде не сохраняется (если не присвоить переменной).
