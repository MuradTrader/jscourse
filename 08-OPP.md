# ЧТО ТАКОЕ ООП ?

## 1. Что такое ООП?

Объектно-ориентированное программирование (ООП) — это стиль написания и организации кода,
в котором программа строится вокруг объектов.

Объект — это сущность, которая может содержать данные (называются свойствами)
и функциональность (называется методами).

**Пример:**

```javascript
// Создание объекта с помощью литерала
const user = {
  username: "john_doe",
  email: "john@example.com",
  // метод объекта
  login() {
    console.log(`${this.username} вошёл в систему.`);
  },
};

// Использование объекта
console.log(user.email); // john@example.com
user.login(); // john_doe вошёл в систему.
```

**Логика:**
Мы описали пользователя (user) как объект с его свойствами
(например, username, email) и поведением (метод login).
Теперь все данные и функциональность этого объекта находятся внутри него.

## 2. Преимущества ООП

Почему это полезно?

Упрощённая организация кода: все данные и функции связаны и собраны в одном месте (внутри объекта).
Повторное использование: можно создавать "шаблоны" объектов
(например, с помощью классов), чтобы избегать повторения.
Лёгкость изменений: изменения внутри объекта не затрагивают другие части программы.

## 3. Основные принципы ООП:

### 3.1. Абстракция

Абстракция позволяет скрывать ненужные детали и показывать только то, что важно.
Например, представим объект телефона.
Для пользователя важны лишь экран и кнопки, а внутренние механизмы скрыты.

**Пример:**

```javascript
// Телефон с абстракцией
class Phone {
  constructor(model) {
    this.model = model;
  }

  // Публичный метод (важен для пользователя)
  call(number) {
    console.log(`Звонок на номер ${number} с телефона ${this.model}.`);
  }

  // Приватный метод (внутренняя логика, недоступна пользователю)
  #checkBattery() {
    console.log("Проверка батареи...");
  }
}

// Использование:
const myPhone = new Phone("iPhone 14");
myPhone.call("123-456-789"); // Звонок на номер 123-456-789 с телефона iPhone 14.
// myPhone.#checkBattery(); // Ошибка! Недоступно извне.
```

**Логика:**
Мы показали пользователю только нужный метод call.
Внутренний метод #checkBattery скрыт, так как он неважен для конечного пользователя.

### 3.2. Инкапсуляция

Инкапсуляция — это сокрытие внутренних данных объекта
и предоставление доступа к ним только через определённые методы (API).

**Пример:**

```javascript
class User {
  #password; // Приватное свойство

  constructor(username, password) {
    this.username = username;
    this.#password = password;
  }

  // Публичный метод для проверки пароля
  checkPassword(inputPassword) {
    return inputPassword === this.#password;
  }
}

// Использование:
const user = new User("john_doe", "1234");
console.log(user.username); // john_doe
console.log(user.checkPassword("1234")); // true
// console.log(user.#password); // Ошибка! Прямой доступ запрещён.
```

**Логика:**
Приватное свойство #password защищено от прямого доступа.
Для взаимодействия с паролем используется метод checkPassword.

### 3.3. Наследование

Наследование позволяет одному классу (называется дочерним)
унаследовать свойства и методы другого класса (называется родительским).
Это помогает избежать дублирования кода.

**Пример:**

```javascript
// Родительский класс
class User {
  constructor(username) {
    this.username = username;
  }

  login() {
    console.log(`${this.username} вошёл в систему.`);
  }
}

// Дочерний класс
class Admin extends User {
  deleteUser(user) {
    console.log(`${this.username} удалил пользователя ${user.username}.`);
  }
}

// Использование:
const admin = new Admin("admin_user");
const regularUser = new User("regular_user");

admin.login(); // admin_user вошёл в систему.
admin.deleteUser(regularUser); // admin_user удалил пользователя regular_user.
```

**Логика:**
Класс Admin наследует метод login из класса User, но добавляет новый метод deleteUser.

Давай разберём логику работы кода пошагово, чтобы полностью понять, как и почему он функционирует.

1. Родительский класс User

```javascript
class User {
  constructor(username) {
    this.username = username;
  }

  login() {
    console.log(`${this.username} вошёл в систему.`);
  }
}
```

Что происходит:
Мы создаём базовый класс User.
У этого класса есть:
Свойство: username (инициализируется через конструктор).
Метод: login(), который выводит сообщение о входе пользователя в систему.

Логика работы:
Конструктор (constructor) вызывается автоматически, когда создаётся объект из класса User.
Он принимает параметр username и сохраняет его в свойство объекта.

Метод login() использует свойство username для вывода сообщения.

2. Дочерний класс Admin

```javascript
class Admin extends User {
  deleteUser(user) {
    console.log(`${this.username} удалил пользователя ${user.username}.`);
  }
}
```

Что происходит:
Класс Admin наследует (extends) все свойства и методы класса User.

Это означает, что:
Admin автоматически получает доступ к constructor и методу login из класса User.
Все функции и свойства User можно использовать в объектах класса Admin.
Внутри Admin добавляется новый метод deleteUser(user).

Этот метод:
Берёт имя текущего администратора (this.username).
Берёт имя другого пользователя (user.username), который передаётся как параметр.
Выводит сообщение об удалении пользователя.

3. Создание объектов

```javascript
const admin = new Admin("admin_user");
const regularUser = new User("regular_user");
```

```javascript
const admin = new Admin("admin_user");
```

Создаётся объект admin, принадлежащий классу Admin.
Вызывается конструктор класса User, от которого наследуется Admin.
Свойство username устанавливается в значение 'admin_user'.

```javascript
const regularUser = new User("regular_user");
```

Создаётся объект regularUser, принадлежащий классу User.
Конструктор класса User устанавливает свойство username в значение 'regular_user'.

4. Использование методов

Вызов метода login:

```javascript
admin.login(); // admin_user вошёл в систему.
```

Метод login был унаследован от класса User.
Внутри метода используется this.username:
Для объекта admin, this.username равно 'admin_user'.
Вывод: admin_user вошёл в систему.

Вызов метода deleteUser:

```javascript
admin.deleteUser(regularUser); // admin_user удалил пользователя regular_user.
```

Метод deleteUser вызывается для объекта admin.

Внутри метода:
this.username ссылается на username объекта admin, то есть 'admin_user'.
user.username берётся из переданного объекта regularUser, где username = 'regular_user'.
Вывод: admin_user удалил пользователя regular_user.

5. Ключевые моменты логики наследования
   Класс Admin наследует все свойства и методы User.

Admin автоматически получает метод login, но может добавить новые методы (например, deleteUser).
Admin и User — это разные классы, но Admin использует функциональность User.

Мы избегаем повторения кода:
метод login не нужно переопределять в классе Admin, он уже доступен через наследование.

Ключевая роль this:
В методах this всегда ссылается на объект, который вызывает метод.
В admin.login(), this.username берёт значение из объекта admin.
В admin.deleteUser(regularUser), user.username берёт значение из переданного объекта regularUser.

6. Итоговый результат
   Код демонстрирует:
   Использование наследования для повторного использования кода (login из User доступен в Admin).
   Добавление новых возможностей в дочерний класс (deleteUser в Admin).

Работа с разными экземплярами классов:
admin работает с пользователем regularUser.

Я спросил у GPT:
То есть как я понял внутри объекта User в функции:

constructor(username) {
this.username = username;
}

Создается новое свойство username.
Точно также внутри объекта Admin тоже создается новое свойство username унаследовав это у родителя User,
хотя в самом коде внутри объекта Admin мы не видим это визуально.
Правильно я понял ?

GPT Сказал:
Да, вы всё правильно поняли! Давайте разберём это чуть более подробно, чтобы закрепить понимание.

1. Как создаётся свойство username в User

В классе User есть конструктор:

constructor(username) {
this.username = username;
}

Когда создаётся объект из класса User,
например:
const regularUser = new User('regular_user');

Происходит следующее:
Конструктор класса User автоматически вызывается.
Внутри конструктора создаётся свойство объекта username,
которое записывается в this (то есть в текущий объект).

Теперь объект regularUser выглядит так:

{
username: 'regular_user'
}

2. Как это работает в Admin
   Класс Admin наследует User, то есть получает доступ ко всем его свойствам и методам.

Это значит:
Когда мы создаём объект из класса Admin:
const admin = new Admin('admin_user');
Автоматически вызывается конструктор User, унаследованный классом Admin.

Таким образом:
В момент создания объекта Admin,
например:
const admin = new Admin('admin_user');
Конструктор User всё равно вызывается автоматически.

В объекте admin создаётся свойство username со значением 'admin_user'.

Теперь объект admin выглядит так:

{
username: 'admin_user'
}

3. Почему мы не видим свойства username в коде Admin
   Мы не видим явного создания username в классе Admin,

потому что:
Наследование автоматически передаёт функциональность конструктора User в Admin.
Таким образом, класс Admin не должен явно переопределять создание username,
если он работает так же, как в User.

4. Итог
   Да, внутри объекта Admin создаётся свойство username, даже если это не видно напрямую в коде.
   Это свойство создаётся благодаря механизму наследования: когда Admin вызывает конструктор User.
   Такой подход позволяет избежать дублирования кода и упрощает архитектуру программы.

Пример для проверки:
Если мы выведем объект admin, мы увидим свойство username:
const admin = new Admin('admin_user');
console.log(admin.username); // admin_user
Это подтверждает, что свойство username создано внутри объекта admin, унаследованного от User.

### 3.4. Полиморфизм

Полиморфизм позволяет переопределять методы родительского класса
в дочерних классах для изменения их поведения.

**Пример:**

```javascript
class User {
  login() {
    console.log("Вход для обычного пользователя.");
  }
}

class Admin extends User {
  login() {
    console.log("Вход для администратора с повышенной безопасностью.");
  }
}

class Author extends User {
  login() {
    console.log("Вход для автора.");
  }
}

// Использование:
const user = new User();
const admin = new Admin();
const author = new Author();

user.login(); // Вход для обычного пользователя.
admin.login(); // Вход для администратора с повышенной безопасностью.
author.login(); // Вход для автора.
```

**Логика:**
Хотя метод login определён в родительском классе,
дочерние классы (Admin, Author) переопределили его для своей специфики.

## 4. Как создавать объекты в ООП?

Для создания объектов используется концепция классов.
Класс — это шаблон, из которого создаются объекты.

**Пример:**

```javascript
class User {
  constructor(username, email) {
    this.username = username;
    this.email = email;
  }

  login() {
    console.log(`${this.username} вошёл в систему.`);
  }
}

// Создание объекта (экземпляра класса):
const user1 = new User("john_doe", "john@example.com");
const user2 = new User("jane_doe", "jane@example.com");

user1.login(); // john_doe вошёл в систему.
user2.login(); // jane_doe вошёл в систему.
```

**Логика:**
Класс описывает, какие свойства (username, email) и методы (login) будут у объектов.
Каждое созданное из класса значение (например, user1, user2) называется экземпляром класса.

**Итог:**
Объектно-ориентированное программирование помогает:
Организовать код так, чтобы он был понятным и структурированным.
Повторно использовать готовые классы и объекты.
Избежать ошибок благодаря сокрытию внутренних данных (инкапсуляция).
Легко расширять код с помощью наследования и полиморфизма.

// --------------------------------------------------------------------------------- //

## \*ООП В JAVASCRIPT

### 1. Классическая модель ООП: классы и экземпляры

Класс — это как чертёж или план дома.
Он определяет структуру и поведение объекта, который будет создан из этого класса.

Экземпляр — это реальный объект, созданный на основе класса.

Например:
Класс — это план создания дома.
Экземпляр — это конкретный построенный дом.

**Пример:**

```javascript
class House {
  constructor(address) {
    this.address = address; // Свойство адрес
  }

  describe() {
    console.log(`Дом находится по адресу: ${this.address}`);
  }
}

// Создаём экземпляры:
const myHouse = new House("ул. Пушкина, д. 1");
const yourHouse = new House("ул. Лермонтова, д. 2");

// Используем методы:
myHouse.describe(); // Дом находится по адресу: ул. Пушкина, д. 1
yourHouse.describe(); // Дом находится по адресу: ул. Лермонтова, д. 2
```

Важный процесс:
инстанцирование — это создание экземпляра на основе класса.
Например, const myHouse = new House('ул. Пушкина, д. 1'); — это инстанцирование.

### 2. Прототипы в JavaScript

В JavaScript классы долгое время отсутствовали, и вместо них использовался механизм прототипов.
Прототип — это объект, к которому связан другой объект.
Прототип содержит общие методы и свойства,
которые могут использоваться связанными объектами.

**Пример (упрощённо):**

```javascript
const animal = {
  eat() {
    console.log("Ест...");
  },
};

const dog = Object.create(animal); // dog связан с прототипом animal
dog.bark = function () {
  console.log("Гав!");
};

dog.eat(); // Ест... (унаследовано от animal)
dog.bark(); // Гав! (собственный метод)
```

Здесь объект dog "наследует" метод eat из animal через прототип.

### 3. Прототипное наследование (Prototypal Inheritance)

Каждый объект в JavaScript связан с прототипом.
Этот прототип может содержать свойства и методы,
которые доступны всем объектам, связанным с ним.

**Пример: массивы**

```javascript
const numbers = [1, 2, 3];

// Массив numbers связан с прототипом Array.prototype
console.log(numbers.map); // function map() { ... }

// Метод map() на самом деле определён в Array.prototype
const doubled = numbers.map((num) => num * 2);
console.log(doubled); // [2, 4, 6]
```

Здесь метод map() не находится в самом массиве numbers.
Вместо этого он определён в Array.prototype.
Благодаря прототипному наследованию, numbers имеет доступ к map().

### 4. Как это отличается от классического ООП

В классическом ООП (например, в Java или C++):

Методы "копируются" из класса в экземпляры.
У каждого экземпляра есть свои методы и свойства.

В JavaScript:
Методы не копируются.
Вместо этого объекты делегируют (перенаправляют) вызовы методов своему прототипу.

Важное отличие:
В Java: каждый объект содержит копию методов.
В JavaScript: методы общие и находятся в прототипе.

### 5. Способы реализации ООП в JavaScript

Автор упоминает три способа реализации ООП в JavaScript:

#### 5.1. Функции-конструкторы (Constructor Functions)

Это старый, но мощный способ создания объектов и задания прототипов.

**Пример:**

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function () {
  console.log(`Привет, меня зовут ${this.name}`);
};

// Создаём экземпляр:
const alice = new Person("Алиса");
alice.sayHello(); // Привет, меня зовут Алиса
```

Здесь sayHello находится в Person.prototype, и все объекты,
созданные с помощью new Person, получают к нему доступ.

#### 5.2. Классы ES6 (ES6 Classes)

Современный способ, который более понятен новичкам,
но под капотом использует функции-конструкторы:

**Пример:**

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Привет, меня зовут ${this.name}`);
  }
}

const bob = new Person("Боб");
bob.sayHello(); // Привет, меня зовут Боб
```

Этот синтаксис проще, но в основе всё равно лежат функции-конструкторы и прототипы.

#### 5.3. Object.create()

Этот метод позволяет напрямую указать, к какому прототипу должен быть связан объект:

**Пример:**

```javascript
const animal = {
  eat() {
    console.log("Ест...");
  },
};

const cat = Object.create(animal); // cat связан с animal
cat.meow = function () {
  console.log("Мяу!");
};

cat.eat(); // Ест... (унаследовано от animal)
cat.meow(); // Мяу! (собственный метод)
```

Этот подход простой и удобный, но используется реже.

### 6. Принципы ООП

Важные принципы ООП работают и в JavaScript:

**Абстракция** — сокрытие деталей реализации.

```javascript
class BankAccount {
  constructor(balance) {
    this._balance = balance; // Приватное свойство
  }

  getBalance() {
    return this._balance;
  }
}

const account = new BankAccount(100);
console.log(account.getBalance()); // 100
```

**Инкапсуляция** — объединение данных и методов для работы с ними.

```javascript
class Car {
  constructor(model) {
    this.model = model;
  }

  startEngine() {
    console.log(`Двигатель ${this.model} запущен.`);
  }
}
```

**Наследование** — возможность одного объекта наследовать свойства и методы другого.

```javascript
class ElectricCar extends Car {
  chargeBattery() {
    console.log("Батарея заряжена.");
  }
}

const tesla = new ElectricCar("Tesla Model S");
tesla.startEngine(); // Двигатель Tesla Model S запущен.
tesla.chargeBattery(); // Батарея заряжена.
```

**Полиморфизм** — возможность объектов вести себя по-разному в зависимости от контекста.

```javascript
class Animal {
  speak() {
    console.log("Животное издаёт звук.");
  }
}

class Dog extends Animal {
  speak() {
    console.log("Собака говорит: Гав!");
  }
}

const animals = [new Animal(), new Dog()];
animals.forEach((animal) => animal.speak());
// Животное издаёт звук.
// Собака говорит: Гав!
```

**Итог**
В JavaScript используется механизм прототипов для реализации ООП.
Есть три основных подхода: функции-конструкторы, классы ES6 и Object.create().
Прототипное наследование — это основа ООП в JavaScript.
Принципы ООП (абстракция, инкапсуляция, наследование, полиморфизм) работают и в JavaScript.
Практика и эксперименты с кодом помогут вам лучше усвоить эти концепции.

// --------------------------------------------------------------------------------- //

## \*ФУНКЦИИ КОНСТРУКТОРА И НОВЫЙ ОПЕРАТОР

Подробное объяснение с примерами: Конструкторы в JavaScript
Давайте разберем, как работают функции-конструкторы в JavaScript,
на основе рассказанного в видео, добавив примеры и пояснения,
чтобы начинающим программистам было проще понять.

Что такое функции-конструкторы?
Функция-конструктор — это обычная функция, используемая для создания объектов.
Главное отличие от обычной функции:
конструктор вызывается с использованием ключевого слова new.

Как работает конструктор?
Когда вы вызываете функцию с new,
происходит четыре важных шага:

Создается новый пустой объект.
Это объект, в который позже добавятся свойства и методы.

const obj = {};

Функция вызывается, а this внутри нее указывает на этот новый объект.
То есть внутри функции-конструктора this будет ссылаться на только что созданный объект.

function Person(name) {
console.log(this); // Новый объект
}

Новый объект автоматически связывается с прототипом функции-конструктора.
Это основа прототипного наследования, которое мы обсудим позже.

Этот объект возвращается из функции, если явно не указано иное.

**Пример функции-конструктора:**
Рассмотрим создание конструктора для объекта "человек":

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
}
```

Используем функцию для создания объектов:

```javascript
const jonas = new Person("Jonas", 1991);
console.log(jonas); // { firstName: 'Jonas', birthYear: 1991 }
```

Теперь объект jonas содержит свойства firstName и birthYear.

Аналогично мы можем создать другие объекты:

```javascript
const matilda = new Person("Matilda", 2017);
console.log(matilda); // { firstName: 'Matilda', birthYear: 2017 }
```

**Шаги вызова конструктора с new:**
При вызове new Person('Jonas', 1991) происходят следующие действия:

1 - Создается пустой объект:
{}.

2 - this внутри функции указывает на этот объект:

Например:

```javascript
function Person(name) {
  console.log(this); // {}
}
```

3 - Привязывается прототип:
Новый объект связывается с прототипом конструктора.
Это важно для наследования методов, что мы рассмотрим далее.

4 - Объект возвращается автоматически:
Если явно не указано иное, JavaScript сам вернет новый объект.

**Добавление методов:**
**Пример плохой практики**
Метод можно добавить прямо в конструктор:

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;

  this.calcAge = function () {
    console.log(2037 - this.birthYear);
  };
}
```

При создании объектов каждый объект будет содержать собственную копию метода,
что неэффективно:

```javascript
const jonas = new Person("Jonas", 1991);
jonas.calcAge(); // 46
```

Но если создать тысячи таких объектов, память будет расходоваться нерационально.
Поэтому такой подход не рекомендуется.

**Правильный способ: прототипы**
Методы добавляются в прототип:

```javascript
Person.prototype.calcAge = function () {
  console.log(2037 - this.birthYear);
};
```

Теперь метод calcAge будет доступен всем объектам Person,
но хранится он будет только в одном месте (в прототипе).

```javascript
jonas.calcAge(); // 46
matilda.calcAge(); // 20
```

**Проверка принадлежности объекта конструктору:**
С помощью оператора instanceof можно проверить,
был ли объект создан через конкретный конструктор:

```javascript
console.log(jonas instanceof Person); // true
console.log({} instanceof Person); // false
```

**Итог: Функции-конструкторы — это "чертеж"**
Конструктор определяет, какие свойства и методы будут у объектов.
С помощью new можно создавать много объектов, используя этот "чертеж".

```javascript
const house1 = new Person("John", 1990);
const house2 = new Person("Sarah", 2000);

console.log(house1.firstName); // John
console.log(house2.firstName); // Sarah
```

Что дальше?
В следующем уроке изучается прототипное наследование,
чтобы мы могли более эффективно работать с методами и свойствами объектов.

// --------------------------------------------------------------------------------- //

## \*ПРОТОТИПЫ

Подробное объяснение с примерами: Прототипы и прототипное наследование
Разберем, что такое прототипы и как они работают в JavaScript,
используя более простой язык и дополнительные примеры,
чтобы это стало понятно даже новичку.

1. Что такое прототипы в JavaScript?
   В JavaScript прототипы — это механизм, который позволяет объектам
   наследовать свойства и методы от других объектов.
   Это основа так называемого прототипного наследования.

Ключевые моменты:
Каждая функция в JavaScript, включая конструкторы, автоматически имеет свойство prototype.
Объекты, созданные с помощью конструктора, наследуют методы и свойства,
определенные на prototype этого конструктора.

2. Практический пример
   Создадим конструктор Person:

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
}
```

// Создаем объект
const jonas = new Person('Jonas', 1991);
console.log(jonas);

Что произошло здесь?
Мы вызвали функцию Person с оператором new, что:
Создало новый пустой объект.
Установило this внутри функции на этот новый объект.
Связало новый объект с прототипом Person.prototype.
Вернуло новый объект.

3. Добавление метода через прототип
   **Плохой подход: добавление метода напрямую в конструктор**
   Если мы добавим метод прямо в функцию-конструктор,
   каждый объект будет получать собственную копию метода.
   Это неэффективно:

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;

  this.calcAge = function () {
    return 2024 - this.birthYear;
  };
}

const jonas = new Person("Jonas", 1991);
const matilda = new Person("Matilda", 2017);

console.log(jonas.calcAge()); // Работает, но создается отдельная копия метода для каждого объекта
console.log(matilda.calcAge());
```

Так делать не стоит, так как при создании тысячи объектов
метод calcAge будет дублироваться тысячу раз.

**Правильный подход: добавление метода на prototype**
Добавим метод на прототип Person.prototype:

```javascript
Person.prototype.calcAge = function () {
  return 2024 - this.birthYear;
};

const jonas = new Person("Jonas", 1991);
const matilda = new Person("Matilda", 2017);

console.log(jonas.calcAge()); // 33
console.log(matilda.calcAge()); // 7
```

Что произошло здесь?
Метод calcAge был добавлен к Person.prototype.
Все объекты, созданные с помощью конструктора Person, могут использовать этот метод.
Однако метод не копируется в каждый объект! Он доступен через связь объекта с прототипом.

4. Прототипное наследование: как оно работает
   Каждый объект в JavaScript имеет скрытое свойство [[Prototype]] (или **proto** в старом синтаксисе),
   которое указывает на его прототип.

Проверим прототип jonas:

```javascript
console.log(jonas.__proto__); // Выведет Person.prototype
console.log(jonas.__proto__ === Person.prototype); // true
```

5. Свойства прототипа
   Мы можем добавлять не только методы, но и свойства на prototype:

```javascript
Person.prototype.species = "Homo sapiens";

console.log(jonas.species); // "Homo sapiens"
console.log(matilda.species); // "Homo sapiens"
```

**Отличие от собственных свойств объекта:**
Собственные свойства (Own Properties) хранятся прямо в объекте:

```javascript
console.log(jonas.hasOwnProperty("firstName")); // true
console.log(jonas.hasOwnProperty("species")); // false
```

Свойство species доступно через прототип, но не является собственным.

6. Проверка наследования
   JavaScript предоставляет методы для проверки прототипного наследования:

```javascript
console.log(Person.prototype.isPrototypeOf(jonas)); // true
console.log(Person.prototype.isPrototypeOf(matilda)); // true
```

7. Сравнение: прототип конструктора и прототип объекта
   Person.prototype — это прототип, который используется для создания новых объектов.
   jonas.**proto** — это прототип объекта jonas, который указывает на Person.prototype.

8. Как работает new и связь с прототипом?
   Когда мы используем new, выполняются следующие шаги:

Создается новый пустой объект.
Устанавливается связь объекта с prototype конструктора.
Новый объект возвращается из функции.

**Код за кулисами:**

```javascript
const jonas = Object.create(Person.prototype);
jonas.firstName = "Jonas";
jonas.birthYear = 1991;
```

9. Итоговая диаграмма связей
   Конструктор: Person
   Прототип конструктора: Person.prototype
   Объекты: jonas, matilda
   Связь объектов с прототипом: jonas.**proto** === Person.prototype

**Пример для практики**
Создадим другой конструктор Car:

```javascript
function Car(make, year) {
  this.make = make;
  this.year = year;
}

Car.prototype.getAge = function () {
  return 2024 - this.year;
};

const bmw = new Car("BMW", 2018);
const toyota = new Car("Toyota", 2015);

console.log(bmw.getAge()); // 6
console.log(toyota.getAge()); // 9
```

**Вывод**
Использование prototype позволяет эффективно добавлять методы и свойства.
Все объекты, созданные через один конструктор, могут использовать методы прототипа без дублирования.

---

**Вы сказали:**
То есть как я понял в этой строке кода:
console.log(jonas.**proto** === Person.prototype); // true

У Person есть свой prototype, точно также у объекта jonas тоже есть свой prototype.
Я правильно понял ?

**ChatGPT сказал:**
Почти правильно, но есть важное уточнение.
Давайте разберём подробно, чтобы не было путаницы.

**Уточнение:**
У Person (функции-конструктора) есть свойство prototype.
Это объект, на который будут ссылаться все объекты, созданные с помощью Person и оператора new.

У jonas (объекта) нет своего свойства prototype.
Вместо этого у него есть скрытое свойство **proto**,
которое указывает на объект Person.prototype.
Это и есть связь объекта с прототипом.

**Подробно с примерами:**

1. Что такое Person.prototype?
   Когда вы создаете функцию-конструктор, JavaScript автоматически добавляет ей свойство prototype.
   Это специальный объект, который используется как "шаблон" для всех объектов,
   создаваемых через эту функцию.

```javascript
function Person(name) {
  this.name = name;
}

// Person.prototype — это объект
console.log(Person.prototype); // {}
```

2. Что такое jonas.**proto**?
   Когда вы создаете объект с помощью new Person, JavaScript автоматически
   связывает этот объект с Person.prototype.
   Связь осуществляется через скрытое свойство **proto**.

```javascript
const jonas = new Person("Jonas");

// jonas.__proto__ указывает на Person.prototype
console.log(jonas.__proto__ === Person.prototype); // true
```

3. Разница между prototype и **proto**:
   Person.prototype — это объект, который используется для создания связей с будущими объектами.
   jonas.**proto** — это ссылка на Person.prototype.

**Почему jonas.**proto** === Person.prototype?**
Когда вы создаете объект с помощью new, происходит следующее:

Новый объект создается.
Новому объекту устанавливается скрытое свойство **proto**,
которое ссылается на Person.prototype.
Новый объект возвращается.

**Это видно на примере:**

```javascript
const jonas = new Person("Jonas");

// JavaScript за кулисами делает следующее:
jonas.__proto__ = Person.prototype;
```

**Итог:**
У Person есть prototype, который используется как прототип для всех объектов, создаваемых этой функцией.
У jonas нет своего prototype, но есть **proto**, которое ссылается на Person.prototype.

**На диаграмме это будет выглядеть так:**
Person (функция) ---> Person.prototype (объект-прототип)
jonas (объект) ---> **proto** ---> Person.prototype

---

**Вы сказали:**
В этой строке кода, когда добавляем метод calcAge через protorype Person,
создается ли этот метод и внутри Person.prototype ?
Как это было для jonas.**proto**

```javascript
Person.prototype.calcAge = function () {
  return 2024 - this.birthYear;
};

const jonas = new Person("Jonas", 1991);
const matilda = new Person("Matilda", 2017);

console.log(jonas.calcAge()); // 33
console.log(matilda.calcAge()); // 7
```

**ChatGPT сказал:**
Да, когда вы добавляете метод calcAge через Person.prototype,
этот метод создается внутри объекта Person.prototype.
Давайте разберем, как это работает.

**Как это работает?**
Добавление метода: Когда вы пишете:

```javascript
Person.prototype.calcAge = function () {
  return 2024 - this.birthYear;
};
```

Вы добавляете функцию calcAge в объект Person.prototype.
Теперь этот метод становится доступным для всех объектов,
созданных с помощью конструктора Person.

```javascript
console.log(Person.prototype);
// { calcAge: [Function] }
```

Связь через **proto**:
Когда вы создаете объект jonas через new Person,
JavaScript автоматически связывает его скрытое свойство **proto**
с объектом Person.prototype.

```javascript
const jonas = new Person("Jonas", 1991);

// jonas.__proto__ указывает на Person.prototype
console.log(jonas.__proto__ === Person.prototype); // true
```

Это значит, что jonas не содержит метод calcAge напрямую.
Вместо этого, когда вы вызываете jonas.calcAge(),
JavaScript проверяет объект jonas.
Если там нет свойства calcAge, он смотрит в jonas.**proto**,
который ссылается на Person.prototype.
В данном случае он находит calcAge там и использует его.

**Проверка структуры:**
Давайте убедимся, что метод calcAge находится в Person.prototype:

```javascript
console.log(Person.prototype);
// { calcAge: [Function: calcAge] }
```

Проверим, есть ли метод calcAge непосредственно в объекте jonas:

```javascript
console.log(jonas.hasOwnProperty("calcAge")); // false
```

Это возвращает false, потому что calcAge находится не в самом jonas, а в его прототипе.

**Итог:**
Метод calcAge добавляется в объект Person.prototype.
Все объекты, созданные через new Person, могут использовать этот метод
благодаря их скрытой ссылке **proto**, которая указывает на Person.prototype.

**Графически это выглядит так:**
Person (функция) ---> Person.prototype { calcAge }
jonas (объект) ---> **proto** ---> Person.prototype
matilda (объект) ---> **proto** ---> Person.prototype

**Преимущества такого подхода:**
Экономия памяти:
Метод calcAge существует только в одном экземпляре — в Person.prototype.
Все объекты (jonas, matilda) просто "наследуют" его,
вместо создания копий для каждого объекта.

Удобство добавления функциональности:
Если вы добавите новый метод в Person.prototype,
все объекты, созданные через Person,
автоматически получат доступ к этому методу.

---

**Я спросил у GPT:**
Почему тогда свойство добавленные внутри функции конструктора Person,
и эти свойство на прямую добавляются и для объекта jonas,
при создании этого объекта jonas с помощью
const jonas = new Person('Jonas', 1991); ?

Если происходит следующее:
когда мы создаем объект с помощью new,

происходит следующее:
Новый объект создается.
Новому объекту устанавливается скрытое свойство **proto**,
которое ссылается на Person.prototype.
Новый объект возвращается.

**ChatGPT сказал:**
Прекрасный вопрос! Давайте разберем это более подробно и шаг за шагом,
чтобы понять, почему свойства, добавленные внутри функции конструктора Person,
добавляются непосредственно в создаваемый объект (jonas),
а методы, добавленные через Person.prototype, остаются в прототипе.

**Что происходит при вызове new:**
Когда вы вызываете new Person('Jonas', 1991);,
происходит несколько шагов (как вы правильно указали):

1. Создается новый пустой объект:
   {}.

2. Устанавливается связь с прототипом:
   Новому объекту устанавливается скрытое свойство **proto**,
   которое ссылается на Person.prototype.

3. Выполняется функция-конструктор Person:
   Функция-конструктор Person вызывается в контексте нового объекта.
   Это означает, что this внутри Person указывает на новый объект (jonas).

4. Добавляются свойства в новый объект:
   Все свойства, объявленные с помощью this внутри конструктора,
   добавляются напрямую в новый объект, потому что this указывает на него.

5. Возвращается новый объект:
   После выполнения конструктора объект возвращается,
   и переменная jonas ссылается на этот объект.

**Почему свойства добавляются напрямую?**

Рассмотрим ваш пример:

```javascript
function Person(name, birthYear) {
  this.name = name; // Прямое добавление свойства в объект
  this.birthYear = birthYear; // Прямое добавление свойства в объект
}

const jonas = new Person("Jonas", 1991);
```

Когда конструктор Person выполняется, this указывает на новый объект jonas.
Вы добавляете свойства name и birthYear с помощью this.name = name и this.birthYear = birthYear.
Эти свойства напрямую записываются в объект jonas.

В результате:

```javascript
console.log(jonas);
// { name: 'Jonas', birthYear: 1991 }
```

**Связь с прототипом:**
Когда вы добавляете метод через Person.prototype:

```javascript
Person.prototype.calcAge = function () {
  console.log(2024 - this.birthYear);
};
```

Этот метод записывается в объект Person.prototype.
Новый объект jonas не содержит метода calcAge в себе,
но через **proto** может его использовать.

**Почему свойства и методы ведут себя по-разному?**
Свойства конструктора:
Свойства, добавленные через this в конструкторе, записываются в каждый созданный объект.
Это логично, так как эти свойства, как правило, индивидуальны для каждого объекта.
Например, name и birthYear у jonas и matilda разные.

Методы через прототип:
Методы добавляются в Person.prototype,
чтобы:
Избежать дублирования в каждом объекте.
Сэкономить память: метод calcAge существует в единственном экземпляре.

**Итоговая структура:**
jonas (индивидуальные свойства):

```javascript
console.log(jonas);
// { name: 'Jonas', birthYear: 1991 }
```

jonas.**proto** (доступ к методам):

```javascript
console.log(jonas.__proto__);
// { calcAge: [Function: calcAge] }
```

**Вызов метода через прототип:**
Когда вы вызываете jonas.calcAge(),

JavaScript:
Сначала ищет calcAge в объекте jonas.
Не находит его и смотрит в jonas.**proto**,
который ссылается на Person.prototype.

Результат:

```javascript
console.log(jonas.calcAge()); // 33
```

**Почему так сделано?**
Свойства конструктора (name, birthYear) уникальны для каждого объекта.
Методы через прототип (calcAge) общие для всех объектов, созданных через Person.
Это помогает соблюдать DRY-принцип (Don't Repeat Yourself):
вы не создаете копию метода для каждого объекта,
а используете единственный экземпляр метода через Person.prototype.

// --------------------------------------------------------------------------------- //

## \*ЦЕПОЧКА ПРОТОТИПОВ

Цепочка прототипов (Prototype Chain)
Ключевые моменты:
У каждого объекта есть прототип, доступный через **proto**.
Person.prototype сам является объектом и тоже имеет прототип — Object.prototype.
У Object.prototype нет прототипа, его **proto** равно null. Это конец цепочки.

**Пример цепочки прототипов:**

```javascript
console.log(jonas.__proto__);
// { calcAge: [Function: calcAge], constructor: [Function: Person] }

console.log(jonas.__proto__.__proto__);
// { constructor: [Function: Object], hasOwnProperty: [Function: hasOwnProperty], ... }

console.log(jonas.__proto__.__proto__.__proto__);
// null
```

5. Поиск метода в цепочке
   Если вы вызовете метод, которого нет в объекте:

JS проверяет текущий объект.
Если метода нет, идет к прототипу (через **proto**).
И так далее, пока не дойдет до null.

**Пример:**

```javascript
console.log(jonas.hasOwnProperty("name")); // true
```

JS проверяет jonas — метода hasOwnProperty нет.
Идет в Person.prototype — метода там тоже нет.
Идет в Object.prototype, где находит hasOwnProperty.

6. Похожесть цепочки прототипов и цепочки областей видимости
   Цепочка областей видимости (Scope Chain):

Если переменная не найдена в текущей области, JS ищет ее во внешней области и так далее.

Цепочка прототипов:
Если свойство или метод не найдено в объекте,
JS ищет его в прототипе объекта, затем в прототипе прототипа, и так далее.

**Итоговая диаграмма:**
jonas.**proto** указывает на Person.prototype.
Person.prototype.**proto** указывает на Object.prototype.
Object.prototype.**proto** равно null.
Это и есть цепочка прототипов.

**Заключение**
Прототипы помогают организовать код и экономить память.
Все объекты связаны через цепочку прототипов.
Методы и свойства ищутся по цепочке, если их нет в объекте.
С пониманием этого вы сможете углубиться в ООП и использовать наследование,
а также оптимизировать код для больших приложений.

// --------------------------------------------------------------------------------- //

## \*ПРОТОТИПНОЕ НАСЛЕДОВАНИЕ ВСТРОЕННЫХ ОБЪЕКТОВ

Подробное объяснение работы прототипов и цепочки прототипов (с примерами):
В этом объяснении мы разберёмся с концепцией наследования через прототипы (prototypal inheritance)
и цепочки прототипов (prototype chain), начиная с простых примеров
и доходя до более сложных случаев с встроенными объектами, такими как массивы или функции.

1. Что такое прототипы?
   В JavaScript объекты могут наследовать свойства и методы от других объектов
   через механизм, называемый прототипами.
   У каждого объекта есть скрытое свойство [[Prototype]], доступное через **proto**.

**Пример:**

```javascript
const obj = { name: "Jonas" };
console.log(obj.__proto__); // Object.prototype
```

Когда мы обращаемся к свойству объекта, например, obj.hasOwnProperty,
JavaScript ищет это свойство в объекте obj.
Если оно не найдено, поиск продолжается в obj.**proto**,
затем в его прототипе и так далее до вершины цепочки — объекта Object.prototype.

2. Создание объектов через функции-конструкторы
   Функции-конструкторы — это способ создания объектов с помощью ключевого слова new.

**Пример:**

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Добавляем статический метод
Person.greet = function () {
  console.log("Hello from the Person constructor!");
};

// Создаем экземпляр
const person1 = new Person("Alice", 25);

// Вызов статического метода
Person.greet(); // Работает, выводит: "Hello from the Person constructor!"

// Попытка вызова статического метода на экземпляре
person1.greet(); // Ошибка: greet не является функцией
```

**Объяснение:**
Метод greet добавлен к самому конструктору Person.
Он доступен только через Person.greet().
Он недоступен через экземпляры, такие как person1.

2. Статический метод в классе

**Пример:**

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // Статический метод
  static greet() {
    console.log("Hello from the Person class!");
  }

  // Обычный метод (экземплярный)
  sayHi() {
    console.log(`Hi, my name is ${this.name}`);
  }
}

// Вызов статического метода
Person.greet(); // Работает, выводит: "Hello from the Person class!"

// Создаем экземпляр
const person1 = new Person("Alice", 25);

// Попытка вызова статического метода на экземпляре
person1.greet(); // Ошибка: greet не является функцией

// Вызов обычного метода
person1.sayHi(); // Работает, выводит: "Hi, my name is Alice"
```

**Объяснение:**
Метод greet доступен только через класс Person, а не через экземпляры.
Метод sayHi — это экземплярный метод, доступный через объекты, созданные с помощью класса.

**Ключевые различия: статические и экземплярные методы:**
| Характеристика | Статический метод | Экземплярный метод |
|------------------------|---------------------------|---------------------------|
| Где определяется | На уровне конструктора/класса | В прототипе конструктора/класса |
| Как вызывать | Через класс/конструктор | Через экземпляры |
| Использование this | Указывает на класс/конструктор | Указывает на конкретный объект |

**Пример использования this в статических методах:**
Когда вы вызываете статический метод,
this внутри метода ссылается на сам класс или конструктор.

**Пример:**

```javascript
class MathHelper {
  static square(number) {
    console.log(this); // Указывает на сам класс MathHelper
    return number * number;
  }
}

console.log(MathHelper.square(5)); // 25
```

**Почему статические методы полезны?**

1. Утилитарные функции:
   Статические методы используются для функций, которые не зависят
   от конкретных объектов, но связаны с классом.

**Пример:**

```javascript
class MathHelper {
  static add(a, b) {
    return a + b;
  }
}
console.log(MathHelper.add(2, 3)); // 5
```

2. Организация кода:
   Они помогают лучше структурировать код, указывая, что метод принадлежит классу, а не экземпляру.

3. Отсутствие лишних связей:
   Статические методы не требуют создания экземпляров, что экономит ресурсы.

**Итог:**
Статические методы привязаны к классу или функции-конструктору, а не к их экземплярам.
Они полезны для вспомогательных функций, которые логически связаны с классом, но не зависят от его объектов.
Чтобы создать статический метод в классе, используйте ключевое слово static.
Теперь вы можете начать использовать статические методы, чтобы писать более чистый и организованный код! 🚀

---

**Я спросил у GPT:**
Почему здесь работает статический метод from():

```javascript
const arrayLike = document.querySelectorAll("div"); // NodeList, похож на массив
const realArray = Array.from(arrayLike); // Преобразуем в настоящий массив
console.log(realArray); // Настоящий массив
```

А вот здесь не работает:

```javascript
Array.from(document.querySelector("div"));
```

**GPT сказал:**

1. Почему работает в первом случае:

```javascript
const arrayLike = document.querySelectorAll("div"); // NodeList, похож на массив
const realArray = Array.from(arrayLike); // Преобразуем в настоящий массив
console.log(realArray); // Настоящий массив
```

document.querySelectorAll('div') возвращает NodeList — это коллекция элементов, похожая на массив.
У неё есть индексы (0, 1, ...) и свойство length, но она не является полноценным массивом.
Array.from предназначен именно для таких объектов — он преобразует их в настоящий массив.
Поэтому всё работает корректно, и realArray становится массивом.

2. Почему не работает во втором случае:

```javascript
Array.from(document.querySelector("div"));
```

document.querySelector('div') возвращает единственный элемент DOM (или null, если такого элемента нет).
Это не NodeList или другой "массивоподобный" объект, а конкретный элемент (например, <div>),
у которого нет свойства length и индексов.

Array.from не может обработать обычный DOM-элемент, так как он ожидает объект,
похожий на массив (например, NodeList, arguments, Set, Map или объект с length).

**Что произойдет?**
Если элемент существует (например, <div>), то вызов Array.from выдаст ошибку:

```
TypeError: Array.from is not a function
```

Потому что DOM-элемент не соответствует требованиям для работы Array.from.

**Как исправить?**
Если вы хотите работать с результатом document.querySelector,
вы можете:

- Упаковать результат в массив вручную:

```javascript
const element = document.querySelector("div"); // Получаем один элемент
const realArray = Array.from([element]); // Упаковываем элемент в массив
console.log(realArray); // Теперь это массив
```

- Использовать querySelectorAll, если хотите получить все элементы, даже если их один:

```javascript
const arrayLike = document.querySelectorAll("div"); // Получаем NodeList
const realArray = Array.from(arrayLike); // Преобразуем в массив
console.log(realArray);
```

**Итог:**
querySelectorAll возвращает NodeList, который похож на массив,
поэтому его можно преобразовать с помощью Array.from.

querySelector возвращает один элемент, который не является массивоподобным объектом,
поэтому Array.from не работает напрямую.
Если вам нужно работать с одним элементом как с массивом,
упакуйте его в массив вручную.

// --------------------------------------------------------------------------------- //

## \*СОЗДАНИЕ ОБЪЕКТА - OBJECT CREATE

Object.create и прототипное наследование:
Автор объясняет, как использовать Object.create для создания объектов с явно заданным прототипом.
Это альтернативный способ работы с прототипным наследованием,
который отличается от использования конструкторов или ES6-классов.

**Основная идея:**
С помощью Object.create можно:

- Создать новый объект.
- Явно задать прототип этого объекта, передав его как аргумент.

**Пример:**
Создадим объект-прототип, который будет "родителем" для других объектов:

```javascript
const personProto = {
  calcAge() {
    console.log(`Возраст: ${2024 - this.birthYear}`);
  },
};
```

personProto — это обычный объект. Он будет "шаблоном" (прототипом) для других объектов.
Метод calcAge будет доступен всем объектам, созданным на основе personProto.

Теперь создадим объект на основе personProto:

```javascript
const steven = Object.create(personProto);
steven.firstName = "Steven";
steven.birthYear = 1990;

steven.calcAge(); // Возраст: 34
```

**Что происходит?**
Object.create(personProto) создает объект steven, у которого personProto является прототипом.
Это значит, что если в steven не находится свойства или метода, поиск идет в personProto.
Метод calcAge, определенный в personProto, доступен в steven.

**В чем отличие от конструкторов и классов?**
**Конструкторы и классы:**

- Вызываются через new.
- Автоматически создают прототип через prototype свойство.

**Пример:**

```javascript
class Person {
  constructor(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }

  calcAge() {
    console.log(`Возраст: ${2024 - this.birthYear}`);
  }
}

const sarah = new Person("Sarah", 1980);
sarah.calcAge(); // Возраст: 44
```

**Object.create:**

- Не использует new.
- Не требует конструктора.
- Прототип задается вручную.

**Как работает Object.create?**

1. Создаем прототипный объект. Это будет "родитель", который содержит общие методы:

```javascript
const personProto = {
  greet() {
    console.log(`Привет, я ${this.firstName}!`);
  },
};
```

2. Создаем новый объект с заданным прототипом.

```javascript
const steven = Object.create(personProto);
```

Теперь:

- steven — это пустой объект.
- У steven есть скрытое свойство [[Prototype]], указывающее на personProto.

3. Добавляем свойства.

```javascript
steven.firstName = "Steven";
steven.birthYear = 1990;
steven.greet(); // Привет, я Steven!
```

Метод greet не находится в steven, но поиск идет в personProto, где он и находится.

**Диаграмма для понимания:**
Автор упоминает диаграмму для объяснения.

Вот что происходит:
С Object.create:

```
steven -> personProto -> Object.prototype -> null
```

С классами или конструкторами:

```
sarah -> Person.prototype -> Object.prototype -> null
```

В обоих случаях цепочка прототипов (Prototype Chain) работает одинаково:
поиск свойства идет вверх по цепочке.

**Почему использовать Object.create?**

- Управление прототипом.
  Вы вручную задаете прототип объекта.
  Это проще для понимания и гибче.

- Легкость использования.
  Нет необходимости писать классы или конструкторы,
  если нужно просто создать объект с прототипом.

- Редкость в реальной жизни.
  Object.create используется реже, чем классы и конструкторы,
  но важно знать его, так как он помогает понять, как работают прототипы.

**Пример с улучшением: Метод init**
Добавим метод для упрощения создания объектов:

```javascript
const personProto = {
  init(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  },
  calcAge() {
    console.log(`Возраст: ${2024 - this.birthYear}`);
  },
};

// Создаем объект с помощью init
const sarah = Object.create(personProto);
sarah.init("Sarah", 1985);
sarah.calcAge(); // Возраст: 39
```

**Метод init:**

- Работает как конструктор, но вызывается вручную.
- Инициализирует свойства объекта.

**Плюсы и минусы Object.create:**
**Плюсы:**

- Простота и гибкость.
- Полный контроль над прототипом.
- Меньше "магии", чем с классами.

**Минусы:**

- Редко используется, поэтому менее привычен.
- Неудобно задавать свойства вручную без дополнительных методов (init решает эту проблему).

**Итог**
Object.create — это простой и гибкий способ работать с прототипами.
Он позволяет вручную устанавливать прототипы и создавать цепочки наследования.
Несмотря на редкость использования, понимание этого метода помогает
лучше понять работу прототипов и цепочки прототипов.
Используйте Object.create, когда нужен легкий способ
создать объект с прототипом, без усложнений конструкторами или классами.

---

**Вы сказали:**
В чем различие метода init() от функции конструктора ?

```javascript
const personProto = {
  init(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  },
  calcAge() {
    console.log(Возраст: ${2024 - this.birthYear});
  }
};

// Создаем объект с помощью init
const sarah = Object.create(personProto);
sarah.init('Sarah', 1985);
sarah.calcAge(); // Возраст: 39
```

**ChatGPT сказал:**
Различия между методом init() и функции-конструктором связаны с тем,
как они используются, и в каком контексте они работают.
Давайте подробно рассмотрим эти различия, чтобы было понятно.

### 1. Контекст вызова

**Метод init():**

- Это обычный метод, который находится в объекте-прототипе (в данном случае в personProto).
- Вызывается вручную для инициализации свойств объекта.
  ```javascript
  sarah.init("Sarah", 1985);
  ```
- Метод не создает объект, а просто инициализирует свойства
  уже существующего объекта (sarah в данном примере).

**Функция-конструктор:**

- Это функция, которая используется с оператором new
  для создания нового объекта и инициализации его свойств.

  ```javascript
  function Person(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }

  const sarah = new Person("Sarah", 1985);
  ```

- Функция-конструктор:
  - Создает новый объект.
  - Автоматически устанавливает прототип нового объекта на Person.prototype.
  - Возвращает новый объект, если не указано иное.

### 2. Как создается объект

**Метод init():**
Объект нужно создать вручную с помощью Object.create:

```javascript
const sarah = Object.create(personProto); // Новый объект с прототипом personProto
sarah.init("Sarah", 1985); // Инициализация
```

Здесь объект sarah создается вызовом Object.create(personProto).
Метод init просто заполняет свойства объекта, но не участвует в его создании.

**Функция-конструктор:**
Объект создается автоматически при вызове функции с оператором new:

```javascript
const sarah = new Person("Sarah", 1985); // Новый объект создан и сразу инициализирован
```

Новый объект создается внутри функции-конструктора,
и его прототип автоматически привязывается к Person.prototype.

### 3. Установка прототипа

**Метод init():**
Прототип объекта задается вручную через Object.create:

```javascript
const sarah = Object.create(personProto);
```

Здесь вы явно указываете, что прототипом для sarah будет personProto.

**Функция-конструктор:**
Прототип устанавливается автоматически на основе свойства prototype функции:

```javascript
Person.prototype.calcAge = function () {
  console.log(`Возраст: ${2024 - this.birthYear}`);
};

const sarah = new Person("Sarah", 1985);
// Прототип объекта sarah — это Person.prototype
```

### 4. Использование в реальном коде

**Метод init():**

- Удобен, если вы хотите создать объект на основе заранее определенного прототипа.
- Используется в комбинации с Object.create.
- Подходит для случаев, когда нужен полный контроль над прототипами.

**Пример:**

```javascript
const personProto = {
  init(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  },
  calcAge() {
    console.log(`Возраст: ${2024 - this.birthYear}`);
  },
};

// Создание нового объекта с заданным прототипом
const sarah = Object.create(personProto);
sarah.init("Sarah", 1985);
sarah.calcAge(); // Возраст: 39
```

**Функция-конструктор:**

- Это более "традиционный" способ создания объектов.
- Используется чаще в старых кодах, где классы (ES6) еще не применялись.
- Удобна для создания множества объектов одного типа.

**Пример:**

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
}

Person.prototype.calcAge = function () {
  console.log(`Возраст: ${2024 - this.birthYear}`);
};

const sarah = new Person("Sarah", 1985);
sarah.calcAge(); // Возраст: 39
```

### 5. ES6-классы как альтернатива

С появлением ES6-классов разница между init и функциями-конструкторами
стала менее заметной, так как классы объединяют их возможности.

**Пример класса:**

```javascript
class Person {
  constructor(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }

  calcAge() {
    console.log(`Возраст: ${2024 - this.birthYear}`);
  }
}

const sarah = new Person("Sarah", 1985);
sarah.calcAge(); // Возраст: 39
```

- constructor — это аналог функции-конструктора.
- Методы класса автоматически добавляются в прототип.

**Итог**

- init() — это просто метод, который нужно вручную вызвать для заполнения свойств объекта.
  Он не создает объект и не работает с прототипами автоматически.
- Функция-конструктор — создает объект автоматически через new и связывает его с прототипом.
- Если вы хотите гибкости и явного контроля — используйте init() с Object.create.
  Если нужен упрощенный процесс создания объектов — используйте функцию-конструктор или ES6-классы.

---

**Вы сказали:**
То есть функция init() создает свойство this.firstName = firstName;
this.birthYear = birthYear; для объекта sarah = Object.create(personProto) ?

**ChatGPT сказал:**
Да, именно так!

Метод init() добавляет свойства firstName и birthYear в объект sarah,
который был создан с помощью Object.create(personProto).

Вот пошаговая логика:

1. **Создание объекта sarah**

```javascript
const sarah = Object.create(personProto);
```

Здесь мы создаем объект sarah, чьим прототипом является объект personProto.
На данном этапе объект sarah пустой, но он уже "наследует" методы из personProto, такие как calcAge.

Пример содержимого объекта sarah сразу после создания:

```javascript
console.log(sarah);
// {}
```

Но прототип sarah — это personProto, поэтому мы видим унаследованные методы:

```javascript
console.log(Object.getPrototypeOf(sarah) === personProto); // true
```

2. **Вызов метода init()**

```javascript
sarah.init("Sarah", 1985);
```

Метод init() вызывается на объекте sarah.
Внутри метода init(), ключевая часть кода — это:

```javascript
this.firstName = firstName;
this.birthYear = birthYear;
```

this указывает на объект sarah, так как метод вызван как sarah.init(...).
Эти строки создают новые свойства в объекте sarah и устанавливают их значения.

После вызова:

```javascript
console.log(sarah);
// { firstName: 'Sarah', birthYear: 1985 }
```

3. **Итог: свойства находятся в объекте sarah**
   Свойства firstName и birthYear добавлены в сам объект sarah, а не в прототип.

```javascript
console.log(sarah.firstName); // Sarah
console.log(sarah.birthYear); // 1985
```

Методы, такие как calcAge(), находятся в прототипе personProto,
но доступны через прототипную цепочку:

```javascript
sarah.calcAge(); // Возраст: 39
```

**Сравнение с функцией-конструктором:**
Если бы мы использовали функцию-конструктор, то аналогичные свойства
также добавлялись бы в созданный объект, но через процесс вызова new:

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
}

const sarah = new Person("Sarah", 1985);
```

И результат был бы таким же:

```javascript
console.log(sarah);
// { firstName: 'Sarah', birthYear: 1985 }
```

**Почему используется init():**
Метод init() используется в подходе с Object.create,
чтобы избежать ручного добавления свойств:

```javascript
// Без init():
sarah.firstName = "Sarah";
sarah.birthYear = 1985;

// С init():
sarah.init("Sarah", 1985);
```

Этот подход упрощает инициализацию объектов
и делает его более структурированным.

// --------------------------------------------------------------------------------------- //

## \*НАСЛЕДОВАНИЕ МЕЖДУ ФУНКЦИЯМИ КОНСТРУКТОРА И КЛАССОВ

Что такое прототипное наследование?
Основные идеи:

- Прототипы:
  Каждый объект в JavaScript имеет скрытое свойство [[Prototype]],
  которое указывает на другой объект (его прототип).

- Наследование:
  Если свойство или метод отсутствует у объекта,
  JavaScript ищет его в прототипе. Это называется цепочкой прототипов.

**Простая демонстрация:**

```javascript
const personProto = {
  calcAge() {
    console.log(2024 - this.birthYear);
  },
};

// Создаем объект sarah, который наследует от personProto
const sarah = Object.create(personProto);
sarah.birthYear = 1985;

sarah.calcAge(); // Вывод: 39
```

Здесь:
Объект sarah наследует метод calcAge от personProto через цепочку прототипов.

### 1. Наследование через функции-конструкторы

Функции-конструкторы — это старый способ создания объектов и их наследования.

**Шаг 1. Создаем базовый "родительский" класс**

```javascript
function Person(firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
}

Person.prototype.calcAge = function () {
  console.log(2024 - this.birthYear);
};
```

- Функция Person создаёт объекты с firstName и birthYear.
- Метод calcAge добавляется в Person.prototype,
  чтобы не дублировать его для каждого экземпляра.

**Шаг 2. Создаем "дочерний" класс**
Теперь создадим конструктор Student, который наследует от Person:

```javascript
function Student(firstName, birthYear, course) {
  Person.call(this, firstName, birthYear); // Вызываем Person как функцию
  this.course = course; // Добавляем уникальное свойство
}
```

Здесь:
Person.call(this, firstName, birthYear) вызывает функцию Person,
но внутри объекта Student. Это устанавливает свойства firstName и birthYear.

**Шаг 3. Настраиваем прототипное наследование**
Чтобы объект Student наследовал методы Person, нужно связать их прототипы:

```javascript
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
```

- Object.create(Person.prototype) создаёт новый объект,
  который наследует от Person.prototype.
- Student.prototype.constructor = Student исправляет ссылку на конструктор,
  которая по умолчанию указывает на Person.

**Шаг 4. Добавляем уникальные методы в Student**

```javascript
Student.prototype.introduce = function () {
  console.log(`Меня зовут ${this.firstName}, я изучаю ${this.course}`);
};
```

**Шаг 5. Используем классы**
Создадим объект и протестируем:

```javascript
const mike = new Student("Mike", 2000, "Computer Science");

mike.introduce(); // Меня зовут Mike, я изучаю Computer Science
mike.calcAge(); // Вывод: 24
```

Здесь:

- Метод introduce берётся из Student.prototype.
- Метод calcAge берётся через цепочку прототипов из Person.prototype.

### 2. Наследование через ES6 классы

ES6 классы упрощают процесс.

**Шаг 1. Создаем родительский класс**

```javascript
class Person {
  constructor(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }

  calcAge() {
    console.log(2024 - this.birthYear);
  }
}
```

**Шаг 2. Создаем дочерний класс**

```javascript
class Student extends Person {
  constructor(firstName, birthYear, course) {
    super(firstName, birthYear); // Вызывает конструктор родителя
    this.course = course;
  }

  introduce() {
    console.log(`Меня зовут ${this.firstName}, я изучаю ${this.course}`);
  }
}
```

- Ключевое слово extends указывает, что Student наследует от Person.
- Метод super вызывает конструктор родительского класса.

**Шаг 3. Используем классы**

```javascript
const jane = new Student("Jane", 1995, "Mathematics");

jane.introduce(); // Меня зовут Jane, я изучаю Mathematics
jane.calcAge(); // Вывод: 29
```

### 3. Наследование через Object.create

Это более ручной способ.

**Шаг 1. Создаем прототип**

```javascript
const personProto = {
  calcAge() {
    console.log(2024 - this.birthYear);
  },
};

const studentProto = Object.create(personProto);
```

Теперь studentProto наследует все методы из personProto, например calcAge.

**Расширение studentProto:**
Добавим уникальные свойства и методы для студентов:

- Свойство course, чтобы хранить информацию о курсе студента.
- Метод introduce, чтобы студент мог представиться.

```javascript
studentProto.init = function (firstName, birthYear, course) {
  personProto.init.call(this, firstName, birthYear); // Вызов родительского метода
  this.course = course;
};

studentProto.introduce = function () {
  console.log(`Меня зовут ${this.firstName}, и я изучаю ${this.course}.`);
};
```

**Создание объекта студента:**
Теперь создадим конкретного студента:

```javascript
const jane = Object.create(studentProto);
jane.init("Jane", 2000, "Computer Science");
jane.introduce(); // Меня зовут Jane, и я изучаю Computer Science.
jane.calcAge(); // Возраст: 24
```

**Объяснение цепочки прототипов:**

- jane наследует методы от studentProto (introduce).
- studentProto наследует методы от personProto (calcAge).

Можно проверить это через console.log:

```javascript
console.log(jane.__proto__ === studentProto); // true
console.log(studentProto.__proto__ === personProto); // true
```

**Почему это важно?**
Использование Object.create позволяет:

- Упростить создание цепочек прототипов.
- Обойтись без функций-конструкторов или классов.
- Ясно видеть, как объекты связаны друг с другом.
  Этот подход идеально подходит для ситуаций, где требуется максимальная гибкость.

// --------------------------------------------------------------------------------------- //

## \*НАСЛЕДОВАНИЕ МЕЖДУ КЛАССАМИ ES6

1. Создание базового класса
   Начнем с базового класса, который называется Person.
   Это родительский класс, содержащий общие свойства и методы.

**Код:**

```javascript
class Person {
  constructor(firstName, birthYear) {
    this.firstName = firstName;
    this.birthYear = birthYear;
  }

  calcAge() {
    console.log(`Age: ${2024 - this.birthYear}`);
  }
}
```

**Пояснения:**

- class Person:
  Создаем класс Person.
- constructor:
  Метод конструктора вызывается, когда создается новый объект этого класса.
  Он инициализирует свойства (firstName и birthYear).
- Метод calcAge(): Вычисляет возраст на основе текущего года.

**Пример использования:**

```javascript
const person = new Person("Alice", 1990);
console.log(person); // { firstName: 'Alice', birthYear: 1990 }
person.calcAge(); // Age: 34
```

2. Наследование с помощью extends
   Теперь создадим класс Student, который наследует свойства и методы Person.

**Код:**

```javascript
class Student extends Person {
  constructor(firstName, birthYear, course) {
    super(firstName, birthYear); // Вызов конструктора родительского класса
    this.course = course; // Добавляем новое свойство
  }

  introduce() {
    console.log(`Hi, I'm ${this.firstName}, and I study ${this.course}.`);
  }
}
```

**Пояснения:**

- extends Person:
  Student наследует от Person.
  Это автоматически связывает прототипы
  (Student.prototype ссылается на Person.prototype).

- constructor в дочернем классе:

  - super(firstName, birthYear):
    Вызывает конструктор родительского класса Person.
    Это нужно для инициализации свойств firstName и birthYear.
  - super обязателен:
    Вызывается первым в конструкторе дочернего класса.
    Это создает объект и позволяет использовать this.

- Метод introduce():
  Добавлен только в классе Student.

**Пример использования:**

```javascript
const student = new Student("Bob", 2003, "Math");
console.log(student); // { firstName: 'Bob', birthYear: 2003, course: 'Math' }
student.calcAge(); // Age: 21 (наследуется от Person)
student.introduce(); // Hi, I'm Bob, and I study Math.
```

3. Прототипная цепочка
   Наследование работает за счет связи прототипов.

Когда вызывается метод:

- JavaScript ищет метод в объекте (например, student).
- Если метод не найден, он ищет его в Student.prototype.
- Если и там нет, поиск продолжается в Person.prototype.
- Если ничего не найдено, он ищет в Object.prototype.

**Пример:**

```javascript
console.log(student);
// student -> Student.prototype -> Person.prototype -> Object.prototype
```

4. Переопределение методов
   Мы можем переопределить метод родительского класса в дочернем.

**Код:**

```javascript
class Student extends Person {
  constructor(firstName, birthYear, course) {
    super(firstName, birthYear);
    this.course = course;
  }

  calcAge() {
    const age = 2024 - this.birthYear;
    console.log(
      `I am ${age} years old, but as a student, I feel like ${age + 10}.`
    );
  }
}
```

**Пояснения:**

- Новый метод calcAge() в Student переопределяет метод из Person.
- Если вызвать student.calcAge(), выполнится новая версия метода.

**Пример:**

```javascript
student.calcAge();
// I am 21 years old, but as a student, I feel like 31.
```

5. Упрощение: без конструктора в дочернем классе
   Если дочерний класс не добавляет новых свойств, можно не писать constructor.
   В этом случае super вызывается автоматически.

**Код:**

```javascript
class Student extends Person {
  introduce() {
    console.log(`Hi, I'm ${this.firstName}`);
  }
}
```

**Пример:**

```javascript
const student = new Student("Charlie", 2001);
student.calcAge(); // Age: 23
student.introduce(); // Hi, I'm Charlie
```

6. Проверка наследования
   Посмотрим прототипы и убедимся, что наследование настроено правильно.

**Код:**

```javascript
console.log(student.__proto__); // Student.prototype
console.log(student.__proto__.__proto__); // Person.prototype
```

7. Важные замечания:

- Абстракция:
  Синтаксис классов (class) скрывает детали реализации наследования,
  которые основаны на прототипах.
- Проблемы с наследованием:
  В реальных проектах наследование может привести к жесткой связности кода.
  Если родительский класс меняется, это может поломать дочерние классы.

8. Альтернатива: Object.create
   Вместо классов можно использовать Object.create для создания объектов с наследованием.

**Пример:**

```javascript
const personProto = {
  calcAge() {
    console.log(2024 - this.birthYear);
  },
};

const studentProto = Object.create(personProto);
studentProto.introduce = function () {
  console.log(`Hi, I'm ${this.firstName}`);
};

const student = Object.create(studentProto);
student.firstName = "Dana";
student.birthYear = 1998;

student.calcAge(); // 26
student.introduce(); // Hi, I'm Dana
```

**Итог**
Синтаксис классов (class) удобен, но скрывает детали реализации наследования.
Ключевые моменты:

- extends для наследования.
- super для вызова конструктора родителя.
- Переопределение методов позволяет изменять поведение наследуемых классов.

// --------------------------------------------------------------------------------------- //

## \*СВОЙСТВА И МЕТОДЫ, ЗАЩИЩЕННЫЕ ИНКАПСУЛЯЦИЕЙ

Что такое инкапсуляция и защита данных?
Инкапсуляция — это принцип объектно-ориентированного программирования (ООП),
который позволяет скрывать некоторые свойства и методы внутри класса,
ограничивая доступ к ним извне.
Это достигается созданием четкого разделения между:

- Приватными данными/методами — которые нельзя изменять или вызывать извне.
- Публичным интерфейсом (API) — методами, которые разработчик предоставляет для работы с объектом.

**Цели:**

- Защита от случайного изменения или удаления важных данных.
- Упрощение изменений внутри класса, не нарушая внешний код, использующий класс.

**Пример реализации инкапсуляции в JavaScript:**
В JavaScript пока не реализована полная защита данных на уровне языка
(реализуется через соглашения или новые возможности, например, # для приватных полей).

```javascript
class Account {
  constructor(owner, currency, pin) {
    this.owner = owner; // Публичное свойство
    this.currency = currency;
    this._pin = pin; // "Приватное" свойство (через соглашение)
    this._movements = []; // "Приватное" свойство
    console.log(`Спасибо за открытие счета, ${owner}`);
  }

  // Метод для добавления движения
  deposit(value) {
    this._movements.push(value);
  }

  // Метод для снятия средств
  withdraw(value) {
    this.deposit(-value);
  }

  // Публичный метод для доступа к движениям
  getMovements() {
    return this._movements;
  }
}
```

**Объяснение кода:**

- Свойства _movements и \_pin:
  Мы добавили _ перед именем свойства, чтобы обозначить его как "приватное"
  (это не защищает данные, но служит соглашением для разработчиков).

- Методы:
  - deposit и withdraw: Позволяют работать с движениями через публичный интерфейс.
  - getMovements: Публичный метод, который предоставляет доступ к движениям.
    Без него прямое обращение к \_movements нежелательно.

**Пример использования:**

```javascript
const acc1 = new Account("Jonas", "EUR", 1234);

// Используем публичный интерфейс
acc1.deposit(200);
acc1.withdraw(50);

console.log(acc1.getMovements()); // [200, -50]

// Прямой доступ к _movements (не рекомендуется, но возможен)
acc1._movements.push(1000);
console.log(acc1.getMovements()); // [200, -50, 1000]
```

**Проблемы текущей реализации:**

- Доступность "приватных" свойств:
  Несмотря на соглашение (\_), свойства \_movements и \_pin остаются доступными.
  Ничто не мешает пользователю случайно (или намеренно) изменить данные напрямую.

- Защита методов:
  Пример с внутренним методом \_approveLoan:

```javascript
_approveLoan(value) {
  return value < 1000; // Простая проверка
}
```

Этот метод может быть вызван извне, что нарушает принцип инкапсуляции:

```javascript
acc1._approveLoan(500); // Доступен, хотя не должен быть
```

**Улучшение: публичный API для доступа к данным**
Для доступа к приватным данным можно создать публичные методы.

```javascript
class Account {
  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this._pin = pin;
    this._movements = [];
  }

  // Публичный метод для получения PIN (если требуется)
  getPin() {
    return "Этот метод только для демонстрации, не используйте в реальных приложениях";
  }

  // Публичный метод для запроса баланса
  getBalance() {
    return this._movements.reduce((acc, mov) => acc + mov, 0);
  }
}

const acc1 = new Account("Jonas", "EUR", 1234);
acc1.deposit(200);
console.log(acc1.getBalance()); // 200
```

**Результат:**
Мы ограничили прямой доступ к данным.
Создали четкий и понятный публичный интерфейс (API).
Однако настоящая защита данных пока не обеспечена.
Следующий шаг — использовать приватные поля.
В следующем уроке разберем, как использовать #
для полной приватизации данных в JavaScript.

// --------------------------------------------------------------------------------------- //

## \*ИНКАПСУЛЯЦИЯ ПОЛЕЙ И МЕТОДОВ ЗАКРЫТОГО КЛАССА

Подробное объяснение новой концепции Приватных полей и методов в JavaScript:
Новый стандарт JavaScript, известный как Class Fields,
предоставляет четыре новых типа возможностей:
публичные поля, приватные поля, публичные методы и приватные методы.
Вот подробное объяснение каждого аспекта с примерами:

### 1. Публичные поля

Публичные поля создаются прямо внутри класса без использования ключевых слов let, const, или var.
Они являются свойствами, доступными для всех экземпляров класса.

**Пример:**

```javascript
class Account {
  owner = "Anonymous"; // Публичное поле
  currency = "USD"; // Публичное поле

  constructor(owner, currency) {
    this.owner = owner;
    this.currency = currency;
  }
}

const acc1 = new Account("Jonas", "EUR");
console.log(acc1.owner); // "Jonas"
console.log(acc1.currency); // "EUR"
```

**Особенности:**

- Такие поля находятся в экземпляре, а не в прототипе.
- Их можно инициализировать значением по умолчанию, как в примере выше.

### 2. Приватные поля

Приватные поля обозначаются символом # перед именем свойства.
Они полностью скрыты от внешнего кода и доступны только внутри класса.

**Пример:**

```javascript
class Account {
  #pin; // Приватное поле

  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this.#pin = pin; // Устанавливаем значение приватного поля
  }

  getPin() {
    return this.#pin; // Доступ внутри класса
  }
}

const acc2 = new Account("Sarah", "GBP", 1234);
console.log(acc2.getPin()); // 1234
console.log(acc2.#pin); // Ошибка: Нельзя обратиться к приватному полю
```

**Особенности:**

- Приватные поля недоступны даже через наследование или прямую ссылку.
- Это реальная защита данных.

### 3. Публичные методы

Публичные методы — это стандартные методы класса.
Они определяются без каких-либо изменений и доступны для экземпляров.

**Пример:**

```javascript
class Account {
  constructor(owner) {
    this.owner = owner;
  }

  greet() {
    console.log(`Hello, ${this.owner}!`);
  }
}

const acc3 = new Account("Mike");
acc3.greet(); // "Hello, Mike!"
```

**Особенности:**

- Эти методы создаются в прототипе класса, а не в экземпляре.
- Их можно вызывать напрямую через экземпляры класса.

### 4. Приватные методы

Приватные методы обозначаются символом #, как и приватные поля.
Они используются только внутри класса.

**Пример:**

```javascript
class Account {
  #approveLoan(value) {
    // Приватный метод
    return value < 5000;
  }

  requestLoan(value) {
    if (this.#approveLoan(value)) {
      console.log("Loan approved");
    } else {
      console.log("Loan denied");
    }
  }
}

const acc4 = new Account();
acc4.requestLoan(3000); // "Loan approved"
acc4.#approveLoan(3000); // Ошибка: Метод приватный
```

**Особенности:**

- Это позволяет скрывать логику, которая не предназначена для внешнего использования.

### 5. Статические поля и методы

Статические поля и методы принадлежат самому классу, а не его экземплярам.
Они определяются с использованием ключевого слова static.

**Пример:**

```javascript
class Account {
  static bankName = "Global Bank"; // Статическое поле

  static showBankInfo() {
    // Статический метод
    console.log(`Welcome to ${this.bankName}`);
  }
}

Account.showBankInfo(); // "Welcome to Global Bank"
console.log(Account.bankName); // "Global Bank"
```

**Особенности:**

- Доступ к статическим методам и полям осуществляется через сам класс, а не через экземпляры.

---

**Вы сказали:**
Приватные методы работают в 2024 году ?

**ChatGPT сказал:**
Да, в 2024 году приватные методы (обозначаемые символом #)
поддерживаются большинством современных браузеров,
включая последние версии Google Chrome, Firefox и Edge.
Они позволяют полностью скрыть методы от внешнего кода,
обеспечивая реальную инкапсуляцию.

**Пример кода:**

```javascript
class Example {
  #privateMethod() {
    console.log("Это приватный метод");
  }

  callPrivateMethod() {
    this.#privateMethod(); // Вызывает приватный метод внутри класса
  }
}

const obj = new Example();
obj.callPrivateMethod(); // "Это приватный метод"
obj.#privateMethod(); // Ошибка: Невозможно обратиться к приватному методу
```

---

**Вы сказали:**
Приватные методы добавляются на прямую для экземпляра ?
Или приватные методы доступны только через прототипы ?

**ChatGPT сказал:**
Приватные методы (обозначенные символом #) в JavaScript
добавляются непосредственно в контекст экземпляра класса, а не на прототип.
Это делает их доступными только внутри методов самого класса
и недоступными ни через прототип, ни напрямую из экземпляра.

**Пример:**

```javascript
class Example {
  #privateMethod() {
    console.log("Это приватный метод");
  }

  publicMethod() {
    this.#privateMethod(); // Работает
  }
}

const obj = new Example();
obj.publicMethod(); // "Это приватный метод"
console.log(obj.#privateMethod); // Ошибка: приватный метод недоступен
console.log(Example.prototype.#privateMethod); // Ошибка: отсутствует на прототипе
```

**Ключевые моменты:**

- Приватные методы не добавляются на прототип.
- Они доступны только внутри экземпляра, через методы самого класса.

// --------------------------------------------------------------------------------------- //

## \*МЕТОДЫ СОЗДАНИЯ ЦЕПОЧЕК

Что такое метод chaining?
Метод chaining — это возможность вызывать
несколько методов подряд на одном объекте.

**Например:**

```javascript
account.deposit(300).withdraw(100).requestLoan(5000);
```

Всё выполняется в одной строке, потому что
каждый метод возвращает объект, на котором вызван следующий метод.

**Почему chaining не работает по умолчанию?**
Когда метод ничего не возвращает (или возвращает undefined),
следующий вызов метода на undefined вызывает ошибку.

**Пример:**

```javascript
class Account {
  deposit(value) {
    this.balance = (this.balance || 0) + value;
  }
}

const acc = new Account();
acc.deposit(300).withdraw(100); // Ошибка: withdraw не может быть вызван на undefined
```

Метод deposit ничего не возвращает, и вызов withdraw приводит к ошибке.

**Решение: возвращать this**
Метод должен возвращать this, чтобы объект был доступен для следующего вызова.

**Пример:**

```javascript
class Account {
  constructor() {
    this.balance = 0;
  }

  deposit(value) {
    this.balance += value;
    return this; // Возвращаем объект
  }

  withdraw(value) {
    this.balance -= value;
    return this;
  }

  getBalance() {
    console.log(`Баланс: ${this.balance}`);
    return this;
  }
}

// Использование
const acc = new Account();
acc.deposit(300).withdraw(100).getBalance(); // Баланс: 200
```

**Подробное объяснение кода:**

- Создаём метод deposit:

  - Увеличивает balance на указанное значение.
  - Возвращает this, чтобы метод мог быть вызван цепочечно.

- Создаём метод withdraw:

  - Уменьшает balance на указанное значение.
  - Также возвращает this.

- Метод getBalance:
  - Просто выводит баланс в консоль.
  - Возвращает this, чтобы его можно было вызывать после других методов.

**Пошаговая работа chaining:**

```
acc.deposit(300) // deposit возвращает объект acc
  .withdraw(100) // withdraw вызывается на acc и возвращает acc
  .getBalance(); // getBalance вызывается на acc
```

**Преимущества:**

- Удобство: Уменьшает дублирование кода и упрощает чтение.
- Лаконичность: Код становится более компактным.
- Гибкость: Все операции можно выполнить в одной цепочке.

**Когда использовать chaining?**
Чейнинг полезен для классов с методами,
которые изменяют состояние объекта (например, операции с банковским счётом).

```

```
